// ===========================================================================//	Crystal.cp// ===========================================================================#include "Crystal.h"extern long double gPI;// ---------------------------------------------------------------------------//		¥ Crystal// ---------------------------------------------------------------------------Crystal::Crystal(){	r = actV = extV = ctcDist = polyV = diffV = 0.0;	neighbor = ctrSlice = 0;	ctrID = 0;}// ---------------------------------------------------------------------------//		¥ Crystal// ---------------------------------------------------------------------------Crystal::Crystal(Crystal &inXl){	ctr = inXl.ctr;	r = inXl.r;	actV = inXl.actV;	extV = inXl.extV;	ctcDist = inXl.ctcDist;	polyV = inXl.polyV;	diffV = inXl.diffV;	neighbor = inXl.neighbor;	ctrSlice = inXl.ctrSlice;	ctrID = inXl.ctrID;}// ---------------------------------------------------------------------------//		¥ operator= (Crystal &)// ---------------------------------------------------------------------------CrystalCrystal::operator= (Crystal &inXl){	static Crystal outXl;	(*this).ctr = inXl.ctr;	(*this).r = inXl.r;	(*this).actV = inXl.actV;	(*this).extV = inXl.extV;	(*this).ctcDist = inXl.ctcDist;	(*this).polyV = inXl.polyV;	(*this).diffV = inXl.diffV;	(*this).neighbor = inXl.neighbor;	(*this).ctrSlice = inXl.ctrSlice;	(*this).ctrID = inXl.ctrID;	outXl.ctr = inXl.ctr;	outXl.r = inXl.r;	outXl.actV = inXl.actV;	outXl.extV = inXl.extV;	outXl.ctcDist = inXl.ctcDist;	outXl.polyV = inXl.polyV;	outXl.diffV = inXl.diffV;	outXl.neighbor = inXl.neighbor;	outXl.ctrSlice = inXl.ctrSlice;	outXl.ctrID = inXl.ctrID;	return outXl;}// ---------------------------------------------------------------------------//		¥ operator== (Crystal &)// ---------------------------------------------------------------------------BooleanCrystal::operator== (Crystal &inXl){	return (	(ctr == inXl.ctr)								\			&&	(r	== inXl.r)									\			&&	(actV	== inXl.actV)							\			&&	(extV	== inXl.extV)							\			&&	(ctcDist	== inXl.ctcDist)					\			&&	(polyV	== inXl.polyV)						\			&&	(diffV	== inXl.diffV)						\			&&	(neighbor	== inXl.neighbor)				\			&&	(ctrSlice	== inXl.ctrSlice)				\			&&	(ctrID	== inXl.ctrID));}/*// ---------------------------------------------------------------------------//		¥ IntersectionVolume (Crystal &)// ---------------------------------------------------------------------------// Formula for the intersection volume is the two spherical caps done separately.//	Formula is given in CRC Math Tables & Formula, 30th Ed, pg. 314.floatCrystal::IntersectionVolume(Crystal &inXl){	double d = ctr.Distance(inXl.ctr);	double h1 = r - r * ((r*r + d*d - inXl.r * inXl.r) / (2 * r * d));	// comes from law of cosines	double h2 = r + inXl.r - h1 - d;	double V1 = gPI * h1 * h1 * (3 * r - h1) / 3;	double V2 = gPI * h2 * h2 * (3 * inXl.r - h2) / 3;	double vol = V1 + V2;	if (vol < 0)		return 0;	return vol;}*/