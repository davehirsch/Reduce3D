// ===========================================================================//	BoundingBox.h// ===========================================================================#pragma once#include "CReduceApp.h"#include "myLFileStream.h"#include "SideSet.h"#include "CrystalArray.h"#include "NumPtArray.h"#include "LProgressDialog.h"#include "ReduceConstants.h"#include "Point3DFloat.h"#include "Matrix4d.h"#include "CReducePrefs.h"enum VFCodes {kPrefVal = -1, kPrefValRough = -2};// ---------------------------------------------------------------------------//		¥ BoundingBox// ---------------------------------------------------------------------------class CReduceApp;//class CrystalHashTable;class	BoundingBox : public SideSet {	friend class BBView;	friend class CReduceApp;//	friend class CrystalHashTable;	public:		class SimulationErr{};	public:						BoundingBox();						BoundingBox(myLFileStream *inFile);						BoundingBox(BoundingBox &inBBox);		virtual			~BoundingBox();		void			Copy(BoundingBox &inBBox);		Boolean			PointInBox(Point3DFloat &inPt);		Boolean			XlTouchesBox(Crystal &inXl);		void			FindConvexHull();		Boolean			CheckedAgainstBounds();		float			SurfaceArea();		float			GetMaxDimension();		float			GetMinDimension();		float			VolumeMinusGuard(float guardWidth);		float			GetXMax(){return xMax.x;};		float			GetYMax(){return yMax.y;};		float			GetZMax(){return zMax.z;};		CrystalArray *	GetXls();		double		NearestSideDist(Point3DFloat &inPt);		float			GetPercentSphereInside(Point3DFloat inCtr, float inRadius, short inNumSpherePts);		inline SideSet	*GetExscribedCube() {return (mType == kRPBox ? this : mExscribedCube);};		inline SideSet	*GetInscribedBox() {return (mType == kRPBox ? this : mInscribedBox);};		void			SetOffset(Point3DFloat &inPt);	protected:		void			FindBoundPoints();		void			FindCenter();		void			DiscardInteriorPoints();		void			FindFirstSide();		NumberedPt		MinThetaPt(NumberedPt &inPt1, NumberedPt &inPt2,								NumberedPt &inPt3, Matrix4d &inMatrix,								short &coplanars);		float			Theta(float x1, float y1, float x2, float y2);		NumberedPt		&BendAroundSide (NumPtArray &coplanars, NumberedPt &pt1,								NumberedPt &pt2, NumberedPt &pt3);		void			FindCoplanars (NumPtArray &coplanars, Side &inSide);		Boolean			VerifySide (Side &inSide, NumberedPt* betterPt = nil, NumPtArray *coplanars = nil);		void			DoCoplanars (Side &ioSide, NumPtArray &coplanars);		short			CheckSides (Point3DFloat inPt1, Point3DFloat inPt2);		Boolean			FindNextEdge (short &nextSide, short &nextEdge);		void			FoldEdge (short nextSide, short nextEdge);		void			BetterInscribedBox();		Boolean			PrimitiveInBox(SideSet *inPrim);		void			Inflate();		void			FindBetterCenter();		void			AdjustToBounds();		void			ForceVolumeFraction(float inVolFraction, LProgressDialog *inProgress);		void			FixVolumeFraction(float inVolFraction, LProgressDialog *inProgress);		float			GetVolumeFraction(LProgressDialog *inProgress, long Tries = kPrefVal, HoleSet *inHoles = nil);		void			RandPtInPrimitiveNotHole(Point3DFloat &outPt, HoleSet *inHoles = nil);		float			GetMCVolFracGranularity(short mode);		void			MakeRandomSimulation(double *inRadiiList, LProgressDialog *inProgress,							Boolean inMatchingCTDataSet, float inVolFraction, HoleSet* inHoles=nil, float betafactorfactor=0);	protected:		CrystalArray		*theXls;		CReduceApp			*mTheApp;		NumPtArray			*mPtArray;		NumberedPt			xMin, xMax, yMin, yMax, zMin, zMax;		LProgressDialog 	*mProgress;		PrefStruct			*mPrefs;		SideSet				*mInscribedBox;		SideSet				*mExscribedCube;		Boolean				mShowModels;};