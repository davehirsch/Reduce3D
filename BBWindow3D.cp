#if TARGET_CPU_PPC//**************************************************************************************// Filename:	BBWindow3D.cp// Copyright © 1997 <YourNameHere>. All rights reserved.//// Description:	////**************************************************************************************// Revision History:// Thursday, February 6, 1997 - Original//**************************************************************************************#include "BBWindow3D.h"#include "ReduceConstants.h"#include "BoundingBox.h"#include "CrystalArray.h"#include "CReduceApp.h"#include "ErrorAlert.h"#include "CQD3DErrorWindow.h"		// for reporting QD3D errors#include "QD3D Debug Macros.h"#include "CReducePrefs.h"#include "CRendererMaker.h"#include "CCameraMaker.h"#include "CDrawContextMaker.h"#include "myLFileStream.h"//**************************************************************************************// Function:	CreateBBWindowStream//// Description: Creates a New BBWindow3D object from the data in a Stream.//// Inputs:	inStream	the source stream for the data//		// Outputs:	none	////**************************************************************************************BBWindow3D*	BBWindow3D::CreateBBWindow3DStream( PP::LStream	*inStream){	// extract any data specific to your class		// Then pass the rest of the stream to the base class	return (new BBWindow3D(inStream));}//**************************************************************************************// Function:	Default Constructor//// Description: Builds the BBWindow3D class.//// Inputs:	none//		// Outputs:	none	////**************************************************************************************BBWindow3D::BBWindow3D(){}//**************************************************************************************// Function:	Stream Constructor//// Description: Builds the BBWindow3D class from a PP Stream//// Inputs:	inStream//		// Outputs:	none	////**************************************************************************************BBWindow3D::BBWindow3D(PP::LStream *inStream)	: PP::LWindow(inStream){	mStorageObj = nil;	mLightGroup = nil;	mFileObj = nil;	mBBGroup = nil;	mXlGroup = nil;	mHlGroup = nil;	mView = nil;}//**************************************************************************************// Function:	Copy Constructor//// Description: Copies the BBWindow3D class.//// Inputs:	inOriginal	- The object to copy//		// Outputs:	none	////**************************************************************************************BBWindow3D::BBWindow3D(const BBWindow3D& inOriginal)	: PP::LWindow(inOriginal){}//**************************************************************************************// Function:	Destructor//// Description: Destroys the BBWindow3D class.//// Inputs:	none//		// Outputs:	none	////**************************************************************************************BBWindow3D::~BBWindow3D(){	if (mFileObj) 		Q3Object_Dispose(mFileObj);	mFileObj = nil;	if (mView) 		Q3Object_Dispose(mView);	mView = nil;	if (mBBGroup) 		Q3Object_Dispose(mBBGroup);	mBBGroup = nil;	if (mXlGroup) 		Q3Object_Dispose(mXlGroup);	mXlGroup = nil;	if (mHlGroup) 		Q3Object_Dispose(mHlGroup);	mHlGroup = nil;	if (mLightGroup) 		Q3Object_Dispose(mLightGroup);	mLightGroup = nil;	if (mStorageObj) 		Q3Object_Dispose(mStorageObj);	mStorageObj = nil;}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidBBWindow3D::FinishCreateSelf(){	TQ3Status status;	mTheApp = (CReduceApp *) PP::LCommander::GetTopCommander();	mTheBoundingBox = mTheApp->GetBBox();	mTheBB3DView = (LQD3DViewerPane *) FindPaneByID(k_3DViewerPane);	mTheXls = mTheBoundingBox->GetXls();	mTheHoles = mTheApp->GetHoles();		// Make the QD3D Error Message window.	void *dummy = CQD3DErrorWindow::GetInstance();	if (dummy == nil)		CQD3DErrorWindow::Install( this );	try {		MakeBBModel();		MakeXlsModel();		if (mTheHoles != nil)			MakeHolesModel();	} catch (QD3DFailedErr) {		// clean up	}		mView = Q3View_New();	TQ3FileObject theDataQuasiFile = MyGetHandleFile();	TQ3FileMode	theMode = kQ3FileModeNormal;	TQ3RendererObject theRenderer = MakeDefaultRenderer();	TQ3CameraObject theCamera = MakeDefaultCamera();	TQ3DrawContextObject theDC = MakeDefaultDrawContext();	status = ::Q3View_SetDrawContext(mView, theDC );	ThrowIfQ3Fail_(status);	status = Q3Object_Dispose(theDC);		status = ::Q3View_SetRenderer(mView, theRenderer );	ThrowIfQ3Fail_(status);	status = Q3Object_Dispose(theRenderer);		status = ::Q3View_SetCamera(mView, theCamera );	ThrowIfQ3Fail_(status);	status = Q3Object_Dispose(theCamera);		Q3File_OpenWrite(theDataQuasiFile, theMode);	Q3View_StartWriting(mView, theDataQuasiFile);	do {		if (mTheXls->HasBounds()) {			Q3Object_Submit(mXlGroup, mView);	// this line dictates which one starts			mCurModel = kXls;		} else {			Q3Object_Submit(mBBGroup, mView);	// this line dictates which one starts			mCurModel = kBBox;		}	} while (Q3View_EndWriting(mView) == kQ3ViewStatusRetraverse);	Q3File_Close(theDataQuasiFile);	Handle theHandle;	unsigned long size;	TQ3StorageObject theStorage;	Q3File_GetStorage(theDataQuasiFile, &theStorage);	Q3HandleStorage_Get(theStorage, &theHandle, &size);	mTheBB3DView->SpecifyData(theHandle, size);	status = Q3Object_Dispose(theDataQuasiFile);	status = Q3Object_Dispose(theStorage);	Show();	Select();	FocusDraw();}// ---------------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------------voidBBWindow3D::FindCommandStatus(	PP::CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName ){	switch (inCommand) {			case PP::cmd_Save:				outEnabled = (IsVisible());		break;		case cmd_ShowBBox:				outEnabled = (mBBGroup != nil);				outUsesMark = true;				outMark = (mCurModel == kBBox) ? checkMark : noMark;		break;		case cmd_ShowXls:				outEnabled = (mXlGroup != nil);				outUsesMark = true;				outMark = (mCurModel == kXls) ? checkMark : noMark;		break;		case cmd_ShowHoles:				outEnabled = (mHlGroup != nil);				outUsesMark = true;				outMark = (mCurModel == kHoles) ? checkMark : noMark;		break;		default:				mTheApp->FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);		break;	}}// ---------------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------------BooleanBBWindow3D::ObeyCommand(	PP::CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			case PP::cmd_Save:			Save3DModel();		break;		case cmd_ShowBBox:			mTheBB3DView->SpecifyGroup(mBBGroup);			mCurModel = kBBox;			Refresh();		break;		case cmd_ShowXls:			if (mXlGroup != nil) {				mTheBB3DView->SpecifyGroup(mXlGroup);				mCurModel = kXls;				Refresh();			}		break;		case cmd_ShowHoles:			if (mXlGroup != nil) {				mTheBB3DView->SpecifyGroup(mHlGroup);				mCurModel = kHoles;				Refresh();			}		break;		default:			if (!(cmdHandled = PP::LWindow::ObeyCommand(inCommand, ioParam)))				cmdHandled = mTheApp->ObeyCommand(inCommand, ioParam);		break;	}		return cmdHandled;}// ---------------------------------------------------------------------------------//		¥ MakeBBModel// ---------------------------------------------------------------------------------voidBBWindow3D::MakeBBModel(){	if (!mTheXls->HasBounds()) {		TQ3GeometryObject		thisTri;		TQ3TriangleData		thisTriDat;		TQ3GroupPosition		groupPos;		TQ3FileMode				theMode = 0;		TQ3Status				result;		TQ3ColorRGB				vertexColor = {.4, .4, 1.0};				mBBGroup = Q3DisplayGroup_New();		Side *thisSide;		for (short i=1; i<=mTheBoundingBox->GetCount(); i++) {	// for each side...			thisSide = (Side *) mTheBoundingBox->GetItemPtr(i);			MakeTriangle(*thisSide, thisTriDat);			thisTri = Q3Triangle_New(&thisTriDat);			MySetTriangleVerticesDiffuseColor (thisTri, vertexColor);						groupPos = Q3Group_AddObject(mBBGroup, thisTri);			if (groupPos == NULL)				throw QD3DFailedErr();			result = Q3Object_Dispose(thisTri);		}		thisSide = nil;		MakeTriangle(*thisSide, thisTriDat);	// clean up		MakeAxes(mBBGroup, mTheBoundingBox->GetXMax(),								mTheBoundingBox->GetYMax(),								mTheBoundingBox->GetZMax());	}}// ---------------------------------------------------------------------------------//		¥ MakeAxes// ---------------------------------------------------------------------------------voidBBWindow3D::MakeAxes(TQ3GroupObject &ioGroup, float xMax, float yMax, float zMax){	TQ3GroupPosition		groupPos;	TQ3Status				myResult;	TQ3LineData				thisLineDat;	TQ3GeometryObject		thisLine;	TQ3AttributeSet		myAttrSet;	TQ3ColorRGB				xAxisColor = {1.0, 0.0, 0.0};	TQ3ColorRGB				yAxisColor = {0.0, 1.0, 0.0};	TQ3ColorRGB				zAxisColor = {0.0, 0.0, 1.0};	TQ3ColorRGB				noAxisColor = {0.0, 0.0, 0.0};		thisLineDat.vertices[0].point.x = 0.0;	thisLineDat.vertices[0].point.y = 0.0;	thisLineDat.vertices[0].point.z = 0.0;	thisLineDat.vertices[0].attributeSet = NULL;	thisLineDat.vertices[1].attributeSet = NULL;	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = 0.0;	thisLineDat.vertices[1].point.z = 0.0;	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &xAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[1].point.x = 0.0;	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = 0.0;	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &yAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[1].point.x = 0.0;	thisLineDat.vertices[1].point.y = 0.0;	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &zAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[0].point.y = 0.0;	thisLineDat.vertices[0].point.z = (short) (zMax * 1.1);	thisLineDat.vertices[1].point.x = 0.0;	thisLineDat.vertices[1].point.y = 0.0;	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[0].point.y = 0.0;	thisLineDat.vertices[0].point.z = 0.0;	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = 0.0;	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[0].point.y = 0.0;	thisLineDat.vertices[0].point.z = 0.0;	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = 0.0;	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = 0.0;	thisLineDat.vertices[0].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[0].point.z = 0.0;	thisLineDat.vertices[1].point.x = 0.0;	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = 0.0;	thisLineDat.vertices[0].point.y = 0.0;	thisLineDat.vertices[0].point.z = (short) (zMax * 1.1);	thisLineDat.vertices[1].point.x = 0.0;	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = 0.0;	thisLineDat.vertices[0].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[0].point.z = 0.0;	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = 0.0;	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[0].point.y = 0.0;	thisLineDat.vertices[0].point.z = (short) (zMax * 1.1);	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = 0.0;	thisLineDat.vertices[0].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[0].point.z = (short) (zMax * 1.1);	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);	thisLineDat.vertices[0].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[0].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[0].point.z = 0.0;	thisLineDat.vertices[1].point.x = (short) (xMax * 1.1);	thisLineDat.vertices[1].point.y = (short) (yMax * 1.1);	thisLineDat.vertices[1].point.z = (short) (zMax * 1.1);	myAttrSet = Q3AttributeSet_New();	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &noAxisColor);	thisLineDat.lineAttributeSet = myAttrSet;	thisLine = ::Q3Line_New(&thisLineDat);	groupPos = Q3Group_AddObject(ioGroup, thisLine);	if (groupPos == NULL)		throw QD3DFailedErr();	myResult = Q3Object_Dispose(thisLine);	myResult = Q3Object_Dispose(myAttrSet);}// ---------------------------------------------------------------------------------//		¥ MakeXlsModel// ---------------------------------------------------------------------------------voidBBWindow3D::MakeXlsModel(){	TQ3GeometryObject		thisSphere;	TQ3EllipsoidData		thisSphereDat;	TQ3GroupPosition		groupPos;	TQ3FileMode				theMode = 0;	TQ3Status				result;	TQ3ColorRGB				XlColor = {1.0, .4, 0.4};	float						XlTransparency = 1;	// opaque		mXlGroup = Q3DisplayGroup_New();	TQ3StyleObject		theSubdivisionStyle = MakeSubdivisionStyle();	groupPos = Q3Group_AddObject(mXlGroup, theSubdivisionStyle);	Crystal *thisXl;	for (short i=1; i<=mTheXls->GetCount(); i++) {	// for each Xl...		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		MakeSphere(*thisXl, thisSphereDat, XlColor, XlTransparency);		thisSphere = Q3Ellipsoid_New(&thisSphereDat);				groupPos = Q3Group_AddObject(mXlGroup, thisSphere);		if (groupPos == NULL)			throw QD3DFailedErr();		result = Q3Object_Dispose(thisSphere);	}	thisXl = nil;	MakeSphere(*thisXl, thisSphereDat, XlColor, XlTransparency);	// clean up		result = Q3Object_Dispose(theSubdivisionStyle);	MakeAxes(mXlGroup, mTheBoundingBox->GetXMax(),							mTheBoundingBox->GetYMax(),							mTheBoundingBox->GetZMax());/*To check distribution of points on weighting sphere: 	static TQ3AttributeSet		myAttrSet=nil;				//attribute set for color	CReducePrefs			*mPrefs = mTheApp->GetPrefs();	TQ3GeometryObject		thisBox;	TQ3BoxData				thisBoxDat;	TQ3GroupPosition		groupPos;	TQ3FileMode				theMode = 0;	TQ3Status				result;	TQ3ColorRGB				XlColor = {1.0, .4, 0.4};	float						XlTransparency = 1;	// opaque	float	inRadius = 1;	mXlGroup = Q3DisplayGroup_New();	long	numInBox = 0;	double azimuth;	double radiusAtZ;	Point3DFloat thisPt;		for (long i = 1; i <= mPrefs->GetNumSpherePts(); i++) {		thisPt.z = inRadius * (1.0 - 2.0 * RandomDbl(0, 1));		radiusAtZ = sqrt(sqr(inRadius) - sqr(thisPt.z));		azimuth = RandomDbl(0, 2*pi);		thisPt.x = radiusAtZ * cos(azimuth);		thisPt.y = radiusAtZ * sin(azimuth);		Q3Point3D_Set(&thisBoxDat.origin, thisPt.x, thisPt.y, thisPt.z);		Q3Vector3D_Set(&thisBoxDat.orientation, 0, .06, 0);		Q3Vector3D_Set(&thisBoxDat.minorAxis, .06, 0, 0);		Q3Vector3D_Set(&thisBoxDat.majorAxis, 0, 0, .06);		if (myAttrSet == nil) {			myAttrSet = Q3AttributeSet_New();			result = Q3AttributeSet_Add						(myAttrSet, kQ3AttributeTypeDiffuseColor, &XlColor);		}		thisBoxDat.boxAttributeSet = myAttrSet;		thisBoxDat.faceAttributeSet = NULL;				thisBox = Q3Box_New(&thisBoxDat);		groupPos = Q3Group_AddObject(mXlGroup, thisBox);		if (groupPos == NULL)			throw QD3DFailedErr();		result = Q3Object_Dispose(thisBox);	}	MakeAxes(mXlGroup, 1, 1, 1);	result = Q3Object_Dispose(myAttrSet);*/}// ---------------------------------------------------------------------------------//		¥ MakeHolesModel// ---------------------------------------------------------------------------------voidBBWindow3D::MakeHolesModel(){	TQ3GeometryObject		thisSphere;	TQ3EllipsoidData		thisSphereDat;	TQ3GroupPosition		groupPos;	TQ3FileMode				theMode = 0;	TQ3Status				result;	TQ3ColorRGB				XlColor = {1.0, .4, 0.4};	float						XlTransparency = 1;	// opaque	TQ3ColorRGB				HoleColor = {0.4, 0.4, 1.0};	float						HoleTransparency = 0.01;		mHlGroup = Q3DisplayGroup_New();	TQ3StyleObject		theSubdivisionStyle = MakeSubdivisionStyle();	groupPos = Q3Group_AddObject(mHlGroup, theSubdivisionStyle);	Crystal *thisXl;	for (short i=1; i<=mTheXls->GetCount(); i++) {	// for each Xl...		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		MakeSphere(*thisXl, thisSphereDat, XlColor, XlTransparency);		thisSphere = Q3Ellipsoid_New(&thisSphereDat);				groupPos = Q3Group_AddObject(mHlGroup, thisSphere);		if (groupPos == NULL)			throw QD3DFailedErr();		result = Q3Object_Dispose(thisSphere);	}	thisXl = nil;	MakeSphere(*thisXl, thisSphereDat, XlColor, XlTransparency);	// clean up	for (short i=1; i<=mTheHoles->GetCount(); i++) {	// for each Hole...		thisXl = (Crystal *) mTheHoles->GetItemPtr(i);		MakeSphere(*thisXl, thisSphereDat, HoleColor, HoleTransparency);		thisSphere = Q3Ellipsoid_New(&thisSphereDat);				groupPos = Q3Group_AddObject(mHlGroup, thisSphere);		if (groupPos == NULL)			throw QD3DFailedErr();		result = Q3Object_Dispose(thisSphere);	}	thisXl = nil;	MakeSphere(*thisXl, thisSphereDat, XlColor, XlTransparency);	// clean up		result = Q3Object_Dispose(theSubdivisionStyle);	MakeAxes(mHlGroup, mTheBoundingBox->GetXMax(),							mTheBoundingBox->GetYMax(),							mTheBoundingBox->GetZMax());}// ---------------------------------------------------------------------------------//		¥ MakeSphere// ---------------------------------------------------------------------------------voidBBWindow3D::MakeSphere(Crystal &inXl, TQ3EllipsoidData &outSphereDat, TQ3ColorRGB &inColor,							float inTrans){	static TQ3AttributeSet		myAttrSet=nil;				/*attribute set for color*/	TQ3Status				myResult;	if (&inXl == nil) {		myResult = Q3Object_Dispose(myAttrSet);		myAttrSet = nil;	} else {		TQ3ColorRGB				transColor = {inTrans, inTrans, inTrans};				outSphereDat.origin.x = inXl.ctr.x;		outSphereDat.origin.y = inXl.ctr.y;		outSphereDat.origin.z = inXl.ctr.z;		outSphereDat.orientation.x = 0.0;		outSphereDat.orientation.y = 0.0;		outSphereDat.orientation.z = inXl.r;		outSphereDat.majorRadius.x = inXl.r;		outSphereDat.majorRadius.y = 0.0;		outSphereDat.majorRadius.z = 0.0;		outSphereDat.minorRadius.x = 0.0;		outSphereDat.minorRadius.y = inXl.r;		outSphereDat.minorRadius.z = 0.0;		outSphereDat.uMin = 0.0;		outSphereDat.uMax = 1.0;		outSphereDat.vMin = 0.0;		outSphereDat.vMax = 1.0;		outSphereDat.caps = kQ3EndCapNone;		outSphereDat.interiorAttributeSet = NULL;		if (myAttrSet == nil) {			/*Create a new empty attribute set.*/			myAttrSet = Q3AttributeSet_New();		//	if (myAttrSet == NULL)		//		return (kQ3Failure);			/*Add the specified color attribute to the attribute set.*/			myResult = Q3AttributeSet_Add						(myAttrSet, kQ3AttributeTypeDiffuseColor, &inColor);			myResult = Q3AttributeSet_Add						(myAttrSet, kQ3AttributeTypeTransparencyColor, &transColor);		//	if (myResult == kQ3Failure)		//		return (kQ3Failure);		//	myResult = Q3Geometry_SetAttributeSet ();		}		outSphereDat.ellipsoidAttributeSet = myAttrSet;	}}// ---------------------------------------------------------------------------------//		¥ MakeTriangle// ---------------------------------------------------------------------------------voidBBWindow3D::MakeTriangle(Side &inSide, TQ3TriangleData &outTriDat){	outTriDat.vertices[0].attributeSet = NULL;	outTriDat.vertices[0].point.x = inSide.pt1.x;	outTriDat.vertices[0].point.y = inSide.pt1.y;	outTriDat.vertices[0].point.z = inSide.pt1.z;	outTriDat.vertices[1].attributeSet = NULL;	outTriDat.vertices[1].point.x = inSide.pt2.x;	outTriDat.vertices[1].point.y = inSide.pt2.y;	outTriDat.vertices[1].point.z = inSide.pt2.z;	outTriDat.vertices[2].attributeSet = NULL;	outTriDat.vertices[2].point.x = inSide.pt3.x;	outTriDat.vertices[2].point.y = inSide.pt3.y;	outTriDat.vertices[2].point.z = inSide.pt3.z;	TQ3Status							myResult;				/*result code*/	static TQ3AttributeSet			myAttrSet = nil;		/*attribute set*/	TQ3ColorRGB				triColor = {1, .6, .6};	if (&inSide == nil) {		myResult = Q3Object_Dispose(myAttrSet);		myAttrSet = nil;	} else {		if (myAttrSet == nil) {			/*Create a new empty attribute set.*/			myAttrSet = Q3AttributeSet_New();		//	if (myAttrSet == NULL)		//		return (kQ3Failure);			/*Add the specified color attribute to the attribute set.*/			myResult = Q3AttributeSet_Add (myAttrSet, kQ3AttributeTypeDiffuseColor, &triColor);		//	if (myResult == kQ3Failure)		//		return (kQ3Failure);		//	myResult = Q3Geometry_SetAttributeSet ();		}		outTriDat.triangleAttributeSet = myAttrSet;	}}// ---------------------------------------------------------------------------------//		¥ MySetTriangleVerticesDiffuseColor// ---------------------------------------------------------------------------------// This listing is documented in full on page 5-7 of 3D Graphics Programming With QuickDraw 3D.TQ3Status BBWindow3D::MySetTriangleVerticesDiffuseColor 					(TQ3GeometryObject triangle, TQ3ColorRGB color){	TQ3AttributeSet					myAttrSet;				/*attribute set*/	TQ3Status							myResult;				/*result code*/	unsigned long						myIndex;					/*vertex index*/	/*Create a new empty attribute set.*/	myAttrSet = Q3AttributeSet_New();	if (myAttrSet == NULL)		return (kQ3Failure);	/*Add the specified color attribute to the attribute set.*/	myResult = Q3AttributeSet_Add				(myAttrSet, kQ3AttributeTypeDiffuseColor, &color);	if (myResult == kQ3Failure)		return (kQ3Failure);	/*Attach the attribute set to each triangle vertex.*/	for (myIndex = 0; myIndex < 3; myIndex++) {		myResult = Q3Triangle_SetVertexAttributeSet										(triangle, myIndex, myAttrSet);		if (myResult == kQ3Failure) {			myResult = Q3Object_Dispose(myAttrSet);			return (kQ3Failure);		}	}	myResult = Q3Object_Dispose(myAttrSet);	return (kQ3Success);}// ---------------------------------------------------------------------------------//		¥ MyGetHandleFile// ---------------------------------------------------------------------------------TQ3FileObject BBWindow3D::MyGetHandleFile (){	TQ3FileObject				myFileObj;	TQ3StorageObject			myStorageObj;	/*Create new storage object and new file object.*/	if(((myStorageObj = Q3HandleStorage_New(NULL, 0)) == NULL) 		|| ((myFileObj = Q3File_New()) == NULL)) 	{		if (myStorageObj) 			Q3Object_Dispose(myStorageObj);		return(NULL);	}	/*Set the storage for the file object.*/	Q3File_SetStorage(myFileObj, myStorageObj);	Q3Object_Dispose(myStorageObj);	return (myFileObj);}// ---------------------------------------------------------------------------------//		¥ MakeSubdivisionStyle// ---------------------------------------------------------------------------------TQ3StyleObject BBWindow3D::MakeSubdivisionStyle (){	TQ3StyleObject	theSubStyle;	TQ3SubdivisionStyleData	theSubData;	PrefStruct *thePrefs = mTheApp->GetPrefs();	theSubData.method = kQ3SubdivisionMethodConstant;//	theSubData.method = kQ3SubdivisionMethodScreenSpace;	theSubData.c1 = (float)thePrefs->numQD3DEqPts;	theSubData.c2 = (float)thePrefs->numQD3DLngPts;	theSubStyle = ::Q3SubdivisionStyle_New(&theSubData);	return (theSubStyle);}// ---------------------------------------------------------------------------------//		¥ MakeDefaultRenderer// ---------------------------------------------------------------------------------TQ3RendererObject BBWindow3D::MakeDefaultRenderer (){	TQ3RendererObject		myRendererObj;	CRendererMaker	maker;	myRendererObj = maker.GetRef();	return (myRendererObj);}// ---------------------------------------------------------------------------------//		¥ MakeDefaultCamera// ---------------------------------------------------------------------------------TQ3CameraObject BBWindow3D::MakeDefaultCamera (){	TQ3CameraObject		myCameraObj;	PP::SDimension16	frameSize;	mTheBB3DView->GetFrameSize(frameSize);	CCameraMaker	maker(frameSize);	myCameraObj = maker.GetRef();	return (myCameraObj);}// ---------------------------------------------------------------------------------//		¥ MakeDefaultDrawContext// ---------------------------------------------------------------------------------TQ3DrawContextObject BBWindow3D::MakeDefaultDrawContext (){	TQ3DrawContextObject		myDCObj;	Rect	frame;	PP::SDimension16	frameSize;	PP::SPoint32			frameLoc;	mTheBB3DView->GetFrameSize(frameSize);	mTheBB3DView->GetFrameLocation(frameLoc);	frame.top = frameLoc.v;	frame.left = frameLoc.h;	frame.bottom = frameLoc.v + frameSize.height;	frame.right = frameLoc.h + frameSize.width;	CDrawContextMaker	maker((CGrafPort *) GetMacPort(), frame);	myDCObj = maker.GetRef();	return (myDCObj);}// ---------------------------------------------------------------------------------//		¥ Save3DModel// ---------------------------------------------------------------------------------void BBWindow3D::Save3DModel (){	try {		myLFileStream *SaveFile;		Str63	baseName;		mTheXls->GetFileName(baseName);		if (baseName[0] > 26)			baseName[0] = 26;		PP::LString::AppendPStr(baseName, "\p.3DMF");		SaveFile = new myLFileStream("\pName the 3DMF file", baseName);						TQ3FileObject				myFileObj;		TQ3StorageObject			myStorageObj;		TQ3Status					myResult;				FSSpec theSaveSpec;		SaveFile->GetSpecifier(theSaveSpec);		if (SaveFile->IsReplacing()) {			OSErr myErr = ::FSpDelete(&theSaveSpec);			ThrowIfOSErr_(myErr);		}		SaveFile->CreateNewDataFile(FlyThrough_fileCreator, '3DMF');		/*Create new storage object and new file object.*/		if(((myStorageObj = Q3FSSpecStorage_New(&theSaveSpec)) == NULL) 			|| ((myFileObj = Q3File_New()) == NULL)) 		{			if (myStorageObj) 				Q3Object_Dispose(myStorageObj);			return;		}		/*Set the storage for the file object.*/		myResult = Q3File_SetStorage(myFileObj, myStorageObj);//		TQ3FileMode	theMode = kQ3FileModeStream;		myResult = Q3File_OpenWrite(myFileObj, NULL);		ThrowIfQ3Error_();		Q3View_StartWriting(mView, myFileObj);		do {			switch (mCurModel) {				case kBBox:					Q3Object_Submit(mBBGroup, mView);				break;				case kXls:					Q3Object_Submit(mXlGroup, mView);				break;				case kHoles:					Q3Object_Submit(mHlGroup, mView);				break;			}		} while (Q3View_EndWriting(mView) == kQ3ViewStatusRetraverse);		Q3Object_Dispose(myStorageObj);		Q3File_Close(myFileObj);		Q3Object_Dispose(myFileObj);		delete SaveFile;	} catch (myLFileStream::CancelErr) {		// user canceled file selection dialog; do nothing	}}#pragma mark === Non-PPC Stubs ===#else	//non-PPC, will never be called, stubs only	#include "BBWindow3D.h"	#include "ReduceConstants.h"	#include "CReduceApp.h"	BBWindow3D*	BBWindow3D::CreateBBWindow3DStream( PP::LStream	*inStream)	{return (new BBWindow3D(inStream));}	BBWindow3D::BBWindow3D(PP::LStream *inStream): PP::LWindow(inStream){}	BBWindow3D::~BBWindow3D(){}	void BBWindow3D::FinishCreateSelf(){mTheApp = (CReduceApp *) PP::LCommander::GetTopCommander();}	Boolean BBWindow3D::ObeyCommand(PP::CommandT inCommand,void *ioParam)		{return mTheApp->ObeyCommand(inCommand, ioParam);}	void BBWindow3D::FindCommandStatus(PP::CommandT inCommand,		Boolean &outEnabled,	Boolean &outUsesMark,Char16 &outMark,Str255 outName)			{mTheApp->FindCommandStatus(inCommand, outEnabled,outUsesMark, outMark, outName);}#endif