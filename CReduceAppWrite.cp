// =================================================================================//	CReduceAppComp.cp						// =================================================================================#include "CReduceApp.h"#include "CReducePrefs.h"#include "myLFileStream.h"#include "BoundingBox.h"#include "ErrorAlert.h"#include <LString.h>extern long double gPI;// ---------------------------------------------------------------------------//		¥ DoMeanCumCSD// ---------------------------------------------------------------------------voidCReduceApp::DoMeanCumCSD(){	float		rad;	CFloatArray	meanCSD;	float		thisCSDVal;	short		i, index;	long		numXls=0;	// Zero out the CSD array data	float temp = 0.0;	for (i=1; i<= mPrefs->numClassesMeanCSD; i++) {		meanCSD.Push(&temp);	}		mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {			rad = thisXl->r;	// uses extV instead of actV 			index = mPrefs->numClassesMeanCSD - trunc((rad /					(mStats->meanR * mPrefs->maxValueMeanCSD)) *					(mPrefs->numClassesMeanCSD)) + 1;			if (index < 1)				index = 1;			numXls++;			meanCSD.Update(index, (meanCSD[index] + 1));		}	}	mTheXls->Unlock();		for (i=1; i <= mPrefs->numClassesMeanCSD; i++) {	// convert to percent 		thisCSDVal = meanCSD[i];		thisCSDVal *= (100.0 / numXls);		meanCSD.Update(i, thisCSDVal);	}	SaveCSD(meanCSD, kMeanCumCSD);}// ---------------------------------------------------------------------------------//		¥ SaveCSD// ---------------------------------------------------------------------------------voidCReduceApp::SaveCSD(CFloatArray &inCSD, short inCSDKind, float binSize){	FSSpec theSpec;	mInputFile->GetSpecifier(theSpec);	LStr255 newName = MakeCSDFileName(theSpec.name, inCSDKind);		FSSpec outSpec;	outSpec.vRefNum = (mInputFile->GetSpec()).vRefNum;	outSpec.parID = (mInputFile->GetSpec()).parID;	LString::CopyPStr(newName, outSpec.name, sizeof(Str63));		mCSDOutputFile = new myLFileStream(outSpec);	switch (inCSDKind) {		case kReduce:			mCSDOutputFile->CreateNewFile(GraphCFsFileCreator, 'TEXT');		break;		default:			mCSDOutputFile->CreateNewDataFile(CW_fileCreator, 'TEXT');		break;	}	mCSDOutputFile->OpenDataFork(fsRdWrPerm);	WriteCSD(inCSD, inCSDKind, binSize);	mCSDOutputFile->CloseDataFork();	if (inCSDKind == kReduce) {	// write the current prefs into a resource, as an indelible record.		LHandleStream theHStream;/*		mPrefsHolder->WritePrefsToStream(theHStream, mPrefs);		SInt16 prefFileResNum = mCSDOutputFile->OpenResourceFork(fsRdWrPerm);		::UseResFile(prefFileResNum);		::AddResource (theHStream.DetachDataHandle(), 'pref', 128, "\pthe Default Prefs-PPC");		ThrowIfResError_();		::UpdateResFile(prefFileResNum);	// actually removes the resource from the app		ThrowIfResError_();		mCSDOutputFile->CloseResourceFork();*/	}		delete mCSDOutputFile;	mCSDOutputFile = nil;}// ---------------------------------------------------------------------------------//		¥ MakeCSDFileName// ---------------------------------------------------------------------------------LStr255CReduceApp::MakeCSDFileName(Str63 inOldName, short inCSDKind){	static LStr255 outName;	LStr255 tryStr;	TString<Str63> tempStr;	TString<Str63> newName;	UInt8 suffix = NULL;	Boolean goodName = true;	short tryNumber = 0;	static Boolean alreadyShownAlert = false;		tempStr = inOldName;	newName = tempStr;	suffix = newName.ReverseFind(".int", 4);	if (suffix == NULL)		suffix = newName.ReverseFind(".Int", 4);	if (suffix == NULL)		suffix = newName.ReverseFind(".INT", 4);	if (suffix != NULL) {		newName.Remove(suffix, newName.Length());	}	if (newName.Length() > (31-5)) {		if (!alreadyShownAlert) {			ErrorAlert theAlert("\pName Too Long", "\pYour integrate file's name is too long to use as a root for the save files.  The name will be truncated.", 0.1);			alreadyShownAlert = true;		}		newName.Remove(27, newName.Length());	// Truncate to 26 chars	}	do {		switch (inCSDKind) {			case kMeanCumCSD:				if (newName.Length() < 24)					newName.Append(".MeanCSD", 8);				else					newName.Append(".CSD1", 5);			break;			case kMaxCumCSD:				if (newName.Length() < 25)					newName.Append(".MaxCSD", 7);				else					newName.Append(".CSD2", 4);			break;			case kLogCSD:				if (newName.Length() < 25)					newName.Append(".LogCSD", 7);				else					newName.Append(".CSD3", 5);			break;			case kNNCSD:				if (newName.Length() < 26)					newName.Append(".NNCSD", 6);				else					newName.Append(".CSD5", 5);			break;			case kRegCSD:				if (newName.Length() < 25)					newName.Append(".RegCSD", 7);				else					newName.Append(".CSD4", 5);			break;			case kRedStats:				if (newName.Length() < 21)					newName.Append(".MeanCSD", 11);				else					newName.Append(".R3ST", 5);			break;			case kReduce:				if (newName.Length() < 23)					newName.Append(".Reduce3D", 9);				else					newName.Append(".RED3", 5);			break;			case kEnvelope:				if (newName.Length() < 23)					newName.Append(".Envelope", 9);				else					newName.Append(".ENV", 4);			break;			case kIntegrate:				if (newName.Length() < 26)					newName.Append(".Shave", 6);				else					newName.Append(".SHAV", 5);			break;		}		FSSpec tempSpec;		::FSMakeFSSpec((mInputFile->GetSpec()).vRefNum, (mInputFile->GetSpec()).parID, newName, &tempSpec);		if (myLFileStream::FileExists(tempSpec) || (mPrefs->doShave && tryNumber == 0)) { 			tryNumber++;			tryStr.Assign((SInt32)tryNumber);			tryStr = "\p." + tryStr;			newName.Remove(newName.ReverseFind('.'), 63);	// remove whatever suffix we'd appended			if (tryNumber > 1)	// if this is the second time through here				newName.Remove(newName.ReverseFind('.'), 63);	// then we need to remove the try number string we added last time			short overage;			if ((overage = newName.Length() + tryStr.Length() - (31-5)) > 0)	// truncate base to make room for try number string				newName.Remove(newName.Length() + 1 - overage, 63);			newName += tryStr;			goodName = false;		} else {			goodName = true;		}	} while (!goodName);	outName = newName;	return outName;}// ---------------------------------------------------------------------------------//		¥ WriteCSD// ---------------------------------------------------------------------------------voidCReduceApp::WriteCSD(CFloatArray &inCSD, short inCSDKind, float binSize){	char	theStr[kStdStringSize];	char	theTitleStr[kStdStringSize];	short	numBins;	float	cumPct;	short	i;		switch (inCSDKind) {		case kMeanCumCSD:			mCSDOutputFile->putOneLine("Mean Cumulative CSD (CSD1); Reduce3D 2.2\n");			sprintf(theTitleStr, "Mean (x%3.2f) normalized size distribution data\n", mPrefs->maxValueMeanCSD);		break;		case kMaxCumCSD:			mCSDOutputFile->putOneLine("Max Cumulative CSD (CSD2); Reduce3D 2.2\n");			sprintf(theTitleStr, "Max normalized size distribution data\n");		break;		case kLogCSD:			mCSDOutputFile->putOneLine("Log CSD (CSD3); Reduce3D 2.2\n");			sprintf(theTitleStr, "Logarithmic size distribution data\n");		break;		case kNNCSD:			mCSDOutputFile->putOneLine("Nearest-Neighbor CSD (CSD5); Reduce3D 2.2\n");			sprintf(theTitleStr, "Nearest-neighbor size distribution data\n");		break;		case kRegCSD:			mCSDOutputFile->putOneLine("Regular CSD (CSD4); Reduce3D 2.2\n");			sprintf(theTitleStr, "Regular size distribution data, delta L = %3.3f cm\n", mPrefs->deltaLRegCSD);		break;		case kRedStats:			WriteRedStatsFile();		break;		case kReduce:			WriteReduceFile();		break;		case kIntegrate:			WriteIntFile();		break;	}	if (inCSDKind != kRedStats && inCSDKind != kReduce && inCSDKind != kIntegrate) {		numBins = inCSD.GetCount();		mCSDOutputFile->putOneLine(mTheXls->GetIntComment());		mCSDOutputFile->putOneLine("\n");		if (inCSDKind == kNNCSD) {			sprintf(theStr, "Number of valid crystals:\t%hi\n", mStats->numNNRad);			mCSDOutputFile->putOneLine(theStr);			sprintf(theStr, "Mean nearest neighbor size:\t%f\n", mStats->meanNNRad);			mCSDOutputFile->putOneLine(theStr);		} else {			sprintf(theStr, "Number of positive crystals:\t%hi\n", mStats->totalPosXls);			mCSDOutputFile->putOneLine(theStr);		}		mCSDOutputFile->putOneLine(theTitleStr);		switch (inCSDKind) {			case kMeanCumCSD:			case kMaxCumCSD:				mCSDOutputFile->putOneLine("bin\tcum\tnoncum\n");			break;			case kLogCSD:			case kNNCSD:			case kRegCSD:				mCSDOutputFile->putOneLine("bin\tpercent\n");			break;		}		cumPct = 0.0;		for (i=1; i <= numBins; i++) {			cumPct += inCSD[i];			switch (inCSDKind) {				case kMeanCumCSD:				case kMaxCumCSD:					sprintf(theStr, "%10.5f\t%10.5f\t%10.5f\n",  (1.0 * i / numBins), cumPct, inCSD[i]);					mCSDOutputFile->putOneLine(theStr);				break;				case kLogCSD:					sprintf(theStr, "%10.5f\t%10.5f\n",  (1.0 * i / numBins), inCSD[i]);					mCSDOutputFile->putOneLine(theStr);				break;				case kNNCSD:				case kRegCSD:					sprintf(theStr, "%10.5f\t%10.5f\n", (i * binSize), inCSD[i]);					mCSDOutputFile->putOneLine(theStr);				break;			}		}	}}// ---------------------------------------------------------------------------//		¥ DoMaxCumCSD// ---------------------------------------------------------------------------voidCReduceApp::DoMaxCumCSD(){	float		rad, maxRad;	CFloatArray	maxCSD;	float		thisCSDVal;	short		i, index;	rad = 0.0;	// temp use of rad	for (i=1; i<= mPrefs->numClassesMaxCSD; i++) {		maxCSD.Push(&rad);	}	maxRad = CubeRoot(3.0 * mStats->maxActV / (4.0 * gPI));	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {			rad = thisXl->r;	// uses extV instead of actV 			index = mPrefs->numClassesMaxCSD - trunc((rad / mStats->maxR) *					(mPrefs->numClassesMaxCSD - 0.0001));			if (index < 1)				index = 1;			maxCSD.Update(index, (maxCSD[index] + 1));		}	}	mTheXls->Unlock();		for (i=1; i <= mPrefs->numClassesMaxCSD; i++) {	// convert to percent 		thisCSDVal = maxCSD[i];		thisCSDVal *= (100.0 / mStats->numCrystals);		maxCSD.Update(i, thisCSDVal);	}	SaveCSD(maxCSD, kMaxCumCSD);}// ---------------------------------------------------------------------------//		¥ DoLogCsd// ---------------------------------------------------------------------------voidCReduceApp::DoLogCsd(){	float	rad, maxRad;	CFloatArray	logCSD, tempCSD;	short	i, index;	float	binWidth, avgSlope, slope1, slope2;	rad = 0.0;	// temp use of rad	for (i=1; i<= mPrefs->numClassesLogCSD; i++) {		logCSD.Push(&rad);		tempCSD.Push(&rad);	}	maxRad = CubeRoot(3.0 * mStats->maxActV / (4.0 * gPI));			// allocate crystals to bins 	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {			rad = thisXl->r;	// uses extV instead of actV 			index = 1 + trunc((rad / mStats->maxR) * (mPrefs->numClassesLogCSD - 0.0001));			if (index < 1)				index = 1;			tempCSD.Update(index, (tempCSD[index] + 1));		}	}	mTheXls->Unlock();			// convert to cumulate totals 	for (i=2; i <= mPrefs->numClassesLogCSD; i++) {	// convert to percent		tempCSD.Update(i, (tempCSD[i] + tempCSD[i-1]));	}			// normalize to unit volume 	for (i=1; i <= mPrefs->numClassesLogCSD; i++) {	// convert to percent 		tempCSD.Update(i, (tempCSD[i] / mStats->BBVolume));	}			// convert to logarithms of slopes of cumulate curves 	binWidth = mStats->maxR / mPrefs->numClassesLogCSD;	avgSlope = (tempCSD[2] - tempCSD[1]) / binWidth;	if (avgSlope > 0)		logCSD.Update(1, log(avgSlope));	else		logCSD.Update(1, 0.0);		avgSlope = (tempCSD[mPrefs->numClassesLogCSD] - tempCSD[mPrefs->numClassesLogCSD - 1]) / binWidth;	if (avgSlope > 0)		logCSD.Update(mPrefs->numClassesLogCSD, log(avgSlope));	else		logCSD.Update(mPrefs->numClassesLogCSD, 0.0);	for (i=2; i <= mPrefs->numClassesLogCSD-1; i++) {		slope1 = (tempCSD[i] - tempCSD[i-1]) / binWidth;		slope2 = (tempCSD[i+1] - tempCSD[i]) / binWidth;		avgSlope = (slope1 + slope2) / 2.0;		if (avgSlope > 0)			logCSD.Update(i, log(avgSlope));		else			logCSD.Update(i, 0.0);	}		SaveCSD(logCSD, kLogCSD);}// ---------------------------------------------------------------------------//		¥ DoNNCSD// ---------------------------------------------------------------------------voidCReduceApp::DoNNCSD(){	CFloatArray	NNCSD;	short		i, index;	Boolean		overstepCSD;	long		numXls=0;	overstepCSD = false;		float maxNNRad = mStats->maxNNRad;	float binSize = maxNNRad / kNumBinsNNCSD;	float dummy = 0.0;	for (i=1; i<=kNumBinsNNCSD; i++) {		NNCSD.Push(&dummy);	}	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		Crystal *neighborXl = (Crystal *) mTheXls->GetItemPtr(thisXl->neighbor);		if ((thisXl->r > 0) && (thisXl->neighbor > 0)) {			index = trunc(neighborXl->r / binSize) + 1;			if (index > kNumBinsNNCSD) {				index = kNumBinsNNCSD;				overstepCSD = true;			}			numXls++;			NNCSD.Update(index, (NNCSD[index] + 1));		}	}	mTheXls->Unlock();		for (i=1; i <= kNumBinsNNCSD; i++) {	// convert to percent 		NNCSD.Update(i, NNCSD[i] * 100.0 / numXls);	}	SaveCSD(NNCSD, kNNCSD, binSize);}// ---------------------------------------------------------------------------//		¥ DoRegCSD// ---------------------------------------------------------------------------voidCReduceApp::DoRegCSD(){	CFloatArray	regCSD;	short		i, index;	Boolean		overstepCSD;	long		numXls=0;	overstepCSD = false;		float dummy = 0.0;	for (i=1; i<=kNumBinsRegCSD; i++) {		regCSD.Push(&dummy);	}	float maxRad = mStats->maxR;	float binSize = maxRad / kNumBinsRegCSD;	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);// DMH 8/25/05 - this routine now ignores negative radii here and takes the absolute value.//	Formerly, it only wrote the radii data if the radii were positive.  (Radii can be//	negative as a signal from Crystallize that they have some problem).		index = trunc(fabs(thisXl->r) / binSize) + 1;	// CFloatArray is 1-based		if (index > kNumBinsRegCSD) {			index = kNumBinsRegCSD;			overstepCSD = true;		}		numXls++;		regCSD.Update(index, (regCSD[index] + 1));	}	mTheXls->Unlock();		for (i=1; i <= kNumBinsRegCSD; i++) {	// convert to percent 		regCSD.Update(i, regCSD[i] * (100.0 / numXls));	}	SaveCSD(regCSD, kRegCSD, binSize);}// ---------------------------------------------------------------------------//		¥ DoReduce3DFile// ---------------------------------------------------------------------------voidCReduceApp::DoReduce3DFile(){	CFloatArray	regCSD;		SaveCSD(regCSD, kReduce);}// ---------------------------------------------------------------------------//		¥ DoRedStatsFile// ---------------------------------------------------------------------------voidCReduceApp::DoRedStatsFile(){	CFloatArray	regCSD;		SaveCSD(regCSD, kRedStats);}// ---------------------------------------------------------------------------//		¥ WriteRedStatsFile// ---------------------------------------------------------------------------voidCReduceApp::WriteRedStatsFile(){	ErrorAlert theAlert("\pObsolete", "\pAttempt to call obsolete function: WriteRedStatsFile.  Data will be written, but not complete.");	char	theStr[kStdStringSize];	short	i;		sprintf(theStr, "%s\n", (mCSDOutputFile->GetSpec()).name);	mCSDOutputFile->putOneLine(theStr);// write identifier for file type	mCSDOutputFile->putOneLine("Reduce3D 2.2\n");// write number of crystals	sprintf(theStr, "%5hi\n", mStats->numCrystals);	mCSDOutputFile->putOneLine(theStr);// write total area or volume	sprintf(theStr, "%10.5f\n", mStats->BBVolume);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->surfaceArea);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->surfaceToVolRatio);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->xlVolFraction);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->xlDensity);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for radius	sprintf(theStr, "%10.5f\n", mStats->minR);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxR);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanR);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdRadius);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->skewness);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->kurtosis);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for extended volume	sprintf(theStr, "%10.5f\n", mStats->minExtV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxExtV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanExtV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdExtVol);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for actual volume	sprintf(theStr, "%10.5f\n", mStats->minActV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxActV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanActV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdActVol);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->numEngulfed);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for nearest-neighbor distance	sprintf(theStr, "%10.5f\n", mStats->minSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->numSep);	mCSDOutputFile->putOneLine(theStr);// write ordering index	sprintf(theStr, "%10.5f\n", mStats->orderingIndex);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->orderingTTest);	mCSDOutputFile->putOneLine(theStr);// write "isolation index" stats	sprintf(theStr, "%10.5f\n", mStats->meanNNRad);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdNNRad);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->numNNRad);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->isolationIndex);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->isolationTTest);	mCSDOutputFile->putOneLine(theStr);// write quadrat stat// WriteLn(outputFile, 'Quadrat stat mean:       ', quadratStatMean : 10 : 5);// WriteLn(outputFile, 'Quadrat stat esd:        ', quadratStatEsd : 10 : 5);	sprintf(theStr, "n/c\n");	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "n/c\n");	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->circQuadratStatMean);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->circQuadratStatEsd);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->quadratStatDOF);	mCSDOutputFile->putOneLine(theStr);// write random point stat	sprintf(theStr, "%10.5f\n", mStats->RPStatMean);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->RPStatEsd);	mCSDOutputFile->putOneLine(theStr);// write Avrami test parameters// fixif ((mStats->fileType != kDiffSimulation) || mPrefs->doImpingement) {		sprintf(theStr, "%10.5f\n", mStats->actualVol);		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "%10.5f\n", mStats->extendedVol);		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "%10.5f\n", mStats->extendedVolRand);		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "%10.5f\n", mStats->avramiRatio);		mCSDOutputFile->putOneLine(theStr);	} else {		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);	}// write new stats, deciles	sprintf(theStr, "%10.5f\n", mStats->myStat1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->myStat2);	mCSDOutputFile->putOneLine(theStr);	for (i = 1; i <= 9; i++) {		sprintf(theStr, "%10.5f\n", mStats->deciles[i]);		mCSDOutputFile->putOneLine(theStr);	}	for (i = 1; i <= mStats->numLPoints; i++) {		// write h Distances		sprintf(theStr, "%10.5f\n", mStats->hDistances[i]);		mCSDOutputFile->putOneLine(theStr);	}	for (i = 1; i <= mStats->numLPoints; i++) {		// write K values		sprintf(theStr, "%10.5f\n", mStats->LValues[i]);		mCSDOutputFile->putOneLine(theStr);	}}// ---------------------------------------------------------------------------//		¥ WriteIntFile// ---------------------------------------------------------------------------voidCReduceApp::WriteIntFile(short inEnvRun, float inOldMeanR, float inNewMeanR){	LStr255	firstLine("Reduce3D 2.3 ||");	mProgress->SetTitle("\pOutput Progress");	if (inEnvRun == -1) {		mProgress->SetActionDescriptor("\pWriting Integrate File");	// write identifier for file type		if (mPrefs->doShave) {			firstLine = TrimNL(firstLine) + "\pShaved "						+ FltStr(mShaveIteration * mPrefs->shaveIncrement, 2)						+ "\p%, ";			if (mPrefs->keepAspectRatios) {				firstLine += "\pkeeping AR,";			} else switch (mPrefs->shaveXYZ) {				case kX: firstLine += "\pin X, "; break;				case kY: firstLine += "\pin Y, "; break;				case kZ: firstLine += "\pin Z, "; break;			}			switch (mPrefs->direction) {				case kFromMax: firstLine += "\pfrom lg.values"; break;				case kSymmetric: firstLine += "\pfrom outside"; break;				case kFromMin: firstLine += "\pfrom sm.values"; break;			}		}	} else {		mProgress->SetActionDescriptor("\pWriting Envelope File");	// write identifier for envelope file		firstLine += "\p Envelope Output; Run number ";		firstLine += (LStr255) (SInt32) inEnvRun;		firstLine += "\p; Original Mean Radius = ";		firstLine += FltStr(inOldMeanR, 5);		firstLine += "\p; New Mean Radius = ";		firstLine += FltStr(inNewMeanR, 5);	}	firstLine += "\p\n";	mCSDOutputFile->putOneLine(firstLine);	CrystalArray *curXls = mBBox->GetXls();// write incoming comment line	LStr255 theStr(curXls->GetIntComment());	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write NumXls line	theStr = "\pNumber of crystals:\t" + (LStr255)(SInt32)curXls->GetCount() + "\p\n";	mCSDOutputFile->putOneLine(theStr);// write Volume line	theStr = "\pTotal volume:\t" + FltStr(mBBox->Volume(), 5) + "\p\n";	mCSDOutputFile->putOneLine(theStr);// write Bounds line	if ((mBBox->GetType() == kRPBox) || (mBBox->GetType() == kCubeBox)) {		theStr = "\pBounds:\t";		Point3DFloat lower, upper;		lower = (mBBox->GetXls())->LowerBound();		upper = (mBBox->GetXls())->UpperBound();		theStr += FltStr(lower.x, 3);		theStr += '\t';		theStr += FltStr(lower.y, 3);		theStr += '\t';		theStr += FltStr(lower.y, 3);		theStr += '\t';		theStr += FltStr(upper.x, 3);		theStr += '\t';		theStr += FltStr(upper.y, 3);		theStr += '\t';		theStr += FltStr(upper.z, 3);		theStr += '\n';		mCSDOutputFile->putOneLine(theStr);	}// write Xl data	mProgress->SetValues(1,curXls->GetCount(),1);	mProgress->Show();	Crystal thisXl;	for (short i = 1; i <= curXls->GetCount(); i++) {		mProgress->Progress(i);		curXls->FetchItemAt(i, &thisXl);		theStr = (LStr255)(SInt32)i + "\p\t" + FltStr(thisXl.ctr.x, 5) +			+ "\p\t" + FltStr(thisXl.ctr.y, 5) + "\p\t" + FltStr(thisXl.ctr.z, 5)			+ "\p\t" + FltStr(thisXl.r, 5) + "\p\t" + (LStr255)(SInt32) thisXl.ctrSlice			+ "\p\t" + (LStr255)(SInt32) thisXl.ctrID + "\p\n";		mCSDOutputFile->putOneLine(theStr);	}	mProgress->Hide();}// ---------------------------------------------------------------------------//		¥ WritePrefsSettings// ---------------------------------------------------------------------------voidCReduceApp::WritePrefsSettings(){	LStr255	theStr;	theStr = "\pincludeMeanCSD: ";	theStr += (SInt32) mPrefs->includeMeanCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pincludeMaxCSD: ";	theStr += (SInt32) mPrefs->includeMaxCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pincludeLogCSD: ";	theStr += (SInt32) mPrefs->includeLogCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pincludeRegCSD: ";	theStr += (SInt32) mPrefs->includeRegCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoQuadrat: ";	theStr += (SInt32) mPrefs->doQuadrat;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoOthers: ";	theStr += (SInt32) mPrefs->doOthers;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoRandomPt: ";	theStr += (SInt32) mPrefs->doRandomPt;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmake3DModel: ";	theStr += (SInt32) mPrefs->make3DModel;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputSigmas: ";	theStr += (SInt32) mPrefs->outputSigmas;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputCrystals: ";	theStr += (SInt32) mPrefs->outputCrystals;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputR3STT: ";	theStr += (SInt32) mPrefs->outputR3STT;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputReduce: ";	theStr += (SInt32) mPrefs->outputReduce;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoImpingement: ";	theStr += (SInt32) mPrefs->doImpingement;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumClassesMeanCSD: ";	theStr += mPrefs->numClassesMeanCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumClassesMaxCSD: ";	theStr += mPrefs->numClassesMaxCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumClassesLogCSD: ";	theStr += mPrefs->numClassesLogCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pquadratNumPlacings: ";	theStr += mPrefs->quadratNumPlacings;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pquadratNumReps: ";	theStr += mPrefs->quadratNumReps;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pRPNumPlacings: ";	theStr += mPrefs->RPNumPlacings;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pRPNumReps: ";	theStr += mPrefs->RPNumReps;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmaxValueMeanCSD: ";	theStr += FltStr(mPrefs->maxValueMeanCSD, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdeltaLRegCSD: ";	theStr += FltStr(mPrefs->deltaLRegCSD, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pimpingementMeanErr: ";	theStr += FltStr(mPrefs->impingementMeanErr, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pimpingementMaxErr: ";	theStr += FltStr(mPrefs->impingementMaxErr, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoLMcfPcf: ";	theStr += (SInt32) mPrefs->doLMcfPcf;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumNNDist: ";	theStr += mPrefs->numNNDist;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumCFOffsetVolPts: ";	theStr += mPrefs->numCFOffsetVolPts;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pEpanecnikovCVal: ";	theStr += FltStr(mPrefs->EpanecnikovCVal, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumQD3DEqPts: ";	theStr += mPrefs->numQD3DEqPts;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumQD3DLngPts: ";	theStr += mPrefs->numQD3DLngPts;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\psampleShape: ";	theStr += mPrefs->sampleShape;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumEnvelopeRuns: ";	theStr += mPrefs->numEnvelopeRuns;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pinflateBBox: ";	theStr += (SInt32) mPrefs->inflateBBox;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pobservabilityFilter: ";	theStr += (SInt32) mPrefs->observabilityFilter;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pcrit1Factor: ";	theStr += FltStr(mPrefs->crit1Factor, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pcrit2Factor: ";	theStr += FltStr(mPrefs->crit2Factor, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	if (mPrefs->doShave) {		theStr = TrimNL(theStr) + "\pShaved "					+ FltStr(mShaveIteration * mPrefs->shaveIncrement, 2)					+ "\p%, ";		if (mPrefs->keepAspectRatios) {			theStr += "\pkeeping AR,";		} else switch (mPrefs->shaveXYZ) {			case kX: theStr += "\pin X, "; break;			case kY: theStr += "\pin Y, "; break;			case kZ: theStr += "\pin Z, "; break;		}		switch (mPrefs->direction) {			case kFromMax: theStr += "\pfrom lg.values\n"; break;			case kSymmetric: theStr += "\pfrom outside\n"; break;			case kFromMin: theStr += "\pfrom sm.values\n"; break;		}	} else {		theStr = "\pNot shaved\n";	}	mCSDOutputFile->putOneLine(theStr);//	theStr = "\pdoShave";//	theStr += mPrefs->doShave;//	theStr += "\p\n";//	theStr = "\pkeepAspectRatios";//	theStr += mPrefs->keepAspectRatios;//	theStr += "\p\n";//	theStr = "\pshaveXYZ";//	theStr += mPrefs->shaveXYZ;//	theStr += "\p\n";//	theStr = "\pshaveIncrement";//	theStr += mPrefs->shaveIncrement;//	theStr += "\p\n";//	theStr = "\pdirection";//	theStr += mPrefs->direction;//	theStr += "\p\n";	theStr = "\pminPercent: ";	theStr += FltStr(mPrefs->minPercent, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pminPopulation: ";	theStr += mPrefs->minPopulation;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmaxAspectRatio: ";	theStr += FltStr(mPrefs->maxAspectRatio, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\psmaller: ";	theStr += (SInt32) mPrefs->smaller;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pShaveSave: ";	theStr += (SInt32) mPrefs->ShaveSave;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdiscardNegs: ";	theStr += (SInt32) mPrefs->discardNegs;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\puseRaeburn: ";	theStr += (SInt32) mPrefs->useRaeburn;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pconfidence: ";	theStr += mPrefs->confidence;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pseed: ";	theStr += mPrefs->seed;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMCReps: ";	theStr += mPrefs->MCReps;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\ptidyUp: ";	theStr += (SInt32) mPrefs->tidyUp;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\puseVolume: ";	theStr += (SInt32) mPrefs->useVolume;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poverlap: ";	theStr += mPrefs->overlap;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmatchVF: ";	theStr += (SInt32) mPrefs->matchVF;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmakeDCEnv: ";	theStr += (SInt32) mPrefs->makeDCEnv;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pverbose: ";	theStr += (SInt32) mPrefs->verbose;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pVFPercent: ";	theStr += FltStr(mPrefs->VFPercent, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmatchPDF: ";	theStr += (SInt32) mPrefs->matchPDF;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);}// ---------------------------------------------------------------------------//		¥ WriteReduceFile// ---------------------------------------------------------------------------voidCReduceApp::WriteReduceFile(){	short	i;	Crystal	thisXl;	LStr255	theStr;	theStr = (mInputFile->GetSpec()).name;	theStr += "\n";	mCSDOutputFile->putOneLine(theStr);// write identifier for file type	theStr = "\pReduce3D ";//	theStr += mPrefsHolder->GetVersStr();	theStr += "\n";	mCSDOutputFile->putOneLine(theStr);// write incoming comment line	LStr255 commentStr(mTheXls->GetIntComment());	commentStr += "\p\n";	mCSDOutputFile->putOneLine(commentStr);// write our processing params	mCSDOutputFile->putOneLine("\pProcessing Parameters:\n");	WritePrefsSettings();// write holes file reference	if (mHolesFile != nil) {		FSSpec theSpec;		theSpec = mHolesFile->GetSpec();		theStr = "\pHoles File: ";		theStr += theSpec.name;		theStr += "\p\n";	} else {		theStr = "Holes File: none\n";	}	mCSDOutputFile->putOneLine(theStr);// write number of crystals	theStr = "\pNumber of crystals:\t";	theStr += mStats->numCrystals;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	// write total area or volume	theStr = "\pTotal Volume (cubic cm):\t";	theStr += FltFStr(mStats->BBVolume, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSurface Area (sq cm):\t";	theStr += FltFStr(mStats->surfaceArea, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSurface to Volume Ratio:\t";	theStr += FltFStr(mStats->surfaceToVolRatio, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal Volume Fraction:\t";	theStr += FltFStr(mStats->xlVolFraction, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal density:\t";	theStr += FltFStr(mStats->xlDensity, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal intensity:\t";	theStr += FltFStr(mStats->intensity, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal Intensity Sqd:\t";	theStr += FltFStr(mStats->intensitySqd, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal Volume Fraction (MC Method):\t";	theStr += FltFStr(mStats->volFrxn, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for radius	theStr = "\pMinimum radius:\t";	theStr += FltFStr(mStats->minR, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum radius:\t";	theStr += FltFStr(mStats->maxR, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean radius:\t";	theStr += FltFStr(mStats->meanR, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltFStr(mStats->esdRadius, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSkewness:\t";	theStr += FltFStr(mStats->skewness, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pExcess Kurtosis:\t";	theStr += FltFStr(mStats->kurtosis, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for extended volume	theStr = "\pMinimum ext volume:\t";	theStr += FltFStr(mStats->minExtV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum ext volume:\t";	theStr += FltFStr(mStats->maxExtV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean ext volume:\t";	theStr += FltFStr(mStats->meanExtV, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanEVEnvMean : mStats->MeanEVEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanEVEnvStdDev : mStats->MeanEVEnvMax), 5);	theStr += "\p\n";		theStr = "\pMean ext volume:\t";	theStr += FltFStr(mStats->meanExtV, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanEVEnvMean : mStats->MeanEVEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanEVEnvStdDev : mStats->MeanEVEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltFStr(mStats->esdExtVol, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for actual volume	theStr = "\pMinimum act volume:\t";	theStr += FltFStr(mStats->minActV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum act volume:\t";	theStr += FltFStr(mStats->maxActV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean act volume:\t";	theStr += FltFStr(mStats->meanActV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltFStr(mStats->esdActVol, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pNum engulfed crystals:\t";	theStr += (SInt32) mStats->numEngulfed;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for nearest-neighbor distance	theStr = "\pMinimum separation:\t";	theStr += FltFStr(mStats->minSep, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MinSepEnvMean : mStats->MinSepEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MinSepEnvStdDev : mStats->MinSepEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum separation:\t";	theStr += FltFStr(mStats->maxSep, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean separation:\t";	theStr += FltFStr(mStats->meanSep, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanSepEnvMean : mStats->MeanSepEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanSepEnvStdDev : mStats->MeanSepEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltFStr(mStats->esdSep, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pNum valid crystals:\t";	theStr += (SInt32) mStats->numSep;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write ordering index	theStr = "\pOrdering index:\t";	theStr += FltFStr(mStats->orderingIndex, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->OIEnvMean : mStats->OIEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->OIEnvStdDev : mStats->OIEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pOrdering index t-test:\t";	theStr += FltFStr(mStats->orderingTTest, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write "isolation index" stats	theStr = "\pMean NN radius:\t";	theStr += FltFStr(mStats->meanNNRad, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanNNEnvMean : mStats->MeanNNEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->MeanNNEnvStdDev : mStats->MeanNNEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pEsd NN radius:\t";	theStr += FltFStr(mStats->esdNNRad, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pNum valid pairs:\t";	theStr += (SInt32) mStats->numNNRad;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pIsolation index:\t";	theStr += FltFStr(mStats->isolationIndex, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->IIEnvMean : mStats->IIEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->IIEnvStdDev : mStats->IIEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pIsolation index t-test:\t";	theStr += FltFStr(mStats->isolationTTest, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write quadrat stat// WriteLn(outputFile, 'Quadrat stat mean:       ', quadratStatMean : 10 : 5);// WriteLn(outputFile, 'Quadrat stat esd:        ', quadratStatEsd : 10 : 5);	theStr = "\pQuadrat stat mean:\tnc\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pQuadrat stat esd:\tnc\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSpherical quad stat mean:\t";	theStr += FltFStr(mStats->circQuadratStatMean, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->CQSMEnvMean : mStats->CQSMEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->CQSMEnvStdDev : mStats->CQSMEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSpherical quad stat esd:\t";	theStr += FltFStr(mStats->circQuadratStatEsd, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pQuadrat stat d.o.f:\t";	theStr += (SInt32) mStats->quadratStatDOF;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write random point stat	theStr = "\pRandom point stat mean:\t";	theStr += FltFStr(mStats->RPStatMean, 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->RPSMEnvMean : mStats->RPSMEnvMin), 5);	theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltFStr((mPrefs->outputSigmas ? mStats->RPSMEnvStdDev : mStats->RPSMEnvMax), 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pRandom point std dev:\t";	theStr += FltFStr(mStats->RPStatEsd, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write Avrami test parameters// fixif ((mStats->fileType != kDiffSimulation) || mPrefs->doImpingement) {		theStr = "\pAvrami act vol:\t";		theStr += FltFStr(mStats->actualVol, 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);		theStr = "\pAvrami ext vol:\t";		theStr += FltFStr(mStats->extendedVol, 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);		theStr = "\pAvrami ext vol rand:\t";		theStr += FltFStr(mStats->extendedVolRand, 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);		theStr = "\pAvrami ratio:\t";		theStr += FltFStr(mStats->avramiRatio, 5);		theStr += (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");		theStr += FltFStr((mPrefs->outputSigmas ? mStats->AREnvMean : mStats->AREnvMin), 5);		theStr += (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");		theStr += FltFStr((mPrefs->outputSigmas ? mStats->AREnvStdDev : mStats->AREnvMax), 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);	} else {		mCSDOutputFile->putOneLine("Avrami ext vol:\tn/c\n");		mCSDOutputFile->putOneLine("Avrami act vol:\tn/c\n");		mCSDOutputFile->putOneLine("Avrami ext vol rand:\tn/c\n");		mCSDOutputFile->putOneLine("Avrami ratio:\tn/c\n");	}// write new stats, deciles	theStr = "\pCSD shape stat 1 (skew):\t";	theStr += FltFStr(mStats->myStat1, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCSD shape stat 2 (flat):\t";	theStr += FltFStr(mStats->myStat2, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	mCSDOutputFile->putOneLine("Decile#\tDecile value\n");	for (i = 1; i <= 9; i++) {		theStr = (SInt32) i;		theStr += '\t';		theStr += FltFStr(mStats->deciles[i], 5);		theStr += '\n';		mCSDOutputFile->putOneLine(theStr);	}// write out run parameters	theStr = "\pMean CSD/Num Classes:\t";	theStr += (SInt32) (mPrefs->includeMeanCSD ? mPrefs->numClassesMeanCSD : -1);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean CSD/Max Val:\t";	theStr += (SInt32) (mPrefs->includeMeanCSD ? mPrefs->maxValueMeanCSD : -1);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMax CSD/Num Classes:\t";	theStr += (SInt32) (mPrefs->includeMaxCSD ? mPrefs->numClassesMaxCSD : -1);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pLog CSD/Num Classes:\t";	theStr += (SInt32) (mPrefs->includeLogCSD ? mPrefs->numClassesLogCSD : -1);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pReg CSD/Delta L:\t";	theStr += (SInt32) (mPrefs->includeRegCSD ? mPrefs->deltaLRegCSD : -1.0);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pImpingement Correction/Mean Err:\t";	theStr += (SInt32) (mPrefs->doImpingement ? mPrefs->impingementMeanErr : -1.0);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pImpingement Correction/Max Err:\t";	theStr += FltFStr((mPrefs->doImpingement ? mPrefs->impingementMaxErr : -1.0), 5);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pNumber of runs to calculate boundary envelopes:\t";	theStr += (SInt32) (mPrefs->numEnvelopeRuns);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pNum points in Offset Interesction Volume Monte Carlo:\t";	theStr += (SInt32) (mPrefs->doLMcfPcf ? mPrefs->numCFOffsetVolPts : -1);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pC value for Epanecnikov kernel bandwidth calc:\t";	theStr += FltFStr((mPrefs->doLMcfPcf ? mPrefs->EpanecnikovCVal : -1.0), 5);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);// write out correlation function results and stuff	theStr = "\pNumXlsUsed in L/PCF/MCF:\t";	theStr += (SInt32) (mPrefs->doLMcfPcf ? mStats->numXlsForL : -1);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean R of Xls used in L/PCF/MCF:\t";	theStr += FltFStr((mPrefs->doLMcfPcf ? mStats->newMeanR : -1.0), 5);	theStr += '\n';	mCSDOutputFile->putOneLine(theStr);		if (mDoSigmas) {		mCSDOutputFile->putOneLine("hDistance(cm)\tL value\tL Mean\tL SD\tLgd value\tLgd Mean\tLgd SD\tPCF\tPCF Mean\tPCF SD\tPCFgd\tPCFgd Mean\tPCFgd SD\tMCF\tMCF Mean\tMCF SD\tMCF3\tMCF3 Mean\tMCF3 SD\tMCFgd\tMCFgd Mean\tMCFgd SD\tMCF3gd\tMCF3gd Mean\tMCF3gd SD\n");	} else {		mCSDOutputFile->putOneLine("hDistance(cm)\tL value\tL Min\tL Max\tLgd value\tLgd Min\tLgd Max\tPCF\tPCF Min\tPCF Max\tPCFgd\tPCFgd Min\tPCFgd Max\tMCF\tMCF Min\tMCF Max\tMCF3\tMCF3 Min\tMCF3 Max\tMCFgd\tMCFgd Min\tMCFgd Max\tMCF3gd\tMCF3gd Min\tMCF3gd Max\n");	}	for (i = 1; i <= mStats->numLPoints; i++) {		if (mPrefs->numEnvelopeRuns == 0) {			theStr = FltFStr(mStats->hDistances[i], 5);			theStr += '\t';			theStr += FltFStr(mStats->LValues[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->LgdValues[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->PCF[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->PCFgd[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->MCF[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->MCFgd[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->MCF3[i], 5);			theStr += "\p\t\t";			theStr += FltFStr(mStats->MCF3gd[i], 5);			theStr += "\p\t\t\n";			mCSDOutputFile->putOneLine(theStr);		} else {			theStr = FltFStr(mStats->hDistances[i], 5);			theStr += '\t';			if (GoodCFVal(mStats->LValues[i]))				theStr += FltFStr(mStats->LValues[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->LValuesEnvMean[i] : mStats->LValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->LValuesEnvMean[i] : mStats->LValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->LValuesEnvStdDev[i] : mStats->LValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->LValuesEnvStdDev[i] : mStats->LValuesEnvMax[i], 5);			theStr += '\t';			if (GoodCFVal(mStats->LgdValues[i]))				theStr += FltFStr(mStats->LgdValues[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->LgdValuesEnvMean[i] : mStats->LgdValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->LgdValuesEnvMean[i] : mStats->LgdValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->LgdValuesEnvStdDev[i] : mStats->LgdValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->LgdValuesEnvStdDev[i] : mStats->LgdValuesEnvMax[i], 5);			theStr += '\t';			mCSDOutputFile->putOneLine(theStr);			theStr = "\p";			if (GoodCFVal(mStats->PCF[i]))				theStr += FltFStr(mStats->PCF[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->PCFValuesEnvMean[i] : mStats->PCFValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->PCFValuesEnvMean[i] : mStats->PCFValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->PCFValuesEnvStdDev[i] : mStats->PCFValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->PCFValuesEnvStdDev[i] : mStats->PCFValuesEnvMax[i], 5);			theStr += '\t';			if (GoodCFVal(mStats->PCFgd[i]))				theStr += FltFStr(mStats->PCFgd[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->PCFgdValuesEnvMean[i] : mStats->PCFgdValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->PCFgdValuesEnvMean[i] : mStats->PCFgdValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->PCFgdValuesEnvStdDev[i] : mStats->PCFgdValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->PCFgdValuesEnvStdDev[i] : mStats->PCFgdValuesEnvMax[i], 5);			theStr += '\t';			mCSDOutputFile->putOneLine(theStr);			theStr = "\p";			if (GoodCFVal(mStats->MCF[i]))				theStr += FltFStr(mStats->MCF[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCFValuesEnvMean[i] : mStats->MCFValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCFValuesEnvMean[i] : mStats->MCFValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCFValuesEnvStdDev[i] : mStats->MCFValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCFValuesEnvStdDev[i] : mStats->MCFValuesEnvMax[i], 5);			theStr += '\t';			if (GoodCFVal(mStats->MCF3[i]))				theStr += FltFStr(mStats->MCF3[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCF3ValuesEnvMean[i] : mStats->MCF3ValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCF3ValuesEnvMean[i] : mStats->MCF3ValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCF3ValuesEnvStdDev[i] : mStats->MCF3ValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCF3ValuesEnvStdDev[i] : mStats->MCF3ValuesEnvMax[i], 5);			theStr += '\t';			mCSDOutputFile->putOneLine(theStr);			theStr = "\p";			if (GoodCFVal(mStats->MCFgd[i]))				theStr += FltFStr(mStats->MCFgd[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCFgdValuesEnvMean[i] : mStats->MCFgdValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCFgdValuesEnvMean[i] : mStats->MCFgdValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCFgdValuesEnvStdDev[i] : mStats->MCFgdValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCFgdValuesEnvStdDev[i] : mStats->MCFgdValuesEnvMax[i], 5);			theStr += '\t';			if (GoodCFVal(mStats->MCF3gd[i]))				theStr += FltFStr(mStats->MCF3gd[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCF3gdValuesEnvMean[i] : mStats->MCF3gdValuesEnvMin[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCF3gdValuesEnvMean[i] : mStats->MCF3gdValuesEnvMin[i], 5);			theStr += '\t';			if (GoodCFVal(mDoSigmas ? mStats->MCF3gdValuesEnvStdDev[i] : mStats->MCF3gdValuesEnvMax[i]))				theStr += FltFStr(mDoSigmas ? mStats->MCF3gdValuesEnvStdDev[i] : mStats->MCF3gdValuesEnvMax[i], 5);			theStr += '\n';			mCSDOutputFile->putOneLine(theStr);		}	}	if (mPrefs->outputCrystals) {		// write labels for expanded raw data file		mCSDOutputFile->putOneLine("\pn\tx\ty\tz\tr\tvact\tvext\ts\tid\tnear\tdist\tvpoly\tedgeToEdge\n");		// write data		for (i=1; i <= mStats->numCrystals; i++) {			mTheXls->FetchItemAt(i, &thisXl);			theStr = (SInt32) i;			theStr += '\t';			theStr += FltFStr(thisXl.ctr.x, 5);			theStr += '\t';			theStr += FltFStr(thisXl.ctr.y, 5);			theStr += '\t';			theStr += FltFStr(thisXl.ctr.z, 5);			theStr += '\t';			theStr += FltFStr(thisXl.r, 5);			theStr += '\t';			theStr += FltFStr(thisXl.actV, 5);			theStr += '\t';			theStr += FltFStr(thisXl.extV, 5);			theStr += '\t';			theStr += (SInt32) thisXl.ctrSlice;			theStr += '\t';			theStr += (SInt32) thisXl.ctrID;			theStr += '\t';			theStr += (SInt32) thisXl.neighbor;			theStr += '\t';			theStr += FltFStr(thisXl.ctcDist, 5);			theStr += '\t';			theStr += FltFStr(thisXl.polyV, 5);			theStr += '\t';			theStr += FltFStr(thisXl.diffV, 5);			theStr += '\n';			mCSDOutputFile->putOneLine(theStr);		}	}}// ---------------------------------------------------------------------------//		¥ GoodCFVal// ---------------------------------------------------------------------------BooleanCReduceApp::GoodCFVal(double inVal){	if (mDoSigmas) {		if (inVal == 0)	// neither the mean nor the standard deviation will be exactly zero						// if the data was good			return false;	} else {		if (inVal == -(DBL_MAX-1) || inVal == DBL_MAX || isnan(inVal))			return false;	}	return true;}