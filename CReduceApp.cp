// =================================================================================//	CReduceApp.cp						// =================================================================================#include <LGrowZone.h>#include <LMenu.h>#include <LMenuBar.h>#include <LString.h>#include <LWindow.h>#include <PP_Messages.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <UReanimator.h>#include <URegistrar.h>#include <UModalDialogs.h>#include <UNavServicesDialogs.h>#include <UControlRegistry.h>#include <UGraphicUtils.h>#include <UEnvironment.h>#include <LToggleButton.h>#include <LCicnButton.h>#include <LActiveScroller.h>#include "LProgressDialog.h"#include <LIconPane.h>#ifndef __APPEARANCE__#include <Appearance.h>#endif#include "CReduceApp.h"#include "CSettingsWindow.h"#include "ReduceConstants.h"#include "CReducePrefs.h"#include "myLFileStream.h"#include "ABalloon.h"#include "Version.h"//#include "LAboutBox.h"#include "ErrorAlert.h"#include "BoundingBox.h"//#include <Movies.h>#include <LPopupButton.h>#include <LGAPopupButtonImp.h>// =================================================================================//		¥ Globals// =================================================================================SInt16	gAppResourceFork;	// global to hold my res fork refnum - any function might need itlong double	gPI;extern double_t gRandomXSeed;// =================================================================================//		¥ Main Program// =================================================================================intmain(){	if (_DEBUGGING) {		SetDebugThrow_(PP_PowerPlant::debugAction_Debugger);	// Set Debugging options		SetDebugSignal_(PP_PowerPlant::debugAction_Debugger);	} else {		SetDebugThrow_(PP_PowerPlant::debugAction_Alert);	// Set Debugging options		SetDebugSignal_(PP_PowerPlant::debugAction_Alert);	}	// Expand Stack on non-PowerMac versions	#if TARGET_CPU_PPC		#define dummy__ 0	#else		Ptr newlimit;		newlimit = ::GetApplLimit();		newlimit -= kExtraStackRoom * 1024;		::SetApplLimit(newlimit);	#endif	// Initialize the heap. Parameter is number	// of master handle blocks to allocate.	InitializeHeap( 8 );		// Initialize the MacOS toolbox.	UQDGlobals::InitializeToolbox;		UEnvironment::InitEnvironment();		// MUST CALL THIS!! There are some											// internals to PowerPlant that this											// establishes for us.	gAppResourceFork = ::CurResFile();	gPI = pi;	// do this here so Spotlight only complains once		// Install a GrowZone function to catch  low memory situations.	// Parameter is the size of the memory reserve in bytes.	new LGrowZone( 20000 );	myLFileStream::PreLoad();	// Create the application object and run it.	try {		CReduceApp	theApp;		theApp.Run();	} catch (CReduceApp::InitErr) {	}}// ---------------------------------------------------------------------------------//		¥ CReduceApp// ---------------------------------------------------------------------------------CReduceApp::CReduceApp(){	mSleepTime = 0;//	try {		mPrefsHolder = new CReducePrefs();		Assert_(mPrefsHolder != nil);		mPrefs = mPrefsHolder->GetPreferencesPtr();			if ( UEnvironment::HasFeature( env_HasAppearance ) ) {			::RegisterAppearanceClient();		}				// Register functions to create core PowerPlant classes		RegisterClass_(LWindow);		RegisterClass_(LPane);		RegisterClass_(LDialogBox);		RegisterClass_(LEditField);		RegisterClass_(LPane);		RegisterClass_(LPicture);		RegisterClass_(LPlaceHolder);		RegisterClass_(LScroller);		RegisterClass_(LTextEditView);		RegisterClass_(LView);		RegisterClass_(LWindow);		RegisterClass_(LRadioGroup);		RegisterClass_(LTabGroup);		RegisterClass_(LCicnButton);		RegisterClass_(LOffscreenView);		RegisterClass_(LActiveScroller);		RegisterClass_(LIconPane);		RegisterClass_(ABalloon);		RegisterClass_(ATag);				// Register the Appearance Manager/GA classes				UControlRegistry::RegisterClasses();		// LPopupButtons don't work until AppMgr1.0.1		if(!(UEnvironment::HasFeature(env_HasAppearance101))){			RegisterClassID_(LGAPopupButtonImp, LPopupButton::imp_class_ID);		}		// Register other PP classes:		RegisterClass_(LUndoer);		// Register custom classes		RegisterClass_(CSettingsWindow);		RegisterClass_(LProgressDialog);		RegisterClass_(LIconPane);		mDebugMenuAtt = nil;		settingsWind = nil;		shaveWind = nil;		mSettingsFile = nil;		mInputFile = nil;		mHolesFile = nil;		mBBox = nil;		mStartBBox = nil;		mHoles = nil;		mStats = nil;		mCSDOutputFile = nil;		mFilesToOpen = nil;		mSimulation = nil;		mTheXls = nil;		mShaveIteration = 0;		mQD3DProblem = false;		mSimulating = false;		mRunType = kSingle;		SetDefaultCommander(this);				mProgress = (LProgressDialog *)			LWindow::CreateWindow( kProgressDialogID, LCommander::GetTopCommander() );		ThrowIfNil_( mProgress );		/*	 catch (CPreference::NoResourceErr) {		throw (InitErr());	} catch (CPreference::NewResErr) {		throw (InitErr());	} catch (CPreference::BadProcessErr) {		ErrorAlert theAlert("\pProcess Error", "\pI got an error in the Process Manager - bad process serial number.");		throw (InitErr());	}*/}// ---------------------------------------------------------------------------------//		¥ ~CReduceApp// ---------------------------------------------------------------------------------CReduceApp::~CReduceApp(){	if (settingsWind != nil) {		delete settingsWind;		settingsWind = nil;	}	if (mPrefs != nil) {		delete mPrefs;		mPrefs = nil;	}	if (mInputFile != nil) {		delete mInputFile;		mInputFile = nil;	}	if (mSettingsFile != nil) {		delete mSettingsFile;		mSettingsFile = nil;	}	if (mHolesFile != nil) {		delete mHolesFile;		mHolesFile = nil;	}	if (mBBox != nil) {		delete mBBox;		mBBox = nil;	}	if (mHoles != nil) {		delete mHoles;		mHoles = nil;	}	if (mStats != nil) {		delete mStats;		mStats = nil;	}	if (mCSDOutputFile != nil) {		delete mCSDOutputFile;		mCSDOutputFile = nil;	}	if (mDebugMenuAtt != nil) {		delete mDebugMenuAtt;		mDebugMenuAtt = nil;	}}// ---------------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------------voidCReduceApp::StartUp(){	// only do cmd_New if we're not going to receive an OpenDocs AE	EventRecord theEvent;	if (!(::EventAvail(highLevelEventMask, &theEvent))) {		ObeyCommand( cmd_New, nil );	}}// ---------------------------------------------------------------------------------//		¥ Initialize// ---------------------------------------------------------------------------------//	This function has been added for compatibility with CW10. LApplication no//	longer creates a menu bar. Therefore, it must be done in this Initialize//	function, which is called by LApplication's Run function right before the//	event loop starts. This implementation overrides LApplication's virtual//	function.void CReduceApp::Initialize(){	LMenuBar * theMenuBar = LMenuBar::GetCurrentMenuBar();	ThrowIfNil_(theMenuBar);#if _DEBUGGING/*	mDebugMenuAtt = new LDebugMenuAttachment();	mDebugMenuAtt->InitDebugMenu();	AddAttachment(mDebugMenuAtt);*/#endif}// ---------------------------------------------------------------------------//		¥ HandleAppleEvent// ---------------------------------------------------------------------------//	Respond to an AppleEventvoidCReduceApp::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {					case ae_OpenDoc:			DoAEOpenDoc(inAppleEvent, outAEReply, inAENumber);			break;					default:			LApplication::HandleAppleEvent(inAppleEvent, outAEReply,								outResult, inAENumber);			break;	}}// ---------------------------------------------------------------------------//		¥ DoAEOpenDoc// ---------------------------------------------------------------------------//	Respond to an AppleEvent to open a DocumentvoidCReduceApp::DoAEOpenDoc(	const AppleEvent	&inAppleEvent,	AppleEvent&			/* outAEReply */,	SInt32				inAENumber){	AEDescList	docList;	OSErr		err = ::AEGetParamDesc(&inAppleEvent, keyDirectObject,							typeAEList, &docList);	ThrowIfOSErr_(err);		SInt32	numDocs;	err = ::AECountItems(&docList, &numDocs);	ThrowIfOSErr_(err);			// Loop through all items in the list			// Extract descriptor for the document			// Coerce descriptor data into a FSSpec			// Tell Program object to open document		mFilesToOpen = new LArray(sizeof(FSSpec));		for (SInt32 i = 1; i <= numDocs; i++) {		AEKeyword	theKey;		DescType	theType;		FSSpec		theFileSpec;		Size		theSize;		err = ::AEGetNthPtr(&docList, i, typeFSS, &theKey, &theType,							(Ptr) &theFileSpec, sizeof(FSSpec), &theSize);		ThrowIfOSErr_(err);				FInfo theFinderInfo;		ThrowIfOSErr_(::FSpGetFInfo(&theFileSpec, &theFinderInfo));		if (theFinderInfo.fdCreator == GraphCFsFileCreator) {			mSettingsFile = new myLFileStream(theFileSpec, false);		} else {			if (inAENumber == ae_OpenDoc) {				mFilesToOpen->InsertItemsAt(1, mFilesToOpen->GetCount(), &theFileSpec);			}		}	}	if (mFilesToOpen->GetCount() > 1)		mRunType = kBatch;	::AEDisposeDesc(&docList);	ObeyCommand( cmd_New, nil );}// ---------------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------------BooleanCReduceApp::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			// Deal with command messages (defined in PP_Messages.h).		// Any that you don't handle will be passed to LApplication 					case cmd_New:			if (settingsWind == nil) {				settingsWind = (CSettingsWindow *) LWindow::CreateWindow(rPPob_SettingsWindow, this);				settingsWind->SetUp(this, mPrefsHolder, mPrefs);			}			settingsWind->Select();			settingsWind->Show();			break;		case msg_TabSelect:				UpdateMenus();			break;		default:			cmdHandled = LApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------------voidCReduceApp::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	switch (inCommand) {			// Return menu item status according to command messages.		// Any that you don't handle will be passed to LApplication		case cmd_New:			if (settingsWind == nil || (settingsWind != nil && !(settingsWind->IsVisible())))				outEnabled = true;	// enable the New command if the settings window									// hasn't been created or is hidden			break;		default:			LApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------------//		¥ ShowAboutBox// ---------------------------------------------------------------------------------voidCReduceApp::ShowAboutBox(){	StDialogHandler		theHandler(rPPob_AboutBox, LCommander::GetTopCommander());	LDialogBox			*theDialog = (LDialogBox *)theHandler.GetDialog();	MessageT			hitMessage = msg_Nothing;	LStaticText *theCapt = (LStaticText *) theDialog->FindPaneByID(item_ProgNameStr);	LStr255 curStr;	theCapt->GetText(curStr);	LStr255 verStr (ShortVersionStr);	LStr255 newStr = curStr + verStr;	theCapt->SetText(newStr);	theDialog->Show();	while (hitMessage != msg_OK) {		// Let DialogHandler process events				hitMessage = theHandler.DoDialog();	}}// ---------------------------------------------------------------------------------//		¥ SetInputFileAndProcessData// ---------------------------------------------------------------------------------void CReduceApp::SetInputFileAndProcessData(){	FSSpec				oneFSSpec;		OSType theTL[2];	theTL[0] = Text_fileType;	theTL[1] = Integrate_bin_fileType;	if (mFilesToOpen == nil) {	// didn't get open docs AE from Finder		if (mHolesFile == nil) {			UNavServicesDialogs::LFileChooser chooser;			LFileTypeList types(fileTypes_All);			if (chooser.AskOpenFile(types)) {				mFilesToOpen = new LArray(sizeof(FSSpec));				for (int i=1; i<=chooser.GetNumberOfFiles(); i++) {					chooser.GetFileSpec(i, oneFSSpec);					mFilesToOpen->InsertItemsAt(1, mFilesToOpen->GetCount(), &oneFSSpec);				}				if (mFilesToOpen->GetCount() > 1 && mHolesFile != nil) {					ErrorAlert theAlert("\pBad Choice", "\pYou cannot select a holes file when doing batch processing.");				} else {					if (mFilesToOpen->GetCount() == 1)						mRunType = kSingle;					else						mRunType = kBatch;					for (short i = 1; i <= mFilesToOpen->GetCount(); i++) {						mFilesToOpen->FetchItemAt(i, &oneFSSpec);						if (mInputFile != nil)							delete mInputFile;						mInputFile = new myLFileStream(oneFSSpec);						try {							if (mPrefs->doShave) {								ShaveAndReduceData();							} else {								ReduceData();							}						} catch (ReduceFailedErr) {													}					}				}			} else {				// user chose cancel, or there were no files selected				if (_DEBUGGING) {					ErrorAlert theAlert("\pCanceled", "\p[DEBUG] - user chose cancel, or there were no files selected.");				}			}			mFilesToOpen = nil;		} else {	// we did choose a holes file			mRunType = kSingle;			if (mInputFile != nil)				delete mInputFile;			mInputFile = new myLFileStream(theTL, 2);			ReduceData();		}	} else {	// drag & drop from finder (or other AE mode)		for (short i = 1; i <= mFilesToOpen->GetCount(); i++) {			if (mBBox != nil) {				delete mBBox;				mBBox = nil;			}			mFilesToOpen->FetchItemAt(i, &oneFSSpec);			if (mInputFile != nil)				delete mInputFile;			mInputFile = new myLFileStream(oneFSSpec);			if (mPrefs->doShave)				ShaveAndReduceData();			else				ReduceData();		}	}	SwitchTarget(this);}// ---------------------------------------------------------------------------------//		¥ SetHolesFile// ---------------------------------------------------------------------------------void CReduceApp::SetHolesFile(myLFileStream *inFile){	if (mHolesFile != nil) {		delete mHolesFile;		mHolesFile = nil;	}	if (inFile != nil) {		mHolesFile = new myLFileStream(inFile->GetSpec());	} else {		mHolesFile = nil;	}}// ---------------------------------------------------------------------------------//		¥ ShaveAndReduceData// ---------------------------------------------------------------------------------void CReduceApp::ShaveAndReduceData(){	LProgressDialog *ShavProg = (LProgressDialog *)		LWindow::CreateWindow( kProgressDialogID, LCommander::GetTopCommander() );	ThrowIfNil_( ShavProg );	// Initialize Random Functions	gRandomXSeed = (double_t) mPrefs->seed;	try {		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mStartBBox != nil)			delete mStartBBox;		mStartBBox = new BoundingBox(mInputFile);		CrystalArray *theXls = mStartBBox->GetXls();		if (theXls->GetBounds() == kBoundsNone) {			delete mStartBBox;			mStartBBox = nil;			ErrorAlert theAlert("\pNeed Bounds", "\pTo do shave analysis, you must begin with a file that has explicitly stated bounds for the data.");		} else {			mBBox = new BoundingBox(*mStartBBox);			ShavProg->MoveWindowTo(350,40);			ShavProg->SetTitle("\pShaving Progress");			LStr255 shaveStr;			ShavProg->SetActionDescriptor("\pShave number 1");			ShavProg->SetValues(0,0,0);			ShavProg->Show();			ShavProg->Deactivate();			ShavProg->Refresh();			ShavProg->ToSpinOrNotToSpin(false);			while (ShaveData(mStartBBox, mBBox)) {				shaveStr.Assign((SInt32)mShaveIteration+1);				shaveStr.Insert("\pShave number ",0);				ShavProg->SetActionDescriptor(shaveStr);				ShavProg->Progress();				if (mPrefs->ShaveSave) {					CFloatArray	regCSD;					SaveCSD(regCSD, kIntegrate);				} else {					mBBox->FindConvexHull();					CalcStats();				}				mShaveIteration++;			}			mShaveIteration=0;			delete ShavProg;		}	} catch (CReduceApp::CancelErr) {		// clean up		if (ShavProg != nil) {			delete ShavProg;			ShavProg = nil;		}		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	} catch (LProgressDialog::StopClicked theStopClickException) {		theStopClickException.theThrower->Hide();		mProgress->Hide();		if (ShavProg != nil) {			delete ShavProg;			ShavProg = nil;		}		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}		settingsWind->Show();	} catch (CReduceApp::CalcError) {		// clean up		if (ShavProg != nil) {			delete ShavProg;			ShavProg = nil;		}		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	}}// ---------------------------------------------------------------------------------//		¥ ReduceData// ---------------------------------------------------------------------------------void CReduceApp::ReduceData(){	// Initialize Random Functions	gRandomXSeed = (double_t) mPrefs->seed;	try {	if (mPrefs->verbose) {			FSSpec debugSpec = mInputFile->GetSpec();			LStr255 inName = debugSpec.name;			inName += "\p Log";			inName.Remove(32, 100);	// truncate to 31 characters			short foundVRefNum;			long foundDirID;			::FindFolder(debugSpec.vRefNum, 'desk', kDontCreateFolder, &foundVRefNum, &foundDirID);			debugSpec.vRefNum = foundVRefNum;			debugSpec.parID = foundDirID;			LString::CopyPStr(inName, debugSpec.name);			mDebugOutputFile = new myLFileStream(debugSpec, true);			mDebugOutputFile->CreateNewDataFile(CW_fileCreator, 'TEXT');	}		if (mBBox != nil)			delete mBBox;		mBBox = new BoundingBox(mInputFile);		if (mHolesFile != nil) {			if (mHoles != nil)				delete mHoles;			mHoles = new HoleSet(mHolesFile);		}		mBBox->FindConvexHull();		if (mPrefs->inflateBBox)			mBBox->Inflate();		CalcStats();//		USoundPlayer::PlaySound(rFinishSound);	} catch (CReduceApp::CancelErr) {		// clean up		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	} catch (CReduceApp::CalcError) {		// clean up		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	} catch (BoundingBox::SimulationErr) {		// clean up		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	}}// ---------------------------------------------------------------------------------//		¥ ShaveData// ---------------------------------------------------------------------------------/*	This routine takes the ioBBox (which began as a duplicate of the mStartBBox),	adjusts its bounds, and removes all crystals that fall outside the bounds.	It then checks the boundary conditions to see if the box is still legal. */BooleanCReduceApp::ShaveData(BoundingBox *mStartBBox, BoundingBox *ioBBox){	CrystalArray *ioXls = ioBBox->GetXls();	short primType = ioBBox->GetType();		float	incr = (mPrefs->shaveIncrement / 100.0);	// should only get here if the primitive is Cylinder or RP, and explicit bounds	//	were given in the input file.  The SideSet primitive should be the same type of bounds	//	as given in the input file.	if ((primType == kCubeBox) || (primType == kRPBox)) {		Point3DFloat lower, upper, stLower, stUpper, stDim;		lower = ioXls->LowerBound();		upper = ioXls->UpperBound();		stLower = (mStartBBox->GetXls())->LowerBound();		stUpper = (mStartBBox->GetXls())->UpperBound();		stDim = stUpper - stLower;		if (mPrefs->keepAspectRatios) {			switch (mPrefs->direction) {				case kFromMax:					upper = stUpper - (incr * mShaveIteration * stDim);				break;				case kSymmetric:					upper = stUpper - (incr * 0.5 * mShaveIteration * stDim);					lower = stLower + (incr * 0.5 * mShaveIteration * stDim);				break;				case kFromMin:					lower = stLower + (incr * mShaveIteration * stDim);				break;			}		} else {			switch (mPrefs->direction) {				case kFromMax:					switch (mPrefs->shaveXYZ) {						case kX:							upper.x = stUpper.x - (incr * mShaveIteration * stDim.x);						break;						case kY:							upper.y = stUpper.y - (incr * mShaveIteration * stDim.y);						break;						case kZ:							upper.z = stUpper.z - (incr * mShaveIteration * stDim.z);						break;					}				break;				case kSymmetric:					switch (mPrefs->shaveXYZ) {						case kX:							upper.x = stUpper.x - (incr * 0.5 * mShaveIteration * stDim.x);							lower.x = stLower.x + (incr * 0.5 * mShaveIteration * stDim.x);						break;						case kY:							upper.y = stUpper.y - (incr * 0.5 * mShaveIteration * stDim.y);							lower.y = stLower.y + (incr * 0.5 * mShaveIteration * stDim.y);						break;						case kZ:							upper.z = stUpper.z - (incr * 0.5 * mShaveIteration * stDim.z);							lower.z = stLower.z + (incr * 0.5 * mShaveIteration * stDim.z);						break;					}				break;				case kFromMin:					switch (mPrefs->shaveXYZ) {						case kX:							lower.x = stLower.x + (incr * mShaveIteration * stDim.x);						break;						case kY:							lower.y = stLower.y + (incr * mShaveIteration * stDim.y);						break;						case kZ:							lower.z = stLower.z + (incr * mShaveIteration * stDim.z);						break;					}				break;			}		}		ioXls->SetLower(lower);		ioXls->SetUpper(upper);		ioBBox->AdjustToBounds();	} else { 	// then the primitive must be a Cylinder		Point3DFloat ctr;		Point3DFloat stCtr = (mStartBBox->GetXls())->GetCtr();		float	stRad = (mStartBBox->GetXls())->GetRadius();		float	stHt = (mStartBBox->GetXls())->GetHeight();		float	rad, ht;		if (mPrefs->keepAspectRatios) {			rad = (incr * mShaveIteration * stRad);			ht = (incr * mShaveIteration * stHt);			switch (mPrefs->direction) {				case kFromMax:	// places new cylinder within start cylinder but attached to base					Point3DFloat deltaH1(0, 0, 0.5*(ht-stHt));					ctr = stCtr + deltaH1;				break;				case kSymmetric:	// places new cylinder centered within start cylinder					// nothing else needed				break;				case kFromMin:	// places new cylinder within start cylinder but attached to top					Point3DFloat deltaH2(0, 0, 0.5*(stHt - ht));					ctr = stCtr + deltaH2;				break;			}		} else {			switch (mPrefs->direction) {				Point3DFloat delta;				case kFromMax:					switch (mPrefs->shaveXYZ) {						case kX:							rad = (incr * mShaveIteration * stRad);							delta.x = stCtr.x - stRad + rad;						break;						case kY:							rad = (incr * mShaveIteration * stRad);							delta.y = stCtr.y - stRad + rad;						break;						case kZ:							ht = (incr * mShaveIteration * stHt);							delta.z = stCtr.z + 0.5 * (ht - stHt);						break;					}				break;				case kSymmetric:					switch (mPrefs->shaveXYZ) {						case kX:							rad = (incr * mShaveIteration * stRad);						break;						case kY:							rad = (incr * mShaveIteration * stRad);						break;						case kZ:							ht = (incr * mShaveIteration * stHt);						break;					}				break;				case kFromMin:					switch (mPrefs->shaveXYZ) {						case kX:							rad = (incr * mShaveIteration * stRad);							delta.x = stCtr.x + stRad - rad;						break;						case kY:							rad = (incr * mShaveIteration * stRad);							delta.y = stCtr.y + stRad - rad;						break;						case kZ:							ht = (incr * mShaveIteration * stHt);							delta.z = stCtr.z + 0.5 * (stHt - ht);						break;					}				break;				ctr = stCtr + delta;			}		}		ioXls->SetRadius(rad);		ioXls->SetHeight(ht);		ioXls->SetCtr(ctr);		ioBBox->AdjustToBounds();	}	// now check to see if the box is still legal	Boolean goodBox;	if (mPrefs->smaller)	// smaller means ALL must be illegal for goodBox to be false		goodBox = (((100 * (1 - mShaveIteration * incr) > mPrefs->minPercent))				|| (ioXls->GetCount() > mPrefs->minPopulation)				|| (mPrefs->keepAspectRatios ? false : (ioBBox->AspectRatio() < mPrefs->maxAspectRatio)));	else	// if any are illegal then goodBox is false		goodBox = !(((100 * (1 - mShaveIteration * incr) < mPrefs->minPercent))				|| (ioXls->GetCount() < mPrefs->minPopulation)				|| (mPrefs->keepAspectRatios ? false : (ioBBox->AspectRatio() > mPrefs->maxAspectRatio)));	return goodBox;}// ---------------------------------------------------------------------------------//		¥ GetBBox// ---------------------------------------------------------------------------------BoundingBox *CReduceApp::GetBBox(){	return mBBox;}