// =================================================================================//	CReduceApp.cp						// =================================================================================#include <LGrowZone.h>#include <LMenu.h>#include <LMenuBar.h>#include <LString.h>#include <LWindow.h>#include <PP_Messages.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <UReanimator.h>#include <URegistrar.h>#include <UModalDialogs.h>#include <UControlRegistry.h>#include <UGraphicUtils.h>#include <UEnvironment.h>#include <LToggleButton.h>#include <LCicnButton.h>#include <LActiveScroller.h>#include "USoundPlayer.h"#include "LProgressDialog.h"#include "UGetMultipleFiles.h"#include <LIconPane.h>#ifndef __APPEARANCE__#include <Appearance.h>#endif#include "CReduceApp.h"#include "CSettingsWindow.h"#include "ReduceConstants.h"#include "CReducePrefs.h"#include "myLFileStream.h"#include "CHelpAttach.h"#include "LAboutBox.h"#include "ErrorAlert.h"#include "BoundingBox.h"#include "BBWindow.h"#include <Movies.h>#include <LPopupButton.h>#include <LGAPopupButtonImp.h>#include "SpotlightAPI.h"#if TARGET_CPU_PPC	#include <QD3D.h>	#include "BBWindow3D.h"	#include "LQD3DViewerPane.h"#endif// =================================================================================//		¥ Globals// =================================================================================SInt16	gAppResourceFork;	// global to hold my res fork refnum - any function might need itlong double	gPI;extern double_t gRandomXSeed;// =================================================================================//		¥ Main Program// =================================================================================intmain(){	if (_DEBUGGING) {		SetDebugThrow_(PP_PowerPlant::debugAction_Debugger);	// Set Debugging options		SetDebugSignal_(PP_PowerPlant::debugAction_Debugger);	} else {		SetDebugThrow_(PP_PowerPlant::debugAction_Alert);	// Set Debugging options		SetDebugSignal_(PP_PowerPlant::debugAction_Alert);	}	// Expand Stack on non-PowerMac versions	#if TARGET_CPU_PPC		#define dummy__ 0	#else		Ptr newlimit;		newlimit = ::GetApplLimit();		newlimit -= kExtraStackRoom * 1024;		::SetApplLimit(newlimit);	#endif	// Initialize the heap. Parameter is number	// of master handle blocks to allocate.	PP::InitializeHeap( 8 );		// Initialize the MacOS toolbox.	PP::UQDGlobals::InitializeToolbox( &qd );		PP::UEnvironment::InitEnvironment();		// MUST CALL THIS!! There are some											// internals to PowerPlant that this											// establishes for us.	gAppResourceFork = ::CurResFile();	SLDisable();	gPI = pi;	// do this here so Spotlight only complains once	SLEnable();		// Install a GrowZone function to catch  low memory situations.	// Parameter is the size of the memory reserve in bytes.	new PP::LGrowZone( 20000 );	myLFileStream::PreLoad();	// Create the application object and run it.	try {		CReduceApp	theApp;		theApp.Run();	} catch (CReduceApp::InitErr) {	}}// ---------------------------------------------------------------------------------//		¥ CReduceApp// ---------------------------------------------------------------------------------CReduceApp::CReduceApp(){	mSleepTime = 0;	try {		mPrefsHolder = new CReducePrefs();		Assert_(mPrefsHolder != nil);		mPrefsHolder->LoadPreferences();		mPrefs = mPrefsHolder->mPrefsPtr;			if ( PP::UEnvironment::HasFeature( PP::env_HasAppearance ) ) {			::RegisterAppearanceClient();		}				// Register functions to create core PowerPlant classes		RegisterClass_(PP::LWindow);		RegisterClass_(PP::LPane);		RegisterClass_(PP::LDialogBox);		RegisterClass_(PP::LEditField);		RegisterClass_(PP::LPane);		RegisterClass_(PP::LPicture);		RegisterClass_(PP::LPlaceHolder);		RegisterClass_(PP::LScroller);		RegisterClass_(PP::LTextEditView);		RegisterClass_(PP::LView);		RegisterClass_(PP::LWindow);		RegisterClass_(PP::LRadioGroup);		RegisterClass_(PP::LTabGroup);		RegisterClass_(PP::LCicnButton);		RegisterClass_(PP::LOffscreenView);		RegisterClass_(PP::LActiveScroller);		RegisterClass_(PP::LIconPane);//		RegisterClass_(LGroupBox);				// Register the Appearance Manager/GA classes				PP::UControlRegistry::RegisterClasses();		// PP::LPopupButtons don't work until AppMgr1.0.1		if(!(PP::UEnvironment::HasFeature(PP::env_HasAppearance101))){			RegisterClassID_(PP::LGAPopupButtonImp, PP::LPopupButton::imp_class_ID);		}		// Register other PP classes:		RegisterClass_(PP::LUndoer);		// Register custom classes		RegisterClass_(CSettingsWindow);		RegisterClass_(LProgressDialog);		RegisterClass_(BBWindow);		RegisterClass_(BBView);		RegisterClass_(CHelpAttach);//		RegisterClass_(ErrorAlert);		RegisterClass_(PP::LIconPane);	#if TARGET_CPU_PPC		RegisterClass_(BBWindow3D);		RegisterClass_(LQD3DViewerPane);	#endif		mDebugMenuAtt = nil;		settingsWind = nil;		shaveWind = nil;		mSettingsFile = nil;		mInputFile = nil;		mHolesFile = nil;		mBBox = nil;		mStartBBox = nil;		mHoles = nil;		mStats = nil;		mCSDOutputFile = nil;		mFilesToOpen = nil;		mSimulation = nil;		mTheXls = nil;		mShaveIteration = 0;		mQD3DProblem = false;		mSimulating = false;		mRunType = kSingle;		SetDefaultCommander(this);				mProgress = (LProgressDialog *)			PP::LWindow::CreateWindow( kProgressDialogID, PP::LCommander::GetTopCommander() );		ThrowIfNil_( mProgress );				if (HasQD3D())			// Initialize QuickDraw3D			InitQD3D();	} catch (CPreference::NoResourceErr) {		throw (InitErr());	} catch (CPreference::NewResErr) {		throw (InitErr());	} catch (CPreference::BadProcessErr) {		ErrorAlert theAlert("\pProcess Error", "\pI got an error in the Process Manager - bad process serial number.");		throw (InitErr());	}}// ---------------------------------------------------------------------------------//		¥ ~CReduceApp// ---------------------------------------------------------------------------------CReduceApp::~CReduceApp(){	if (settingsWind != nil) {		delete settingsWind;		settingsWind = nil;	}	if (mPrefs != nil) {		delete mPrefs;		mPrefs = nil;	}	if (mInputFile != nil) {		delete mInputFile;		mInputFile = nil;	}	if (mSettingsFile != nil) {		delete mSettingsFile;		mSettingsFile = nil;	}	if (mHolesFile != nil) {		delete mHolesFile;		mHolesFile = nil;	}	if (mBBox != nil) {		delete mBBox;		mBBox = nil;	}	if (mHoles != nil) {		delete mHoles;		mHoles = nil;	}	if (mStats != nil) {		delete mStats;		mStats = nil;	}	if (mCSDOutputFile != nil) {		delete mCSDOutputFile;		mCSDOutputFile = nil;	}	if (mDebugMenuAtt != nil) {		delete mDebugMenuAtt;		mDebugMenuAtt = nil;	}#if TARGET_CPU_PPC	TQ3Status result;	result = Q3Exit();	// unload QuickDraw 3D/*	if (result == kQ3Failure) {		ErrorAlert theAlert("\pQuickDraw 3D problem", "\pThere was an error unloading QuickDraw 3D.  Erg.");	}*/#endif}// ---------------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------------voidCReduceApp::StartUp(){	// only do cmd_New if we're not going to receive an OpenDocs AE	EventRecord theEvent;	if (!(::EventAvail(highLevelEventMask, &theEvent))) {		ObeyCommand( PP::cmd_New, nil );	}}// ---------------------------------------------------------------------------------//		¥ Initialize// ---------------------------------------------------------------------------------//	This function has been added for compatibility with CW10. PP::LApplication no//	longer creates a menu bar. Therefore, it must be done in this Initialize//	function, which is called by PP::LApplication's Run function right before the//	event loop starts. This implementation overrides PP::LApplication's virtual//	function.void CReduceApp::Initialize(){	PP::LMenuBar * theMenuBar = PP::LMenuBar::GetCurrentMenuBar();	ThrowIfNil_(theMenuBar);#if _DEBUGGING	mDebugMenuAtt = new PP::LDebugMenuAttachment();	mDebugMenuAtt->InitDebugMenu();	AddAttachment(mDebugMenuAtt);#endif}// ---------------------------------------------------------------------------//		¥ HandleAppleEvent// ---------------------------------------------------------------------------//	Respond to an AppleEventvoidCReduceApp::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {					case PP::ae_OpenDoc:			DoAEOpenDoc(inAppleEvent, outAEReply, inAENumber);			break;					default:			PP::LApplication::HandleAppleEvent(inAppleEvent, outAEReply,								outResult, inAENumber);			break;	}}// ---------------------------------------------------------------------------//		¥ DoAEOpenDoc// ---------------------------------------------------------------------------//	Respond to an AppleEvent to open a DocumentvoidCReduceApp::DoAEOpenDoc(	const AppleEvent	&inAppleEvent,	AppleEvent&			/* outAEReply */,	SInt32				inAENumber){	AEDescList	docList;	OSErr		err = ::AEGetParamDesc(&inAppleEvent, keyDirectObject,							typeAEList, &docList);	ThrowIfOSErr_(err);		SInt32	numDocs;	err = ::AECountItems(&docList, &numDocs);	ThrowIfOSErr_(err);			// Loop through all items in the list			// Extract descriptor for the document			// Coerce descriptor data into a FSSpec			// Tell Program object to open document		mFilesToOpen = new PP::LArray(sizeof(FSSpec));		for (SInt32 i = 1; i <= numDocs; i++) {		AEKeyword	theKey;		DescType	theType;		FSSpec		theFileSpec;		Size		theSize;		err = ::AEGetNthPtr(&docList, i, typeFSS, &theKey, &theType,							(Ptr) &theFileSpec, sizeof(FSSpec), &theSize);		ThrowIfOSErr_(err);				FInfo theFinderInfo;		ThrowIfOSErr_(::FSpGetFInfo(&theFileSpec, &theFinderInfo));		if (theFinderInfo.fdCreator == GraphCFsFileCreator) {			mSettingsFile = new myLFileStream(theFileSpec, false);		} else {			if (inAENumber == PP::ae_OpenDoc) {				mFilesToOpen->InsertItemsAt(1, mFilesToOpen->GetCount(), &theFileSpec);			}		}	}	if (mFilesToOpen->GetCount() > 1)		mRunType = kBatch;	::AEDisposeDesc(&docList);	ObeyCommand( PP::cmd_New, nil );}// ---------------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------------BooleanCReduceApp::ObeyCommand(	PP::CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			// Deal with command messages (defined in PP_Messages.h).		// Any that you don't handle will be passed to PP::LApplication 					case PP::cmd_New:			if (settingsWind == nil) {				settingsWind = (CSettingsWindow *) PP::LWindow::CreateWindow(rPPob_SettingsWindow, this);				settingsWind->SetUp(this, mPrefsHolder, mPrefs, mSettingsFile);			}			settingsWind->Select();			settingsWind->Show();			break;		case PP::msg_TabSelect:				UpdateMenus();			break;		default:			cmdHandled = PP::LApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------------voidCReduceApp::FindCommandStatus(	PP::CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	switch (inCommand) {			// Return menu item status according to command messages.		// Any that you don't handle will be passed to PP::LApplication		case PP::cmd_New:			if (settingsWind == nil || (settingsWind != nil && !(settingsWind->IsVisible())))				outEnabled = true;	// enable the New command if the settings window									// hasn't been created or is hidden			break;//		case cmd_DoShave://			if (shaveWind == nil && (settingsWind == nil || (settingsWind != nil && !(settingsWind->IsVisible()))))//				outEnabled = true;		default:			PP::LApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------------//		¥ ShowAboutBox// ---------------------------------------------------------------------------------voidCReduceApp::ShowAboutBox(){	LAboutBox::DoAboutBox(rPPob_AboutBox);}// ---------------------------------------------------------------------------------//		¥ SetInputFileAndProcessData// ---------------------------------------------------------------------------------void CReduceApp::SetInputFileAndProcessData(){	UGetMultipleFiles	*theMultFilesThing;	FSSpec				oneFSSpec;	mProgress->SetGreediness(mPrefs->greediness);	// this sets the greediness for all the boxes		SFTypeList theTL;	theTL[0] = Text_fileType;	theTL[1] = Integrate_bin_fileType;	if (mFilesToOpen == nil) {	// didn't get open docs AE from Finder		if (mHolesFile == nil) {			theMultFilesThing = new UGetMultipleFiles("\pChoose files for processing:", 2, theTL, nil, nil, kResolveAliases+kSuppressTypePopup);			if ((theMultFilesThing->GetSFReply()).sfGood) {				mFilesToOpen = theMultFilesThing->GetFSSpecs();				if (mFilesToOpen->GetCount() > 1 && mHolesFile != nil) {					ErrorAlert theAlert("\pBad Choice", "\pYou cannot select a holes file when doing batch processing.");				} else {					if (mFilesToOpen->GetCount() == 1)						mRunType = kSingle;					else						mRunType = kBatch;					for (short i = 1; i <= mFilesToOpen->GetCount(); i++) {						mFilesToOpen->FetchItemAt(i, &oneFSSpec);						if (mInputFile != nil)							delete mInputFile;						mInputFile = new myLFileStream(oneFSSpec);						try {							if (mPrefs->doShave) {								ShaveAndReduceData();							} else {								ReduceData();							}						} catch (ReduceFailedErr) {													}					}				}			} else {				// user chose cancel, or there were no files selected				if (_DEBUGGING) {					ErrorAlert theAlert("\pCanceled", "\p[DEBUG] - user chose cancel, or there were no files selected.");				}			}			delete theMultFilesThing;			mFilesToOpen = nil;		} else {	// we did choose a holes file			mRunType = kSingle;			if (mInputFile != nil)				delete mInputFile;			mInputFile = new myLFileStream(theTL, 2);			ReduceData();		}	} else {	// drag & drop from finder (or other AE mode)		for (short i = 1; i <= mFilesToOpen->GetCount(); i++) {			if (mBBox != nil) {				delete mBBox;				mBBox = nil;			}			mFilesToOpen->FetchItemAt(i, &oneFSSpec);			if (mInputFile != nil)				delete mInputFile;			mInputFile = new myLFileStream(oneFSSpec);			if (mPrefs->doShave)				ShaveAndReduceData();			else				ReduceData();		}	}	SwitchTarget(this);}// ---------------------------------------------------------------------------------//		¥ SetHolesFile// ---------------------------------------------------------------------------------void CReduceApp::SetHolesFile(myLFileStream *inFile){	if (mHolesFile != nil)		delete mHolesFile;	mHolesFile = new myLFileStream(inFile->GetSpec());}// ---------------------------------------------------------------------------------//		¥ ShaveAndReduceData// ---------------------------------------------------------------------------------void CReduceApp::ShaveAndReduceData(){	LProgressDialog *ShavProg = (LProgressDialog *)		PP::LWindow::CreateWindow( kProgressDialogID, PP::LCommander::GetTopCommander() );	ThrowIfNil_( ShavProg );	// Initialize Random Functions//	Ultra_seed1 = mPrefs->GetRandSeed();//	Ultra_seed2 = Ultra_seed1*10 - 1;//	Ultra_Init();	gRandomXSeed = (double_t) mPrefs->seed;	try {		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mStartBBox != nil)			delete mStartBBox;		mStartBBox = new BoundingBox(mInputFile);		CrystalArray *theXls = mStartBBox->GetXls();		if (!theXls->HasBounds()) {			delete mStartBBox;			mStartBBox = nil;			ErrorAlert theAlert("\pNeed Bounds", "\pTo do shave analysis, you must begin with a file that has explicitly stated bounds for the data.");		} else {			mBBox = new BoundingBox(*mStartBBox);			ShavProg->MoveWindowTo(350,40);			ShavProg->SetTitle("\pShaving Progress");			PP::LStr255 shaveStr;			ShavProg->SetActionDescriptor("\pShave number 1");			ShavProg->SetValues(0,0,0);			ShavProg->Show();			ShavProg->Deactivate();			ShavProg->Refresh();			ShavProg->ToSpinOrNotToSpin(false);			while (ShaveData(mStartBBox, mBBox)) {				shaveStr.Assign((SInt32)mShaveIteration+1);				shaveStr.Insert("\pShave number ",0);				ShavProg->SetActionDescriptor(shaveStr);				ShavProg->Progress();				if (mPrefs->ShaveSave) {					CFloatArray	regCSD;					SaveCSD(regCSD, kIntegrate);				} else {					mBBox->FindConvexHull();					CalcStats();					if (mPrefs->make3DModel)						SwitchTarget(mBBox->GetBB3DWindow());				}				mShaveIteration++;			}			mShaveIteration=0;			delete ShavProg;		}		USoundPlayer::PlaySound(rFinishSound);	} catch (CReduceApp::CancelErr) {		// clean up		if (ShavProg != nil) {			delete ShavProg;			ShavProg = nil;		}		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	} catch (LProgressDialog::StopClicked theStopClickException) {		theStopClickException.theThrower->Hide();		mProgress->Hide();//		mBBox->mProgress->Hide();//		CrystalArray *theXls2 = mBBox->GetXls();//		(theXls2->GetProgress())->Hide();		if (ShavProg != nil) {			delete ShavProg;			ShavProg = nil;		}		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}		settingsWind->Show();	} catch (CReduceApp::CalcError) {		// clean up		if (ShavProg != nil) {			delete ShavProg;			ShavProg = nil;		}		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	}}// ---------------------------------------------------------------------------------//		¥ ReduceData// ---------------------------------------------------------------------------------void CReduceApp::ReduceData(){	// Initialize Random Functions//	Ultra_seed1 = mPrefs->GetRandSeed();//	Ultra_seed2 = Ultra_seed1*10 - 1;//	Ultra_Init();	gRandomXSeed = (double_t) mPrefs->seed;	try {	if (mPrefs->verbose) {//		if (mFilesToOpen->GetCount() > 1) {			FSSpec debugSpec = mInputFile->GetSpec();			PP::LStr255 inName = debugSpec.name;			inName += "\p Log";			inName.Remove(32, 100);	// truncate to 31 characters			short foundVRefNum;			long foundDirID;			::FindFolder(debugSpec.vRefNum, 'desk', kDontCreateFolder, &foundVRefNum, &foundDirID);			debugSpec.vRefNum = foundVRefNum;			debugSpec.parID = foundDirID;			PP::LString::CopyPStr(inName, debugSpec.name);			mDebugOutputFile = new myLFileStream(debugSpec, true);			mDebugOutputFile->CreateNewDataFile(CW_fileCreator, 'TEXT');//		} else {//			mDebugOutputFile = new myLFileStream("\pChoose a file for debugging output", "\pReduce Debug Output", true);//			mDebugOutputFile->CreateNewDataFile(CW_fileCreator, 'TEXT');//		}	}		if (mBBox != nil)			delete mBBox;		mBBox = new BoundingBox(mInputFile);		if (mHolesFile != nil) {			if (mHoles != nil)				delete mHoles;			mHoles = new HoleSet(mHolesFile);		}		mBBox->FindConvexHull();		if (mPrefs->inflateBBox)			mBBox->Inflate();		CalcStats();		if (mPrefs->make3DModel) {			SwitchTarget(mBBox->GetBB3DWindow());		}		USoundPlayer::PlaySound(rFinishSound);	} catch (CReduceApp::CancelErr) {		// clean up		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	} catch (CReduceApp::CalcError) {		// clean up		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	} catch (BoundingBox::SimulationErr) {		// clean up		if (mBBox != nil) {			delete mBBox;			mBBox = nil;		}		if (mHoles != nil) {			delete mHoles;			mHoles = nil;		}	}}// ---------------------------------------------------------------------------------//		¥ ShaveData// ---------------------------------------------------------------------------------/*	This routine takes the ioBBox (which began as a duplicate of the mStartBBox),	adjusts its bounds, and removes all crystals that fall outside the bounds.	It then checks the boundary conditions to see if the box is still legal. */BooleanCReduceApp::ShaveData(BoundingBox *mStartBBox, BoundingBox *ioBBox){	Point3DFloat lower, upper, stLower, stUpper, stDim;	float	incr = (mPrefs->shaveIncrement / 100.0);//	short dir = mPrefs->direction;	lower = (ioBBox->GetXls())->LowerBound();	upper = (ioBBox->GetXls())->UpperBound();	stLower = (mStartBBox->GetXls())->LowerBound();	stUpper = (mStartBBox->GetXls())->UpperBound();	stDim = stUpper - stLower;	if (mPrefs->keepAspectRatios) {		switch (mPrefs->direction) {			case kFromMax:				upper = stUpper - (incr * mShaveIteration * stDim);			break;			case kSymmetric:				upper = stUpper - (incr * 0.5 * mShaveIteration * stDim);				lower = stLower + (incr * 0.5 * mShaveIteration * stDim);			break;			case kFromMin:				lower = stLower + (incr * mShaveIteration * stDim);			break;		}	} else {		switch (mPrefs->direction) {			case kFromMax:				switch (mPrefs->shaveXYZ) {					case kX:						upper.x = stUpper.x - (incr * mShaveIteration * stDim.x);					break;					case kY:						upper.y = stUpper.y - (incr * mShaveIteration * stDim.y);					break;					case kZ:						upper.z = stUpper.z - (incr * mShaveIteration * stDim.z);					break;				}			break;			case kSymmetric:				switch (mPrefs->shaveXYZ) {					case kX:						upper.x = stUpper.x - (incr * 0.5 * mShaveIteration * stDim.x);						lower.x = stLower.x + (incr * 0.5 * mShaveIteration * stDim.x);					break;					case kY:						upper.y = stUpper.y - (incr * 0.5 * mShaveIteration * stDim.y);						lower.y = stLower.y + (incr * 0.5 * mShaveIteration * stDim.y);					break;					case kZ:						upper.z = stUpper.z - (incr * 0.5 * mShaveIteration * stDim.z);						lower.z = stLower.z + (incr * 0.5 * mShaveIteration * stDim.z);					break;				}			break;			case kFromMin:				switch (mPrefs->shaveXYZ) {					case kX:						lower.x = stLower.x + (incr * mShaveIteration * stDim.x);					break;					case kY:						lower.y = stLower.y + (incr * mShaveIteration * stDim.y);					break;					case kZ:						lower.z = stLower.z + (incr * mShaveIteration * stDim.z);					break;				}			break;		}	}	(ioBBox->GetXls())->SetLower(lower);	(ioBBox->GetXls())->SetUpper(upper);	ioBBox->AdjustToBounds();	// now check to see if the box is still legal	Boolean goodBox;	if (mPrefs->smaller)	// smaller means ALL must be illegal for goodBox to be false		goodBox = (((100 * (1 - mShaveIteration * incr) > mPrefs->minPercent))				|| ((ioBBox->GetXls())->GetCount() > mPrefs->minPopulation)				|| (mPrefs->keepAspectRatios ? false : (ioBBox->AspectRatio() < mPrefs->maxAspectRatio)));	else	// if any are illegal then goodBox is false		goodBox = !(((100 * (1 - mShaveIteration * incr) < mPrefs->minPercent))				|| ((ioBBox->GetXls())->GetCount() < mPrefs->minPopulation)				|| (mPrefs->keepAspectRatios ? false : (ioBBox->AspectRatio() > mPrefs->maxAspectRatio)));	return goodBox;}// ---------------------------------------------------------------------------------//		¥ BeTarget// ---------------------------------------------------------------------------------voidCReduceApp::BeTarget(){	if (mBBox!=nil && mBBox->GetBB3DWindow()!=nil && mState != PP::programState_Quitting)		SwitchTarget(mBBox->GetBB3DWindow());}// ---------------------------------------------------------------------------------//		¥ HasQD3D// ---------------------------------------------------------------------------------BooleanCReduceApp::HasQD3D(){	#if TARGET_CPU_PPC		OSErr	myErr;		long	answer;		if (mQD3DProblem)			return false;		if ((myErr = Gestalt(gestaltQD3D, &answer)) == noErr) {			return (answer >= gestaltQD3DPresent);		}	#endif	return false;}// ---------------------------------------------------------------------------------//		¥ GetBBox// ---------------------------------------------------------------------------------BoundingBox *CReduceApp::GetBBox(){	return mBBox;}// ---------------------------------------------------------------------------------//		¥ InitQD3D// ---------------------------------------------------------------------------------voidCReduceApp::InitQD3D(){	#if TARGET_CPU_PPC		mQD3DProblem = false;		TQ3Status	result;		result = Q3Initialize();		if (result == kQ3Failure) {			ErrorAlert theAlert("\pQuickDraw 3D problem", "\pIt looks like you have QuickDraw 3D installed, so I tried to use it to display the Bounding Box, but there was a problem initializing it.  I'll use the non-QD3D version.");			mQD3DProblem = true;		}	#endif}