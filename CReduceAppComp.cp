// =================================================================================//	CReduceAppComp.cp						// =================================================================================#include "CReduceApp.h"#include "CReducePrefs.h"#include "myLFileStream.h"#include "BoundingBox.h"#include "ErrorAlert.h"#include "stdlib.h"#include "string.h"#include "FixMath.h"#include "RadXlComp.h"#include "EnvelopeData.h"#include "Bounds.h"#include "RadSortArray.h"#include "ShuffleArray.h"extern long double gPI;// ---------------------------------------------------------------------------------//		¥ CalcStats// ---------------------------------------------------------------------------------void CReduceApp::CalcStats(){	if (!mSimulating) {		mTheXls = mBBox->GetXls();		if (mStats != nil)			delete mStats;		mStats = new Stats();		mProgress->Show();		FSSpec theSpec = mInputFile->GetSpec();		LStr255 title("Computing Statistics...");		title.Append(theSpec.name);		mProgress->SetTitle(title);				if (mPrefs->tidyUp && mHoles) {			mHoles->TidyCrystalsUp(mTheXls);		}	}	if (!mSimulating && (mTheXls->GetBounds() != kBoundsNone)) {		FindBestPrimitive();		AdaptToPrimitiveBox();	} else {		mStats->numXlsForL = mTheXls->GetCount();		mStats->newMeanR = mStats->meanR;	}	DoInitialStats();		ComputeVolumes(); 		if (!mSimulating && mPrefs->doImpingement && mStats->fileType == kDiffSimulation) {		mTheXls->CorrectForImpingement();	}	ComputeRadiusStats();	if (mPrefs->doOthers || mPrefs->includeRegCSD || mPrefs->doLMcfPcf) {		ComputeNeighbors();		ComputeStats();	}	if (mPrefs->doOthers) {		ComputeAvramiTest();		ComputeCSDStats();	}		if (mPrefs->doQuadrat)		try {			ComputeQuadrat();		} catch (CReduceApp::QuadratFailed) {			;	// no cleanup required		}	if (mPrefs->doRandomPt)		ComputeRandomPt();//	if (!mSimulating && !mTheXls->HasBounds()) {//		FindBestPrimitive();//		AdaptToPrimitiveBox();//	} else {//		mStats->numXlsForL = mTheXls->GetCount();//		mStats->newMeanR = mStats->meanR;//	}//// Debug only!!! - for testing of filter function://mTheXls->FilterForObservability();//throw CancelErr();	if (mPrefs->doLMcfPcf) {		if (!mSimulating) {	// for the simulations, this is set in DoEnvelopes based							// on the real data params (intensity, mean NN dist, etc.)				// figure out the bandwidth - twice the calculated value is the whole width			float bandwidth = 2.0 * mPrefs->EpanecnikovCVal / CubeRoot(mStats->intensity);			float scaleIncrement = bandwidth * (1.0 - mPrefs->overlap * 0.01);			float totScale = mPrefs->numNNDist * mStats->meanSep;			short numScales = trunc(totScale / scaleIncrement) + 1;			mStats->SetCFParams(numScales, mPrefs->outputSigmas);			// set up HDistance Array			for (short i = 1; i <= numScales; i++) {				mStats->hDistances[i] = scaleIncrement * i;			}		}						ComputeCFs_Both();	}	if (!mSimulating) {		if (mPrefs->numEnvelopeRuns > 0)			DoEnvelopes();			mProgress->SetActionDescriptor("\pWriting Output Files...");		mProgress->SetValues(0, 7, 0);		if (mPrefs->includeMeanCSD)			DoMeanCumCSD();		mProgress->ThisMuchCompleted(1);		if (mPrefs->includeMaxCSD)			DoMaxCumCSD();		mProgress->ThisMuchCompleted(2);		if (mPrefs->includeLogCSD)			DoLogCsd();		mProgress->ThisMuchCompleted(3);		if (mPrefs->includeRegCSD) {			DoNNCSD();			mProgress->ThisMuchCompleted(4);			DoRegCSD();			mProgress->ThisMuchCompleted(5);		}		if (mPrefs->outputReduce)			DoReduce3DFile();		mProgress->ThisMuchCompleted(6);		if (mPrefs->outputR3STT)			DoRedStatsFile();		mProgress->ThisMuchCompleted(7);				mProgress->Hide();	}}#pragma mark ============================ Primitive Stuff// ---------------------------------------------------------------------------//		¥ FindBestPrimitive// ---------------------------------------------------------------------------/*	Since the processing for the correlation functions is *extremely* slow when	their bounding boxes are made of sides, here we figure out the best geometrical	primitive for the bounding box, guided by the option chosen in the settings	window.	Algorithm:		1) Make a Primitive that is outside the box, based on the min & max points			and the center that we've already calculated.		2) Reduce the dimensions by small increments until the primitive is			inside the box.		3) Move the primitive in each of the 6 directions, to find the range of movement			of the primitive inside the box.  Put the primitive in the middle of this range.		4) Expand the primitive until it's just outside the box.		5) Redo 2-4 a couple of times.	NOT TRUE ANYMORE (as of 10/8/97): This algorithm will find the best primitive inside the box that KEEPS THE RATIOS		AMONG THE DIMENSIONS which were dictated by the min & max points of the		original crystal array.  While this is probably not too bad an assumption,		the algorithm won't find the primitive with the largest volume that would fit		inside the box.*/voidCReduceApp::FindBestPrimitive(){	Point3DFloat ctr, beforeCtr;	SideSet curPrim;	short tryNum;	short numtries = 6;		switch (mPrefs->sampleShape) {	case kRectPrism:		NewFindBestRPPrimitive(curPrim);	// start with a Monte Carlo search for best box		Point3DFloat curLengths = curPrim.GetSideLenPt();				do {		// expand box until just too big			curLengths *= 1.01;			curPrim.SetDimensions(curLengths);		} while (mBBox->PrimitiveInBox(&curPrim));		for (tryNum = 1; tryNum <= numtries; tryNum++) {				// set shrinking factors; get finer-grained with later tries			float bigFactor = 1.0 - ((numtries - tryNum + 1) * 0.015);			float smFactor = 1.0 - ((numtries - tryNum + 1) * 0.03);			// Shrink until primitive is inside box: try for each dimension, pick version with largest volume			// Try Shrinking X:			Point3DFloat beforeLengths = curPrim.GetSideLenPt();			beforeCtr = curPrim.GetCtr();//	OLD Version: keeps ratios among dimensions			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths *= bigFactor;				if (curLengths.x < (beforeLengths.x / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double oldVersionVolume = curPrim.Volume();			Point3DFloat oldVersionLen = curLengths;			Point3DFloat oldVersionCtr = curPrim.GetCtr();//  Shrink x faster:			curLengths = beforeLengths;			curPrim.SetDimensions(curLengths);			curPrim.SetCtr(beforeCtr);			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths.x *= smFactor;				curLengths.y *= bigFactor;				curLengths.z *= bigFactor;				if (curLengths.y < (beforeLengths.y / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double yzVersionVolume = curPrim.Volume();			Point3DFloat yzVersionLen = curLengths;			Point3DFloat yzVersionCtr = curPrim.GetCtr();//  Shrink y faster:			curLengths = beforeLengths;			curPrim.SetDimensions(curLengths);			curPrim.SetCtr(beforeCtr);			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths.x *= bigFactor;				curLengths.y *= smFactor;				curLengths.z *= bigFactor;				if (curLengths.z < (beforeLengths.z / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double xzVersionVolume = curPrim.Volume();			Point3DFloat xzVersionLen = curLengths;			Point3DFloat xzVersionCtr = curPrim.GetCtr();//  Shrink z faster:			curLengths = beforeLengths;			curPrim.SetDimensions(curLengths);			curPrim.SetCtr(beforeCtr);			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths.x *= bigFactor;				curLengths.y *= bigFactor;				curLengths.z *= smFactor;				if (curLengths.x < (beforeLengths.x / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double xyVersionVolume = curPrim.Volume();			Point3DFloat xyVersionLen = curLengths;			Point3DFloat xyVersionCtr = curPrim.GetCtr();//  Shrink x slower:			curLengths = beforeLengths;			curPrim.SetDimensions(curLengths);			curPrim.SetCtr(beforeCtr);			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths.x *= bigFactor;				curLengths.y *= smFactor;				curLengths.z *= smFactor;				if (curLengths.x < (beforeLengths.x / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double xVersionVolume = curPrim.Volume();			Point3DFloat xVersionLen = curLengths;			Point3DFloat xVersionCtr = curPrim.GetCtr();//  Shrink y slower:			curLengths = beforeLengths;			curPrim.SetDimensions(curLengths);			curPrim.SetCtr(beforeCtr);			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths.x *= smFactor;				curLengths.y *= bigFactor;				curLengths.z *= smFactor;				if (curLengths.y < (beforeLengths.y / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double yVersionVolume = curPrim.Volume();			Point3DFloat yVersionLen = curLengths;			Point3DFloat yVersionCtr = curPrim.GetCtr();//  Shrink z slower:			curLengths = beforeLengths;			curPrim.SetDimensions(curLengths);			curPrim.SetCtr(beforeCtr);			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,													// we shrink it's dimensions by 99%				curLengths.x *= smFactor;				curLengths.y *= smFactor;				curLengths.z *= bigFactor;				if (curLengths.z < (beforeLengths.z / 1000)) {					ErrorAlert theAlert("\pBad Shape", "\pI couldn't make an inscribed box after many tries.  You should inspect the crystal array for an outlier, which is the typical cause of this error.");					throw CalcError();				}				curPrim.SetDimensions(curLengths);			}			PutPrimInMiddle(curPrim, tryNum);			do {				curLengths *= 1.01;				curPrim.SetDimensions(curLengths);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much			double zVersionVolume = curPrim.Volume();			Point3DFloat zVersionLen = curLengths;			Point3DFloat zVersionCtr = curPrim.GetCtr();// Choose the best one:			Point3DFloat maxVolLengths;			Point3DFloat maxVolCtr;			double	curMaxVol = 0;			maxVolLengths = xVersionLen;			maxVolCtr = xVersionCtr;			curMaxVol = xVersionVolume;			if (yVersionVolume > curMaxVol) {				maxVolLengths = yVersionLen;				maxVolCtr = yVersionCtr;				curMaxVol = yVersionVolume;			}			if (zVersionVolume > curMaxVol) {				maxVolLengths = zVersionLen;				maxVolCtr = zVersionCtr;				curMaxVol = zVersionVolume;			}			if (xyVersionVolume > curMaxVol) {				maxVolLengths = xyVersionLen;				maxVolCtr = xyVersionCtr;				curMaxVol = xyVersionVolume;			}			if (yzVersionVolume > curMaxVol) {				maxVolLengths = yzVersionLen;				maxVolCtr = yzVersionCtr;				curMaxVol = yzVersionVolume;			}			if (xzVersionVolume > curMaxVol) {				maxVolLengths = xzVersionLen;				maxVolCtr = xzVersionCtr;				curMaxVol = xzVersionVolume;			}			if (oldVersionVolume > curMaxVol) {				maxVolLengths = oldVersionLen;				maxVolCtr = oldVersionCtr;				curMaxVol = oldVersionVolume;			}			curPrim.SetDimensions(maxVolLengths);			curPrim.SetCtr(maxVolCtr);		}	// for tryNum		while (!mBBox->PrimitiveInBox(&curPrim)) {	// reduce by very small increments, until			curLengths *= 0.999;							// it's inside the box			curPrim.SetDimensions(curLengths);		}		// take this primitive we've made, and make the BBox that primitive		mBBox->SetType(kRPBox);		mBBox->SetCtr(curPrim.GetCtr());		mBBox->SetDimensions(curPrim.GetSideLenPt());				// make the inscribed box this primitive, too		mBBox->mInscribedBox->Copy(curPrim);	break;	case kCylinder:		float	ht, rad;		ctr = mBBox->GetCtr();		rad = max(mBBox->xMax.x - mBBox->xMin.x, mBBox->yMax.y - mBBox->yMin.y) / 2;		ht = mBBox->zMax.z - mBBox->zMin.z;		curPrim.SetType(kCylBox);		curPrim.SetCtr(ctr);		curPrim.SetDimensions(rad, ht);	// this RP is now the exscribed box				for (tryNum = 1; tryNum <= numtries; tryNum++) {			while (!mBBox->PrimitiveInBox(&curPrim)) {	// as long as the RP isn't inside the box,														// we shrink it's dimensions by 99%				rad *= 0.99;				ht *= 0.99;				curPrim.SetDimensions(rad, ht);			}			// now the RP should be inscribed, but might not be very large.  We'll try moving the			// center, and then expanding the box a bit.			Point3DFloat lastCtr = ctr;			float minCtrX, maxCtrX, minCtrY, maxCtrY, minCtrZ, maxCtrZ;			do {				ctr.x -= rad * 0.01;				curPrim.SetCtr(ctr);			} while (mBBox->PrimitiveInBox(&curPrim));			ctr.x += rad * 0.01;			minCtrX = ctr.x;			ctr = lastCtr;			curPrim.SetCtr(lastCtr);			do {				ctr.x += rad * 0.01;				curPrim.SetCtr(ctr);			} while (mBBox->PrimitiveInBox(&curPrim));			ctr.x -= rad * 0.01;			maxCtrX = ctr.x;			ctr = lastCtr;			curPrim.SetCtr(lastCtr);			do {				ctr.y -= rad * 0.01;				curPrim.SetCtr(ctr);			} while (mBBox->PrimitiveInBox(&curPrim));			ctr.y += rad * 0.01;			minCtrY = ctr.y;			ctr = lastCtr;			curPrim.SetCtr(lastCtr);			do {				ctr.y += rad * 0.01;				curPrim.SetCtr(ctr);			} while (mBBox->PrimitiveInBox(&curPrim));			ctr.y -= rad * 0.01;			maxCtrY = ctr.y;			ctr = lastCtr;			curPrim.SetCtr(lastCtr);			do {				ctr.z -= ht * 0.01;				curPrim.SetCtr(ctr);			} while (mBBox->PrimitiveInBox(&curPrim));			ctr.z += ht * 0.01;			minCtrZ = ctr.z;			ctr = lastCtr;			curPrim.SetCtr(lastCtr);			do {				ctr.z += ht * 0.01;				curPrim.SetCtr(ctr);			} while (mBBox->PrimitiveInBox(&curPrim));			ctr.z -= ht * 0.01;			maxCtrZ = ctr.z;			curPrim.SetCtr(lastCtr);			ctr.x = (maxCtrX + minCtrX) / 2.0;			ctr.y = (maxCtrY + minCtrY) / 2.0;			ctr.z = (maxCtrZ + minCtrZ) / 2.0;			curPrim.SetCtr(ctr);						do {				ht *= 1.01;				rad *= 1.01;				curPrim.SetDimensions(rad, ht);			} while (mBBox->PrimitiveInBox(&curPrim));				// now the primitive is outside the box again, but not by much		}	// for tryNum		while (!mBBox->PrimitiveInBox(&curPrim)) {	// reduce by very small increments, until				ht *= 0.999;						// it's inside the box				rad *= 0.999;			curPrim.SetDimensions(rad, ht);		}		// take this primitive we've made, and make the BBox that primitive		mBBox->SetType(kCylBox);		mBBox->SetCtr(ctr);		mBBox->SetDimensions(rad, ht);		if (mPrefs->fixClaude) {			// CLAUDE only:  We know that the radius should be 1.2 cm			ctr.x = 1.2;			ctr.y = 1.2;			rad = 1.2;			mBBox->SetCtr(ctr);			mBBox->SetDimensions(rad, ht);		}			// make the inscribed box this primitive, too		mBBox->mInscribedBox->Copy((SideSet &) *mBBox);	break;	case kSides: // if kSides is selected, then leave the BBox the way it is - a collection of sides	default:	break;	}}// ---------------------------------------------------------------------------//		¥ PutPrimInMiddle// ---------------------------------------------------------------------------/* This function finds the limits on the where we can place a primitive, and puts	it in the middle of these limits */voidCReduceApp::PutPrimInMiddle(SideSet &ioPrim, short tryNum){	// now the RP should be inscribed, but might not be very large.  We'll try moving the	// center (faster for early tries), and then expanding the box a bit.	Point3DFloat firstCtr = ioPrim.GetCtr();	Point3DFloat ctr = firstCtr;	Point3DFloat mins, maxes;	Point3DFloat lengths = ioPrim.GetSideLenPt();	if (tryNum == -1)		tryNum = 1;		// Find lower x bound	do {		ctr.x -= (lengths.x/tryNum) * 0.01;		ioPrim.SetCtr(ctr);	} while (mBBox->PrimitiveInBox(&ioPrim));	ctr.x += (lengths.x/tryNum) * 0.01;	mins.x = ctr.x;		// Find upper x bound	ctr = firstCtr;	ioPrim.SetCtr(firstCtr);	do {		ctr.x += (lengths.x/tryNum) * 0.01;		ioPrim.SetCtr(ctr);	} while (mBBox->PrimitiveInBox(&ioPrim));	ctr.x -= (lengths.x/tryNum) * 0.01;	maxes.x = ctr.x;		// Find lower y bound	ctr = firstCtr;	ioPrim.SetCtr(firstCtr);	do {		ctr.y -= (lengths.y/tryNum) * 0.01;		ioPrim.SetCtr(ctr);	} while (mBBox->PrimitiveInBox(&ioPrim));	ctr.y += (lengths.y/tryNum) * 0.01;	mins.y = ctr.y;		// Find upper y bound	ctr = firstCtr;	ioPrim.SetCtr(firstCtr);	do {		ctr.y += (lengths.y/tryNum) * 0.01;		ioPrim.SetCtr(ctr);	} while (mBBox->PrimitiveInBox(&ioPrim));	ctr.y -= (lengths.y/tryNum) * 0.01;	maxes.y = ctr.y;		// Find lower z bound	ctr = firstCtr;	ioPrim.SetCtr(firstCtr);	do {		ctr.z -= (lengths.z/tryNum) * 0.01;		ioPrim.SetCtr(ctr);	} while (mBBox->PrimitiveInBox(&ioPrim));	ctr.z += (lengths.z/tryNum) * 0.01;	mins.z = ctr.z;		// Find upper z bound	ctr = firstCtr;	ioPrim.SetCtr(firstCtr);	do {		ctr.z += (lengths.z/tryNum) * 0.01;		ioPrim.SetCtr(ctr);	} while (mBBox->PrimitiveInBox(&ioPrim));	ctr.z -= (lengths.z/tryNum) * 0.01;	maxes.z = ctr.z;		ctr = (maxes + mins) / 2.0;	ioPrim.SetCtr(ctr);}// ---------------------------------------------------------------------------//		¥ NewFindBestRPPrimitive// ---------------------------------------------------------------------------voidCReduceApp::NewFindBestRPPrimitive(SideSet &ioPrim){	Point3DFloat sampleCtr, bestLen, bestCtr, tempLen, randomCtr, randomSidesLength;	double curVolume = 0, bestVolume = 0;	long numMCTries = 100000;	ioPrim.SetType(kRPBox);	mProgress->Show();	mProgress->SetActionDescriptor("\pLooking for best primitive to fit in bounding box...");	mProgress->SetValues(1, numMCTries, 1);		// Find Center	sampleCtr = mBBox->GetCtr();		// Find Bounds	Point3DFloat lengths(mBBox->xMax.x - mBBox->xMin.x,							mBBox->yMax.y - mBBox->yMin.y,							mBBox->zMax.z - mBBox->zMin.z);		// Make box for random centers - centered at sample center, with sides 1/3 bound length	SideSet centerBox;	centerBox.SetType(kRPBox);	centerBox.SetCtr(sampleCtr);	tempLen = lengths/3;	centerBox.SetDimensions(tempLen);		// Make boxes (min & max) for random side lengths - not for real space consideration,		// just ease of coding (we treat xLen, yLen and zLen as 3 dimensions, and then		// randomize inside a box in those dimensions) - that's why box center is at (xLen/2, yLen/2, ZLen/2)	SideSet maxSideBox;	maxSideBox.SetType(kRPBox);	tempLen = lengths * 1.3;	maxSideBox.SetDimensions(tempLen);	maxSideBox.SetCtr(tempLen/2);	SideSet minSideBox;	minSideBox.SetType(kRPBox);	tempLen = lengths * 0.05;	minSideBox.SetDimensions(tempLen);	maxSideBox.SetCtr(tempLen/2);		// For each Try:	for (long tryNum = 1; tryNum <= numMCTries; tryNum++) {		mProgress->Progress(tryNum);			// get random center		centerBox.RandPtInPrimitive(randomCtr);			// get random lengths		do {			maxSideBox.RandPtInPrimitive(randomSidesLength);		} while ((randomSidesLength.x < minSideBox.GetXLen()) ||				(randomSidesLength.y < minSideBox.GetYLen()) ||				(randomSidesLength.z < minSideBox.GetZLen()));			// adjust ioPrim		ioPrim.SetCtr(randomCtr);		ioPrim.SetDimensions(randomSidesLength);			// if primitive is inside box and		if (mBBox->PrimitiveInBox(&ioPrim)) {				// if it has the biggest volume so far, then			curVolume = ioPrim.Volume();			if (curVolume > bestVolume) {				// record these settings as the best so far				bestVolume = curVolume;				bestCtr = randomCtr;				bestLen = randomSidesLength;			}		}	}	ioPrim.SetCtr(bestCtr);	ioPrim.SetDimensions(bestLen);}// ---------------------------------------------------------------------------//		¥ AdaptToPrimitiveBox// ---------------------------------------------------------------------------voidCReduceApp::AdaptToPrimitiveBox(){	Crystal thisXl;	Crystal *thisXlPtr;	short thisXlNum;	short badClaude1 = 0;	short badClaude2 = 0;		if (mPrefs->fixClaude) {		ErrorAlert err("\pFixing Claude", "\pImplementing Claude-fixing routine.  If the rock isn't Claude, stop now!.", 2);	}	for (thisXlNum = 1; thisXlNum <= mTheXls->GetCount(); thisXlNum++) {	// for each Xl		mTheXls->FetchItemAt(thisXlNum, &thisXl);		if ((thisXlNum <= mTheXls->GetCount()) && (!mBBox->PointInBox(thisXl.ctr))) {			mTheXls->RemoveItemsAt(1, thisXlNum);			thisXlNum--;	// need this, because there's now a different crystal in spot number thisXlNum		} else if (mPrefs->fixClaude) {			if ((thisXlNum <= mTheXls->GetCount()) && (mBBox->XlTouchesBox(thisXl))) {				// This is for CLAUDE only!  He was blobbed poorly!				mTheXls->RemoveItemsAt(1, thisXlNum);				badClaude1++;				thisXlNum--;	// need this, because there's now a different crystal in spot number thisXlNum			} else if ((thisXlNum <= mTheXls->GetCount()) && (thisXl.r < mPrefs->discard)) {				mTheXls->RemoveItemsAt(1, thisXlNum);				badClaude2++;				thisXlNum--;	// need this, because there's now a different crystal in spot number thisXlNum			}		}	}		if (mPrefs->fixClaude) {		LStr255 str = "\pClaude Fixed.  Removed ";		str += (SInt32) badClaude1;		str += "\p border crystals, and ";		str += (SInt32) badClaude2;		str += "\p tiny crystals (radius < ";		str += FltStr(mPrefs->discard, 3);		str += "\p cm).  ";		str += (SInt32) mTheXls->GetCount();		str += "\p crystals remaining.";		ErrorAlert err2("\pFixing Claude", str, 2);	}		mTheXls->Lock();	mStats->numXlsForL = mTheXls->GetCount();	for (thisXlNum = 1; thisXlNum <= mStats->numXlsForL; thisXlNum++) {	// for each Xl		thisXlPtr = (Crystal *) mTheXls->GetItemPtr(thisXlNum);		mStats->newMeanR += thisXlPtr->r / mStats->numXlsForL;	}	mTheXls->Unlock();	mTheXls->RebuildLists();}#pragma mark ==================== Correlation Function Stuff// ---------------------------------------------------------------------------//		¥ ComputeCFs_Both// ---------------------------------------------------------------------------/*	Doing this calculation can be exceedingly slow, so this routine has been	highly optimized for speed & efficiency (I hope).  The basic idea is this:	over a range of scales ("hDistances"), we count the number of pairs of crystals	whose centers are (1) separated by less than or equal to that distance (L function),	or (2) separated by about that distance (PCF, MCF).  Instead of doing that task	this way:		for each hDistance		for each crystal			for each other crystal				are the two crystals separated by less than the hDistance??			end for		end for	end for		...which would require lots of distance calculations, we do it this way:		for each crystal		for each other crystal			figure out separation			for each hDistance				is this hDistance greater than the separation?			end for		end for	end for*/									voidCReduceApp::ComputeCFs_Both(){	long numPts = mStats->numLPoints;	float EpBandwidth = mPrefs->EpanecnikovCVal / CubeRoot(mStats->intensity);		mProgress->SetActionDescriptor("\pCalculating L, PCF, MCF...");	mProgress->SetValues(0, mStats->numXlsForL, 0);	mProgress->SetIncrements(50);	double			tempPCF, h, OIV; 	double			curDist;	long			thisHNum;	double			nearestSideThis, nearestSideOther;	long			*numXlsUsed = new long[numPts+1];	// N in K2 formula; N+ is mStats->numCrystals	long			*numMCFXlsUsed = new long[numPts+1];	long			*numMCFgdXlsUsed = new long[numPts+1];	Crystal			*otherXl;	Crystal			*thisXl;	for (thisHNum = 0; thisHNum <= numPts; thisHNum++) {		numXlsUsed[thisHNum] = 0.0;		numMCFXlsUsed[thisHNum] = 0.0;		numMCFgdXlsUsed[thisHNum] = 0.0;	}		for (short thisXlNum = 1; thisXlNum <= mStats->numXlsForL; thisXlNum++) {	// for each Xl		mProgress->Progress(thisXlNum);		mTheXls->Lock();		thisXl = (Crystal *) mTheXls->GetItemPtr(thisXlNum);		if (mHoles) {			nearestSideThis = min(mBBox->NearestSideDist(thisXl->ctr), mHoles->NearestHoleDist(thisXl->ctr));		} else {			nearestSideThis = mBBox->NearestSideDist(thisXl->ctr);		}		for (thisHNum = 1; thisHNum <= numPts; thisHNum++) {			if (mStats->hDistances[thisHNum] <= nearestSideThis)				numXlsUsed[thisHNum]++;		}		for (short otherXlNum = thisXlNum+1; otherXlNum <= mStats->numXlsForL; otherXlNum++) {			otherXl = (Crystal *) mTheXls->GetItemPtr(otherXlNum);			if (otherXlNum != thisXlNum) {				if (mHoles) {					nearestSideOther = min(mBBox->NearestSideDist(otherXl->ctr), mHoles->NearestHoleDist(otherXl->ctr));				} else {					nearestSideOther = mBBox->NearestSideDist(otherXl->ctr);				}				curDist = thisXl->ctr.Distance(otherXl->ctr);				thisHNum = 1;				if (curDist <= mStats->hDistances[numPts] + EpBandwidth) {	// if the distance is in the range of our h's					OIV = OffsetIntersectVol(thisXl->ctr, otherXl->ctr);					while (thisHNum <= numPts) {	// for each h, h > curDist						h = mStats->hDistances[thisHNum];						if (curDist <= h) {//						if (curDist < h) {							mStats->LValues[thisHNum] += 2.0/OIV;							if (h <= nearestSideThis) {								mStats->LgdValues[thisHNum] += 1.0;							}							if (h <= nearestSideOther) {								mStats->LgdValues[thisHNum] += 1.0;							}						}						if (mPrefs->useRaeburn)							tempPCF = Epanecnikov(EpBandwidth, curDist - h) / (4 * gPI * sqr(curDist));	// Raeburn p.132						else							tempPCF = Epanecnikov(EpBandwidth, curDist - h) / (4 * gPI * sqr(h));	// Stoyan & Stoyan p.284						if (tempPCF > 0) {							mStats->PCF[thisHNum] += 2.0 * tempPCF / OIV;							float thisV = (4.0 / 3.0) * gPI * pow(thisXl->r,3);							float otherV = (4.0 / 3.0) * gPI * pow(otherXl->r,3);							if (mPrefs->useVolume) {								mStats->MCF[thisHNum] += 2.0 * thisV * otherV * tempPCF / OIV;								mStats->MCF3[thisHNum] += 0.5 * (thisV + otherV);							} else {								mStats->MCF[thisHNum] += 2.0 * thisXl->r * otherXl->r * tempPCF / OIV;								mStats->MCF3[thisHNum] += 0.5 * (thisXl->r + otherXl->r);							}							numMCFXlsUsed[thisHNum]++;							if (h <= nearestSideThis) {								mStats->PCFgd[thisHNum] += tempPCF;								if (mPrefs->useVolume) {									mStats->MCFgd[thisHNum] += thisV * otherV * tempPCF;									mStats->MCF3gd[thisHNum] += 0.5 * (thisV + otherV);								} else {									mStats->MCFgd[thisHNum] += thisXl->r * otherXl->r * tempPCF;									mStats->MCF3gd[thisHNum] += 0.5 * (thisXl->r + otherXl->r);								}								numMCFgdXlsUsed[thisHNum]++;							}							if (h <= nearestSideOther) {								mStats->PCFgd[thisHNum] += tempPCF;								if (mPrefs->useVolume) {									mStats->MCFgd[thisHNum] += thisV * otherV * tempPCF;									mStats->MCF3gd[thisHNum] += 0.5 * (thisV + otherV);								} else {									mStats->MCFgd[thisHNum] += thisXl->r * otherXl->r * tempPCF;									mStats->MCF3gd[thisHNum] += 0.5 * (thisXl->r + otherXl->r);								}								numMCFgdXlsUsed[thisHNum]++;							}						}						thisHNum++;					}				}			}		}		mTheXls->Unlock();	}	mStats->intensitySqd = FindIntensitySquared();	for (thisHNum = 1; thisHNum <= numPts; thisHNum++) {	// for each h:		mStats->LValues[thisHNum] = pow((double)(0.75 * (			mStats->LValues[thisHNum] / mStats->intensitySqd		// <-- K function			) / gPI), (double)(1.0/3.0)) - mStats->hDistances[thisHNum];		mStats->PCF[thisHNum] = mStats->PCF[thisHNum] / mStats->intensitySqd;		if (mPrefs->useVolume) {			mStats->MCF[thisHNum] = mStats->MCF[thisHNum] / (mStats->intensitySqd * sqr(mStats->meanActV));			mStats->MCF[thisHNum] = mStats->MCF[thisHNum] / mStats->PCF[thisHNum];			mStats->MCF3[thisHNum] = mStats->MCF3[thisHNum] / (numMCFXlsUsed[thisHNum] * mStats->meanActV);		} else {			mStats->MCF[thisHNum] = mStats->MCF[thisHNum] / (mStats->intensitySqd * sqr(mStats->newMeanR));			mStats->MCF[thisHNum] = mStats->MCF[thisHNum] / mStats->PCF[thisHNum];			mStats->MCF3[thisHNum] = mStats->MCF3[thisHNum] / (numMCFXlsUsed[thisHNum] * mStats->newMeanR);		}		if (numXlsUsed[thisHNum] > 0) {			double KValue = mStats->LgdValues[thisHNum] / (mBBox->VolumeMinusGuard(mStats->hDistances[thisHNum]) * mStats->intensitySqd);			mStats->LgdValues[thisHNum] = pow((double)(0.75 * KValue / gPI), 1.0/3.0) - mStats->hDistances[thisHNum];		}		mStats->PCFgd[thisHNum] = (mStats->PCFgd[thisHNum] / (mStats->intensity * numXlsUsed[thisHNum]));		if (mPrefs->useVolume) {			mStats->MCFgd[thisHNum] = (mStats->MCFgd[thisHNum] / (mStats->intensity * sqr(mStats->meanActV) * numXlsUsed[thisHNum]));			mStats->MCFgd[thisHNum] = mStats->MCFgd[thisHNum] / mStats->PCFgd[thisHNum];			mStats->MCF3gd[thisHNum] = (mStats->MCF3gd[thisHNum] / (numMCFgdXlsUsed[thisHNum] * mStats->meanActV));		} else {			mStats->MCFgd[thisHNum] = (mStats->MCFgd[thisHNum] / (mStats->intensity * sqr(mStats->newMeanR) * numXlsUsed[thisHNum]));			mStats->MCFgd[thisHNum] = mStats->MCFgd[thisHNum] / mStats->PCFgd[thisHNum];			mStats->MCF3gd[thisHNum] = (mStats->MCF3gd[thisHNum] / (numMCFgdXlsUsed[thisHNum] * mStats->newMeanR));		}	}	delete[] numXlsUsed;	delete[] numMCFXlsUsed;	delete[] numMCFgdXlsUsed;}// ---------------------------------------------------------------------------//		¥ Epanecnikov// ---------------------------------------------------------------------------floatCReduceApp::Epanecnikov(float bandwidth, float t){	if (::fabs(t) > bandwidth)		return 0;	else		return (0.75 * (1 - (sqr(t)/sqr(bandwidth))) / bandwidth);}// ---------------------------------------------------------------------------//		¥ OffsetIntersectVol// ---------------------------------------------------------------------------floatCReduceApp::OffsetIntersectVol(Point3DFloat inPt1, Point3DFloat inPt2){	Point3DFloat offSet = inPt1-inPt2;		switch (mBBox->GetType()) {		case kCubeBox:			if (((mBBox->GetSideLen() - ::fabs(offSet.x)) < 0) ||				((mBBox->GetSideLen() - ::fabs(offSet.y)) < 0) ||				((mBBox->GetSideLen() - ::fabs(offSet.z)) < 0))				return 0;			return ((mBBox->GetSideLen() - ::fabs(offSet.x)) *					(mBBox->GetSideLen() - ::fabs(offSet.y)) *					(mBBox->GetSideLen() - ::fabs(offSet.z)));		break;		case kRPBox:			if (((mBBox->GetXLen() - ::fabs(offSet.x)) < 0) ||				((mBBox->GetYLen() - ::fabs(offSet.y)) < 0) ||				((mBBox->GetZLen() - ::fabs(offSet.z)) < 0))				return 0;			return ((mBBox->GetXLen() - ::fabs(offSet.x)) *					(mBBox->GetYLen() - ::fabs(offSet.y)) *					(mBBox->GetZLen() - ::fabs(offSet.z)));		break;		case kCylBox:			// formula from Stoyan & Stoyan, appendix K; (version r=R)			float t, r, h;			t = sqrt(sqr(offSet.x) + sqr(offSet.y));			h = mBBox->GetHeight() - ::fabs(offSet.z);	// Was in error - called getZLen here!  Fixed 8/8/07			r = mBBox->GetRadius();			if ((h < 0) || (t > 2*r))				return 0;			return h * ((2 * sqr(r) * acos(t/(2*r))) -						(t/2) * sqrt(4*sqr(r) - sqr(t)));		break;		case kSidesBox:			static BoundingBox offsetBox;			static Boolean firstTimeThru = true;			if (firstTimeThru)  {				firstTimeThru = false;				offsetBox.Copy(*mBBox);			}			offsetBox.SetOffset(inPt1-inPt2);						static SideSet reducedCube;	// this is a cube that fits around the intersection volume			reducedCube.SetType(kCubeBox);			reducedCube.SetCtr(offSet/2 + mBBox->GetCtr());			reducedCube.SetSideLen((mBBox->GetExscribedCube())->GetSideLen());			short numInside = 0;			Point3DFloat curPt;			for (short thisMCTry = 1; thisMCTry <= mPrefs->numCFOffsetVolPts; thisMCTry++) {				reducedCube.RandPtInPrimitive(curPt);				if (offsetBox.PointInBox(curPt) && mBBox->PointInBox(curPt))					numInside++;			}			return (pow((double)(reducedCube.GetSideLen()), (double)(3)) * numInside / mPrefs->numCFOffsetVolPts);		break;		default:			Throw_(0);		break;	}	return positiveInfinity;}// ---------------------------------------------------------------------------//		¥ FindIntensitySquared// ---------------------------------------------------------------------------/*  The square of an estimator for intensity is not the best estimator for 	the square of the intensity.  It's better to use N * N-1 / Vol^2.  That's	what we do here.	Since using the bounding box will overestimate the intensity, we'll use the	inscribed box's volume and number of crystals.  If we've got Holes, then	we'll do Monte Carlo to get the non-hole volume of the inscribed box. */floatCReduceApp::FindIntensitySquared(){	float intensity = 0;	if (mHoles){		SideSet *mIB = mBBox->GetInscribedBox();		short n = mIB->NumPointsInBox(mTheXls);				SideSet *mEC = mBBox->GetExscribedCube();		long inPoints = 0;		Point3DFloat tryPoint;			srand(::TickCount());		long MCTries = mPrefs->MCReps;		for (long i = 1; i <= MCTries; i++) {			mEC->RandPtInPrimitive(tryPoint);			if (mIB->RawPointInBox(tryPoint) && !mHoles->PointInHole(tryPoint))				inPoints++;		}		float vol = mEC->Volume() * MCTries / inPoints;		if (mSimulating) {			intensity = mStats->numXlsForL * (mStats->numXlsForL-1) / sqr(vol);		} else {			intensity = n * (n-1) / sqr(vol);		}	} else {		if (!mSimulating) {			SideSet *mIB = mBBox->GetInscribedBox();			short n = mIB->NumPointsInBox(mTheXls);						intensity = n * (n-1) / sqr(mIB->Volume());		} else {			intensity = mStats->numXlsForL * (mStats->numXlsForL-1) / sqr(mBBox->Volume());		}	}	return intensity;}// ---------------------------------------------------------------------------//		¥ FindIntensity// ---------------------------------------------------------------------------/* Since using the bounding box will overestimate the intensity, we'll use the	inscribed box's volume and number of crystals.  If we've got Holes, then	we'll do Monte Carlo to get the non-hole volume of the inscribed box. */floatCReduceApp::FindIntensity(){	float intensity = 0;	if (mHoles){		SideSet *mIB = mBBox->GetInscribedBox();		short n = mIB->NumPointsInBox(mTheXls);				SideSet *mEC = mBBox->GetExscribedCube();		long inPoints = 0;		Point3DFloat tryPoint;			srand(::TickCount());		long MCTries = mPrefs->MCReps;		for (long i = 1; i <= MCTries; i++) {			mEC->RandPtInPrimitive(tryPoint);			if (mIB->RawPointInBox(tryPoint) && !mHoles->PointInHole(tryPoint))				inPoints++;		}		float vol = mEC->Volume() * MCTries / inPoints;		if (mSimulating) {			intensity = mStats->numXlsForL / vol;		} else {			intensity = n / vol;		}	} else {		if (!mSimulating) {			SideSet *mIB = mBBox->GetInscribedBox();			short n = mIB->NumPointsInBox(mTheXls);						intensity = n / mIB->Volume();		} else {			intensity = mStats->numXlsForL / mBBox->Volume();		}	}	return intensity;}void * gDebugHelper;#pragma mark ============================= Envelope Stuff// ---------------------------------------------------------------------------//		¥ DoEnvelopes// ---------------------------------------------------------------------------voidCReduceApp::DoEnvelopes(){	LProgressDialog *EnvProgress;	EnvProgress = (LProgressDialog *)		LWindow::CreateWindow( kProgressDialogID, LCommander::GetTopCommander() );	ThrowIfNil_( EnvProgress );	if (mSimulation != nil) {		delete mSimulation;		mSimulation = nil;	}	mSimulation = new CrystalArray();	EnvProgress->SetTitle("\pCalculating Envelope");	EnvProgress->SetActionDescriptor("\pMaking and reducing IC simulations...");	EnvProgress->SetValues(1, mPrefs->numEnvelopeRuns, 0);	Point NewPosition = {55,20};	EnvProgress->DoSetPosition(NewPosition);	EnvProgress->Deactivate();	EnvProgress->Show();	// sort Xls by radii, inverse, so as to simulate placing largest Xls first	RadXlComp		*theRadXlCompPtr;	theRadXlCompPtr = new RadXlComp;	mTheXls->SetComparator(theRadXlCompPtr, false);	mTheXls->Sort();	Boolean matchingCTDataSet = (mTheXls->GetBounds() != kBoundsNone);	// assumes that all datasets without Bounds are real CT data, and that all with Bounds are simulations	short numPts = mStats->numLPoints;	short numEnv = mPrefs->numEnvelopeRuns;	mDoSigmas = mPrefs->outputSigmas;	Stats *tempStats;	tempStats = mStats;	mStats = new Stats();	// make new Stats to hold envelope calcs - has to be in mStats to use same data processing routines	mStats->SetCFParams(tempStats->numLPoints, tempStats->mSigmas);	// make a list of the radii, in order to make simulations:	long numXls = mTheXls->GetCount();	Crystal *thisXl;	double *RadiiList = new double[numXls+1];	RadiiList[0] = numXls;	mTheXls->Lock();	for (long i = 1; i <= numXls; i++) {		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		RadiiList[i] = thisXl->r;	}	mTheXls->Unlock();		BoundingBox *tempBBox = new BoundingBox(*mBBox);	// copy current BBox & Xls so that the ones CalcStats see are those for the Envelope sims														// also makes its own copy of mBBox->mXls	CrystalArray *tempXls = tempBBox->GetXls();	gDebugHelper = tempBBox;	mTheXls->Clear();		EnvelopeData	Envelopes(numEnv, numPts, mDoSigmas);	mSimulating = true;	LStr255 debugStr;	try {		for (short thisEnvRun = 1; thisEnvRun <= numEnv; thisEnvRun++) {	if (mPrefs->verbose) {		mDebugOutputFile->OpenDataFork(fsRdWrPerm);		debugStr = "\p\t\t\t\t\tBeginning Envelope #";		debugStr += (SInt32)thisEnvRun;		debugStr += "\p\n";		mDebugOutputFile->SetMarker(0, streamFrom_End);		mDebugOutputFile->putOneLine(debugStr);		mDebugOutputFile->CloseDataFork();	}			EnvProgress->Progress(thisEnvRun);			mStats->Clear();			mStats->numXlsForL = tempStats->numXlsForL;			mStats->numCrystals = tempStats->numCrystals;			mStats->BBSides = tempStats->BBSides;			mStats->BBVolume = tempStats->BBVolume;			mStats->totalVolume = tempStats->totalVolume;			mStats->totalPosXls = tempStats->totalPosXls;			mStats->numLPoints = tempStats->numLPoints;			mStats->maxR = tempStats->maxR;			for (short i = 1; i <= tempStats->numLPoints; i++) {				mStats->hDistances[i] = tempStats->hDistances[i];			}			mTheXls->InitXlArray(tempXls);			mTheXls->Clear();			float newMeanR = MakeGoodRandomSimulation(RadiiList, tempStats->volFrxn, matchingCTDataSet);			// really just for debugging purposes: holding down shift-option at the end of making the envelope			// will save the envelope simulation to a suitably-named integrate file that can then be rendered,			// reduced, etc.			KeyMap theMap;			::GetKeys(theMap);			if ((theMap[1]) & (myShiftKey | myOptionKey)) {				FSSpec theSpec;				mInputFile->GetSpecifier(theSpec);				LStr255 newName = MakeCSDFileName(theSpec.name, kEnvelope);								FSSpec outSpec;				outSpec.vRefNum = (mInputFile->GetSpec()).vRefNum;				outSpec.parID = (mInputFile->GetSpec()).parID;				LString::CopyPStr(newName, outSpec.name, sizeof(Str63));								mCSDOutputFile = new myLFileStream(outSpec);				mCSDOutputFile->CreateNewDataFile(CW_fileCreator, 'TEXT');				mCSDOutputFile->OpenDataFork(fsRdWrPerm);				WriteIntFile(thisEnvRun, tempStats->meanR, newMeanR);				mCSDOutputFile->CloseDataFork();				delete mCSDOutputFile;				mCSDOutputFile = nil;				mProgress->Show();			}			CalcStats();			ExtractEnvData(mStats, Envelopes.GetSet(thisEnvRun));			mSimulation->Clear();		}		delete[] RadiiList;		EnvProgress->Hide();	} catch (LProgressDialog::StopClicked theStopClicked) {		mProgress->Hide();	// Hide the regular one		EnvProgress->Hide();		delete[] RadiiList;		if (theStopClicked.theThrower == EnvProgress) {			delete EnvProgress;			EnvProgress = nil;		}		delete mStats;		mStats = tempStats;				delete mTheXls;		mTheXls = tempXls;		mBBox->theXls = tempXls;		tempBBox->theXls = nil;		delete tempBBox;		if (theRadXlCompPtr != nil) {			delete theRadXlCompPtr;			theRadXlCompPtr = nil;		}		delete mSimulation;		mSimulation = nil;		throw;	// will be caught higher up, and there the one that was clicked will be hidden	} catch (SimulationErr theSimErr) {		delete mProgress;		delete EnvProgress;		throw SimulationErr();	}	mSimulating = false;	delete mStats;	mStats = tempStats;	EvaluateCFStats(Envelopes, mDoSigmas, mPrefs->confidence);	delete mTheXls;	mTheXls = tempXls;	mBBox->theXls = tempXls;		tempBBox->theXls = nil;	delete tempBBox;	if (theRadXlCompPtr != nil) {		delete theRadXlCompPtr;		theRadXlCompPtr = nil;	}	delete mSimulation;	mSimulation = nil;	delete EnvProgress;	EnvProgress = nil;}// ---------------------------------------------------------------------------//		¥ MakeGoodRandomSimulation// ---------------------------------------------------------------------------//	Make a good random simulation (has VF of inVolFraction) and put it into mBBox (i.e. mTheXls)/*	Input:	inRadiiList - the list of radii to place in the simulation			inVolFraction - the VF we're shooting for (the VF of the sample dataset)			inMatchingCTDataSet - whether the dataset we whose VF we're trying to match									was derived from CT data, or was manufactured by									Crystallize or MakeSimulation*/floatCReduceApp::MakeGoodRandomSimulation(double *inRadiiList, float inVolFraction, Boolean inMatchingCTDataSet){	double neededRadiusEachXl;	float roughTolerance = inVolFraction * mPrefs->VFPercent * 5.0 / 100.0;	// first-cut VF should be within 5 * x % of target VF	float tolerance = inVolFraction * mPrefs->VFPercent / 100.0;	long numXls = inRadiiList[0];	Boolean goodSim = false;	short direction, lastDirection;	float BBVol = mBBox->Volume();	static float roughGranularity = mBBox->GetMCVolFracGranularity(kPrefValRough);	float meanR = 0;		// copy inRadiiList to a working list that can be changed	double *workingList = new double[numXls+1];	workingList[0] = inRadiiList[0];	for (long i = 1; i <= numXls; i++) {		workingList[i] = inRadiiList[i];	// this could be a BlockMove instead		meanR += inRadiiList[i];	}	meanR /= inRadiiList[0];	float startingMeanRadius = meanR;	float factor = (meanR > 2) ? 1 : 32;	mProgress->SetValues(0,0,0);	mProgress->SetActionDescriptor("\pMaking Envelope Simulation");		short initialTries = (mPrefs->makeDCEnv) ? kNumSimMakerRestarts*10 : 1;	float betafactorfactor = 1.0;	Boolean goodFirstSim = false;	long tryNum=1;	do {		try {			mBBox->MakeRandomSimulation(workingList, mProgress, inMatchingCTDataSet, inVolFraction, mHoles, betafactorfactor);	// make random simulation with unchanged radii list, put into mBBox			goodFirstSim = true;			if (mPrefs->verbose) {				LStr255 debugStr;				mDebugOutputFile->OpenDataFork(fsRdWrPerm);				debugStr = "\pMade a good first, possibly DC simulation with betafactorfactor of\t";				debugStr += FltStr(betafactorfactor,3);				debugStr += "\p\tand a VF of\t";				debugStr += FltStr(inVolFraction,3);				debugStr += "\p\n";				mDebugOutputFile->SetMarker(0, streamFrom_End);				mDebugOutputFile->putOneLine(debugStr);				mDebugOutputFile->CloseDataFork();			}			mProgress->Progress(1);		} catch (BoundingBox::SimulationErr theSimErr) {			// couldn't make the first simulation - probably failed at "DC Envelopes"			if (tryNum++ >= initialTries) {				ErrorAlert theAlert("\pReally Bad Simulation", "\pI couldn't make even one good simulation.  Please quit, and complain to the programmer.");				delete mProgress;			} else {				ErrorAlert theAlert("\pBad Simulation", "\pI couldn't make a good DC simulation.  Shrinking depleted zones and re-trying.", 0.5);				betafactorfactor *= 0.9;	// shrink depleted zones to make crystals fit			}		}	} while (!goodFirstSim);	if (mPrefs->matchVF) {		float curVolFrac = mBBox->GetVolumeFraction(mProgress, kPrefVal, mHoles);	// do one high-precision test - maybe we don't need to change anything!		goodSim = (::fabs(curVolFrac - inVolFraction) <= tolerance);		if (!goodSim) {			try {				if ((::fabs(curVolFrac - inVolFraction) > roughTolerance)	// we didn't get close enough to avoid the rough steps, AND					&& (roughGranularity < roughTolerance)) {	// we can actually succeed, because the steps in the VF																// numbers don't mean we'll jump over the correct range of values					direction = lastDirection = sign(inVolFraction - curVolFrac);					while (!goodSim && (factor > 1)) {						while (!goodSim && (direction == lastDirection)) {		//					neededVolume = (inVolFraction - curVolFrac) * BBVol;		//					neededVolumeEachXl = neededVolume / numXls;		//					neededRadiusEachXl = neededVolumeEachXl * 1.5 / (4.0 * gPI * meanR);	// this is an empirical approximation							neededRadiusEachXl = ((inVolFraction - curVolFrac) * BBVol / numXls) * 1.5;	// condensed version							for (long i = 1; i <= numXls; i++) {								workingList[i] += neededRadiusEachXl * factor;	// this could be a BlockMove instead							}							meanR += neededRadiusEachXl * factor;							mTheXls->Clear();	// clear out CrystalArray							mBBox->MakeRandomSimulation(workingList, mProgress, inMatchingCTDataSet, inVolFraction, mHoles);	// make random simulation with new radii list							curVolFrac = mBBox->GetVolumeFraction(mProgress, kPrefValRough, mHoles);							goodSim = (::fabs(curVolFrac - inVolFraction) <= roughTolerance);							lastDirection = direction;							direction = sign(inVolFraction - curVolFrac);							mProgress->Progress(1);						}						factor /= 2.0;						lastDirection = direction;					}				}			} catch (BoundingBox::SimulationErr theSimErr) {				// reset radii - they may have gotten far out-of-whack				meanR = 0;				for (long i = 1; i <= numXls; i++) {					workingList[i] = inRadiiList[i]; // reset working radii list					meanR += workingList[i];				}				meanR /= numXls;				mBBox->MakeRandomSimulation(workingList, mProgress, inMatchingCTDataSet, inVolFraction, mHoles);	// make random simulation with new radii list				// then just fall through to high-precision section			}						factor = 16.0;			curVolFrac = mBBox->GetVolumeFraction(mProgress, kPrefVal, mHoles);			goodSim = (::fabs(curVolFrac - inVolFraction) <= tolerance);			direction = lastDirection = sign(inVolFraction - curVolFrac);			while (!goodSim) {				try {					while (!goodSim && (direction == lastDirection)) {						neededRadiusEachXl = ((inVolFraction - curVolFrac) * BBVol / numXls) * 1.5;	// condensed version						for (long i = 1; i <= numXls; i++) {							workingList[i] += neededRadiusEachXl * factor;	// this could be a BlockMove instead						}						meanR += neededRadiusEachXl * factor;						mTheXls->Clear();						mBBox->MakeRandomSimulation(workingList, mProgress, inMatchingCTDataSet, inVolFraction, mHoles);	// make random simulation with new radii list						curVolFrac = mBBox->GetVolumeFraction(mProgress, kPrefVal, mHoles);						goodSim = (::fabs(curVolFrac - inVolFraction) <= tolerance);						lastDirection = direction;						direction = sign(inVolFraction - curVolFrac);						mProgress->Progress(1);					}				} catch (BoundingBox::SimulationErr theSimErr) {					if (factor > 0.0001) {						meanR = 0;						for (long i = 1; i <= numXls; i++) {							workingList[i] = inRadiiList[i] + neededRadiusEachXl * factor/2; // reset working radii list							meanR += workingList[i];						}						meanR /= numXls;					} else {						ErrorAlert theAlert("\pReally Bad Simulation", "\pAfter repeated tries, I couldn't make a good simulation.  Please quit, and complain to the programmer.");						delete mProgress;						throw SimulationErr();					}				}				if (factor > 0.002)					factor /= 2.0;				lastDirection = direction;			}		}	if (mPrefs->verbose) {		LStr255 debugStr;		mDebugOutputFile->OpenDataFork(fsRdWrPerm);		debugStr = "\pGot Good Sim.  Target VF/Target MeanR/Env VF/Env MeanR:\t";		debugStr += FltStr(inVolFraction,3);		debugStr += "\p\t";;		debugStr += FltStr(startingMeanRadius,3);		debugStr += "\p\t";;		debugStr += FltStr(curVolFrac,3);		debugStr += "\p\t";;		debugStr += FltStr(meanR,3);		debugStr += "\p\n";;		mDebugOutputFile->SetMarker(0, streamFrom_End);		mDebugOutputFile->putOneLine(debugStr);		mDebugOutputFile->CloseDataFork();	}	}	delete[] workingList;	return meanR;}// ---------------------------------------------------------------------------//		¥ EvaluateCFStats// ---------------------------------------------------------------------------/* This takes the results of all the envelope runs, and measures the mean &	sample standard deviation */voidCReduceApp::EvaluateCFStats(EnvelopeData &Envelopes, Boolean inDoSigmas, short inConfidence){	if (inDoSigmas) {		double tempMean, tempSD;		short numPts = mStats->numLPoints;				Envelopes.GetMeanAndSD(0, OIKind, tempMean, tempSD);		mStats->OIEnvMean = tempMean;		mStats->OIEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, IIKind, tempMean, tempSD);		mStats->IIEnvMean = tempMean;		mStats->IIEnvMean = tempSD;		Envelopes.GetMeanAndSD(0, QSMKind, tempMean, tempSD);		mStats->QSMEnvMean = tempMean;		mStats->QSMEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, CQSMKind, tempMean, tempSD);		mStats->CQSMEnvMean = tempMean;		mStats->CQSMEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, RPSMKind, tempMean, tempSD);		mStats->RPSMEnvMean = tempMean;		mStats->RPSMEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, ARKind, tempMean, tempSD);		mStats->AREnvMean = tempMean;		mStats->AREnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, MinSepKind, tempMean, tempSD);		mStats->MinSepEnvMean = tempMean;		mStats->MinSepEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, MeanSepKind, tempMean, tempSD);		mStats->MeanSepEnvMean = tempMean;		mStats->MeanSepEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, MNNRKind, tempMean, tempSD);		mStats->MeanNNEnvMean = tempMean;		mStats->MeanNNEnvStdDev = tempSD;		Envelopes.GetMeanAndSD(0, MEVKind, tempMean, tempSD);		mStats->MeanEVEnvMean = tempMean;		mStats->MeanEVEnvStdDev = tempSD;				mProgress->SetActionDescriptor("\pMeasuring mean and standard deviation of envelopes...");		mProgress->SetValues(1, numPts, 1);		for (short thisHNum = 1; thisHNum <= numPts; thisHNum++) {	// for each h:			Envelopes.GetMeanAndSD(thisHNum, LKind, tempMean, tempSD);			mStats->LValuesEnvMean[thisHNum] = tempMean;			mStats->LValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, LgdKind, tempMean, tempSD);			mStats->LgdValuesEnvMean[thisHNum] = tempMean;			mStats->LgdValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, PCFKind, tempMean, tempSD);			mStats->PCFValuesEnvMean[thisHNum] = tempMean;			mStats->PCFValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, PCFgdKind, tempMean, tempSD);			mStats->PCFgdValuesEnvMean[thisHNum] = tempMean;			mStats->PCFgdValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, MCFKind, tempMean, tempSD);			mStats->MCFValuesEnvMean[thisHNum] = tempMean;			mStats->MCFValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, MCF3Kind, tempMean, tempSD);			mStats->MCF3ValuesEnvMean[thisHNum] = tempMean;			mStats->MCF3ValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, MCFgdKind, tempMean, tempSD);			mStats->MCFgdValuesEnvMean[thisHNum] = tempMean;			mStats->MCFgdValuesEnvStdDev[thisHNum] = tempSD;			Envelopes.GetMeanAndSD(thisHNum, MCF3gdKind, tempMean, tempSD);			mStats->MCF3gdValuesEnvMean[thisHNum] = tempMean;			mStats->MCF3gdValuesEnvStdDev[thisHNum] = tempSD;			mProgress->Progress(thisHNum);		}	} else {		double tempMin, tempMax;		short numPts = mStats->numLPoints;				Envelopes.GetMinAndMax(0, OIKind, inConfidence, tempMin, tempMax);		mStats->OIEnvMin = tempMin;		mStats->OIEnvMax = tempMax;		Envelopes.GetMinAndMax(0, IIKind, inConfidence, tempMin, tempMax);		mStats->IIEnvMin = tempMin;		mStats->IIEnvMax = tempMax;		Envelopes.GetMinAndMax(0, QSMKind, inConfidence, tempMin, tempMax);		mStats->QSMEnvMin = tempMin;		mStats->QSMEnvMax = tempMax;		Envelopes.GetMinAndMax(0, CQSMKind, inConfidence, tempMin, tempMax);		mStats->CQSMEnvMin = tempMin;		mStats->CQSMEnvMax = tempMax;		Envelopes.GetMinAndMax(0, RPSMKind, inConfidence, tempMin, tempMax);		mStats->RPSMEnvMin = tempMin;		mStats->RPSMEnvMax = tempMax;		Envelopes.GetMinAndMax(0, ARKind, inConfidence, tempMin, tempMax);		mStats->AREnvMin = tempMin;		mStats->AREnvMax = tempMax;		Envelopes.GetMinAndMax(0, MinSepKind, inConfidence, tempMin, tempMax);		mStats->MinSepEnvMin = tempMin;		mStats->MinSepEnvMax = tempMax;		Envelopes.GetMinAndMax(0, MeanSepKind, inConfidence, tempMin, tempMax);		mStats->MeanSepEnvMin = tempMin;		mStats->MeanSepEnvMax = tempMax;		Envelopes.GetMinAndMax(0, MNNRKind, inConfidence, tempMin, tempMax);		mStats->MeanNNEnvMin = tempMin;		mStats->MeanNNEnvMax = tempMax;		Envelopes.GetMinAndMax(0, MEVKind, inConfidence, tempMin, tempMax);		mStats->MeanEVEnvMin = tempMin;		mStats->MeanEVEnvMax = tempMax;				mProgress->SetActionDescriptor("\pMeasuring confidence interval from envelope simulations...");		mProgress->SetValues(1, numPts, 1);		for (short thisHNum = 1; thisHNum <= numPts; thisHNum++) {	// for each h:			Envelopes.GetMinAndMax(thisHNum, LKind, inConfidence, tempMin, tempMax);			mStats->LValuesEnvMin[thisHNum] = tempMin;			mStats->LValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, LgdKind, inConfidence, tempMin, tempMax);			mStats->LgdValuesEnvMin[thisHNum] = tempMin;			mStats->LgdValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, PCFKind, inConfidence, tempMin, tempMax);			mStats->PCFValuesEnvMin[thisHNum] = tempMin;			mStats->PCFValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, PCFgdKind, inConfidence, tempMin, tempMax);			mStats->PCFgdValuesEnvMin[thisHNum] = tempMin;			mStats->PCFgdValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, MCFKind, inConfidence, tempMin, tempMax);			mStats->MCFValuesEnvMin[thisHNum] = tempMin;			mStats->MCFValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, MCF3Kind, inConfidence, tempMin, tempMax);			mStats->MCF3ValuesEnvMin[thisHNum] = tempMin;			mStats->MCF3ValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, MCFgdKind, inConfidence, tempMin, tempMax);			mStats->MCFgdValuesEnvMin[thisHNum] = tempMin;			mStats->MCFgdValuesEnvMax[thisHNum] = tempMax;			Envelopes.GetMinAndMax(thisHNum, MCF3gdKind, inConfidence, tempMin, tempMax);			mStats->MCF3gdValuesEnvMin[thisHNum] = tempMin;			mStats->MCF3gdValuesEnvMax[thisHNum] = tempMax;			mProgress->Progress(thisHNum);		}	}}// ---------------------------------------------------------------------------//		¥ ExtractEnvData// ---------------------------------------------------------------------------voidCReduceApp::ExtractEnvData(Stats *inStats, OneSet *ioEnv){	// extract & store values from our Stats class for this evelope run:	ioEnv->orderingIndex = inStats->orderingIndex;	ioEnv->isolationIndex = inStats->isolationIndex;	ioEnv->quadratStatMean = inStats->quadratStatMean;	ioEnv->circQuadratStatMean = inStats->circQuadratStatMean;	ioEnv->RPStatMean = inStats->RPStatMean;	ioEnv->avramiRatio = inStats->avramiRatio;	ioEnv->minSep = inStats->minSep;	ioEnv->meanSep = inStats->meanSep;	ioEnv->meanNNRad = inStats->meanNNRad;	ioEnv->meanExtV = inStats->meanExtV;		for (short thisHNum=1; thisHNum <= inStats->numLPoints; thisHNum++) {		// extract CF data:		ioEnv->L[thisHNum] = inStats->LValues[thisHNum];		ioEnv->PCF[thisHNum] = inStats->PCF[thisHNum];		ioEnv->MCF[thisHNum] = inStats->MCF[thisHNum];		ioEnv->MCF3[thisHNum] = inStats->MCF3[thisHNum];		ioEnv->Lgd[thisHNum] = inStats->LgdValues[thisHNum];		ioEnv->PCFgd[thisHNum] = inStats->PCFgd[thisHNum];		ioEnv->MCFgd[thisHNum] = inStats->MCFgd[thisHNum];		ioEnv->MCF3gd[thisHNum] = inStats->MCF3gd[thisHNum];	}}#pragma mark ================================ Other Stuff// ---------------------------------------------------------------------------------//		¥ DoInitialStats// ---------------------------------------------------------------------------------void CReduceApp::DoInitialStats(){	mStats->negRadii = mTheXls->GetNegRadii();		if (mHolesFile != nil) {		mStats->BBVolume = FindSwissVolume();		mStats->surfaceArea = -1;	// Surface area is fairly meaningless for the									// swiss cheese case		mStats->surfaceToVolRatio = -1;	} else {		mStats->BBVolume = mBBox->Volume();		mStats->surfaceArea = mBBox->SurfaceArea();		mStats->surfaceToVolRatio = mStats->surfaceArea / mStats->BBVolume;	}	mStats->BBSides = mBBox->GetCount();	mStats->numCrystals = mTheXls->GetCount();	LStr255 debugStr;	if (mPrefs->verbose) {		mDebugOutputFile->OpenDataFork(fsRdWrPerm);		LStr255 debugStr = "\pFinding Intensity\n";		mDebugOutputFile->SetMarker(0, streamFrom_End);		mDebugOutputFile->putOneLine(debugStr);		mDebugOutputFile->CloseDataFork();	}	mStats->intensity = FindIntensity();		Crystal *thisXl;	float maxR = 0;	mTheXls->Lock();	for (short i=1; i <= mTheXls->GetCount(); i++) {		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		maxR = max(maxR, thisXl->r);	}	mTheXls->Unlock();	mStats->numXlsForL = mTheXls->GetCount();	mStats->maxR = maxR;	// needed to compute Volume Frxn		if (mPrefs->verbose) {		mDebugOutputFile->OpenDataFork(fsRdWrPerm);		debugStr = "\pGetting Volume Fraction\n";		mDebugOutputFile->SetMarker(0, streamFrom_End);		mDebugOutputFile->putOneLine(debugStr);		mDebugOutputFile->CloseDataFork();	}	mStats->volFrxn = mBBox->GetVolumeFraction(nil, kPrefVal);	// calculates bulk VF even if holes are present (contrasts with VF calc for making env sims)	mStats->totalPosXls = mStats->numCrystals - mStats->negRadii;	mStats->xMin = mBBox->xMin.x;	mStats->xMax = mBBox->xMax.x;	mStats->yMin = mBBox->yMin.y;	mStats->yMax = mBBox->yMax.y;	mStats->zMin = mBBox->zMin.z;	mStats->zMax = mBBox->zMax.z;		LStr255 theComment = mTheXls->GetIntComment();/* Figure out what produced the input file, based on what's in the comment line.	In order to detect Crystallize 2 files, it looks for the string ", Qd = ", which	is (at this point) unique to these simulations.  A hack, I know.  Otherwise, if	the key words "diffusion", "interface" or "heat flow" appear in the comment line,	the file is taken to be a Crystallize 1 simulation of the appropriate type.  If	none of these things hold true, it is assumed to be real data. */	if ((theComment.Find(", Qd = ", 7) != NULL) || (theComment.Find("diffusion", 9) != NULL))		mStats->fileType = kDiffSimulation;	else if (theComment.Find("interface", 9) != NULL)		mStats->fileType = kIntSimulation;	else if (theComment.Find("heat flow", 9) != NULL)		mStats->fileType = kHFSimulation;	else		mStats->fileType = kReal;}// ---------------------------------------------------------------------------//		¥ ComputeVolumes// ---------------------------------------------------------------------------voidCReduceApp::ComputeVolumes(){	short	index;	short numXls = mTheXls->GetCount();	Crystal	*currXl;		mProgress->SetActionDescriptor("\pComputing volumes...");	mProgress->SetValues(0, numXls, 0);	mTheXls->Lock();	for (index = 1; index <= numXls; index++) {		mProgress->Progress(index);		currXl = (Crystal *) mTheXls->GetItemPtr(index);		currXl->extV = std::fabs((4.0/3.0) * gPI * pow((double)(std::fabs(currXl->r)), (double)(3)));		if (mStats->fileType == kDiffSimulation) {			currXl->actV = currXl->extV;	// for these, the volumes are  adjusted in CorrectForImpingement		} else {			currXl->actV = CorrectedXlVol(index, *currXl);		}	}	mTheXls->Unlock();}// ---------------------------------------------------------------------------//		¥ ComputeRadiusStats// ---------------------------------------------------------------------------voidCReduceApp::ComputeRadiusStats(){	float	realNumPosXls;	float	esdPosDenom;	float	variance;	mProgress->SetActionDescriptor("\pCalculating radius and volume stats...");	mProgress->SetValues(0, mTheXls->GetCount(), 0);	realNumPosXls = mStats->totalPosXls;	esdPosDenom = realNumPosXls * (realNumPosXls - 1);		// compute min, max, & mean for radius & volume	Bounds radiusBounds, extVolBounds, actVolBounds;	Crystal *thisXl;	mTheXls->Lock();	for (short i=1; i <= mTheXls->GetCount(); i++) {		mProgress->Progress(i);		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		radiusBounds.Update(std::fabs(thisXl->r));		extVolBounds.Update(thisXl->extV);		actVolBounds.Update(thisXl->actV);	}	mTheXls->Unlock();	mStats->minR = radiusBounds.min;	mStats->maxR = radiusBounds.max;	mStats->meanR = radiusBounds.sum / mStats->numCrystals;	if (!mStats->newMeanR)		mStats->newMeanR = mStats->meanR;	variance = (mStats->numCrystals * radiusBounds.sumsq - sqr(radiusBounds.sum)) / esdPosDenom;	if (variance > 0)		mStats->esdRadius = sqrt(variance);	else		mStats->esdRadius = 0.0;			mStats->minExtV = extVolBounds.min;	mStats->maxExtV = extVolBounds.max;	mStats->meanExtV = extVolBounds.sum / mStats->numCrystals;	variance = (mStats->numCrystals * extVolBounds.sumsq - sqr(extVolBounds.sum)) / esdPosDenom;	if (variance > 0)		mStats->esdExtVol = sqrt(variance);	else		mStats->esdExtVol = 0.0;			mStats->minActV = actVolBounds.min;	mStats->maxActV = actVolBounds.max;	mStats->meanActV = actVolBounds.sum / mStats->numCrystals;	variance = (mStats->numCrystals * actVolBounds.sumsq - sqr(actVolBounds.sum)) / esdPosDenom;	if (variance > 0)		mStats->esdActVol = sqrt(variance);	else		mStats->esdActVol = 0.0;		mStats->xlVolFraction = actVolBounds.sum / mStats->BBVolume;	mStats->xlDensity = mStats->numCrystals / mStats->BBVolume;}// ---------------------------------------------------------------------------//		¥ ComputeNeighbors// ---------------------------------------------------------------------------voidCReduceApp::ComputeNeighbors(){	Crystal	*currXl, *otherXl;	float	testDistSq, minDistSq, boundDist;	float	testDistEdge, minDistEdge;	short numXls = mTheXls->GetCount();	Point3DFloat	pt1, pt2;	mProgress->SetActionDescriptor("\pCalculating Nearest Neighbors...");	mProgress->SetValues(0, numXls, 0);	mTheXls->Lock();	for (short i = 1; i <= numXls; i++) {		currXl = (Crystal *) mTheXls->GetItemPtr(i);		mProgress->Progress(i);		pt1 = currXl->ctr;		boundDist = mBBox->NearestSideDist(pt1);		if (mHolesFile != nil) {			boundDist = min(boundDist, mHoles->NearestHoleDist(pt1));		}		minDistSq = sqr(boundDist);		minDistEdge = boundDist;		currXl->neighbor = 0; // this will only be changed if a xl is closer then the BBox or a hole		for (short j = 1; j <= numXls; j++) {			otherXl = (Crystal *) mTheXls->GetItemPtr(j);			if ((i != j) && (otherXl->r > 0.0)) {				pt2 = otherXl->ctr;				testDistSq = sqr(pt1.Distance(pt2));				if (testDistSq < minDistSq) {					minDistSq = testDistSq;					currXl->neighbor = j;				}				testDistEdge = pt1.Distance(pt2) - currXl->r - otherXl->r;				if (testDistEdge < minDistEdge)					minDistEdge = testDistEdge;			}		}	// for otherXl 		currXl->ctcDist = sqrt(minDistSq);		currXl->diffV = minDistEdge;		if (minDistEdge < 0)			mStats->maxOverlap = max(-minDistEdge, mStats->maxOverlap);	}	// for currXl 	mTheXls->Unlock();}// ---------------------------------------------------------------------------//		¥ ComputeRandomPt// ---------------------------------------------------------------------------voidCReduceApp::ComputeRandomPt(){	short	i, currRep, currXl;	float	minDist, xlDist, sumCubDist;	float	*means = new float[mPrefs->RPNumReps + 1];	float	thisMean;	Point3DFloat	randPt, pt1, pt2;	Crystal *thisXl;		mProgress->SetActionDescriptor("\pComputing random point test...");	mProgress->SetValues(0, mPrefs->RPNumReps, 0);		mTheXls->Lock();	for (currRep = 1; currRep <= mPrefs->RPNumReps; currRep++) {		sumCubDist = 0.0;		mProgress->Progress(currRep);		for (i = 1; i <= mPrefs->RPNumPlacings; i++) {			Get3DRandPt(&randPt);			thisXl = (Crystal *) mTheXls->GetItemPtr(1);			minDist = thisXl->ctr.Distance(randPt);			for (currXl = 1; currXl <= mTheXls->GetCount(); currXl++) {				thisXl = (Crystal *) mTheXls->GetItemPtr(currXl);				xlDist = thisXl->ctr.Distance(randPt);				if (xlDist < minDist)					minDist = xlDist;			}	// for currXl 			float sideDist = NearestSideHoleDist(&randPt);			if (minDist > sideDist) {				i--;			} else {				sumCubDist += pow(minDist, 3);			}		} // for i		float intensity = mStats->intensity; //(mTheXls->GetCount() / mStats->BBVolume);//		thisMean = sumCubDist / mPrefs->RPNumPlacings;//		thisMean *= intensity;//		thisMean *= (8.0/3.0) * gPI * mPrefs->RPNumPlacings;//		thisMean /= (2.0 * mPrefs->RPNumPlacings);		thisMean = (8.0/3.0) * gPI * intensity * sumCubDist;//		thisMean = (8.0/3.0) * gPI * (mTheXls->GetCount() / mStats->BBVolume) * sumCubDist;		means[currRep] = thisMean;	} // for currRep 	means[0] = mPrefs->RPNumReps;	mTheXls->Unlock();		if (mPrefs->RPNumReps == 1) {		mStats->RPStatMean = means[1];		mStats->RPStatEsd = 0.0;	} else {		mStats->RPStatMean = mStats->RPStatEsd = 0.0;		for (i = 1; i <= mPrefs->RPNumReps; i++) {			mStats->RPStatMean += means[i];			mStats->RPStatEsd += sqr(means[i]);		}		mStats->RPStatMean /= mPrefs->RPNumReps;		mStats->RPStatEsd = sqrt((mStats->RPStatEsd - (mPrefs->RPNumReps *							 sqr(mStats->RPStatMean))) / (mPrefs->RPNumReps - 1));	}	mStats->RPStatMean /= (2.0 * mPrefs->RPNumPlacings);	mStats->RPStatEsd /= (2.0 * mPrefs->RPNumPlacings);	delete[] means;}// ---------------------------------------------------------------------------//		¥ ComputeCSDStats// ---------------------------------------------------------------------------voidCReduceApp::ComputeCSDStats(){	float			moment2, moment3, moment4, calc, mean;	float			p00228, p09772, p01587, p08413;	short			validNum, temp;	RadSortArray	RadiusSortArray;	Crystal			*thisXl;	short			i;	validNum = 0;	mean = 0;	mStats->skewness = 0;	mStats->kurtosis = 0;	mTheXls->Lock();	for (i = 1; i <= mTheXls->GetCount(); i++) {		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {			validNum++;			mean += thisXl->r;			RadiusSortArray.Push(&(thisXl->r));		}	}	if (validNum > 0) {		mean /= validNum;		moment2 = 0;		moment3 = 0;		moment4 = 0;		for (i = 1; i <= mTheXls->GetCount(); i++) {			thisXl = (Crystal *) mTheXls->GetItemPtr(i);			if (thisXl->r > 0) {				calc = (thisXl->r - mean);				moment2 += sqr(calc);				moment3 += pow(calc, 3);				moment4 += pow(calc, 4);			}		}		moment2 /= validNum;		moment3 /= validNum;		moment4 /= validNum;		mStats->skewness = moment3 / exp(log(moment2) * 1.5);		mStats->kurtosis = moment4 / (sqr(moment2)) - 3;			// Do deciles		for (i = 1; i <= 9; i++) {			temp = round(i * (validNum / 10.0));			mStats->deciles[i] = RadiusSortArray[temp];		}		temp = round(0.0228 * validNum);		p00228 = RadiusSortArray[temp];		temp = round(0.9772 * validNum);		p09772 = RadiusSortArray[temp];		temp = round(0.1587 * validNum);		p01587 = RadiusSortArray[temp];		temp = round(0.8413 * validNum);		p08413 = RadiusSortArray[temp];		mStats->myStat1 = 2 * (mStats->deciles[5] - p00228) / (p09772 - p00228) - 1;		mStats->myStat2 = 2 * (p08413 - p01587) / (p09772 - p00228) - 1;	}	mTheXls->Unlock();}// ---------------------------------------------------------------------------//		¥ ComputeStats// ---------------------------------------------------------------------------/* computes max, min, etc. for nearest-neighbor-related stuff */voidCReduceApp::ComputeStats(){//	float	uSum, uSumSq, uConst, u, q;//	short	uNum, currRad, currNNRad;	short	i;//	short numRad;	short numXls = mTheXls->GetCount();//	Boolean	kosher;	Bounds	SepBounds, NNRadBounds;	Crystal	*thisXl, *neighborXl;	mProgress->SetActionDescriptor("\pCalculating ordering stats...");	mProgress->SetValues(0, numXls, 0);	mStats->numSep = 0;	mStats->numNNRad = 0;	mTheXls->Lock();	for (i = 1; i<= numXls; i++) {		mProgress->Progress(i);		thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if ((thisXl->r > 0) && (thisXl->neighbor > 0)) {			(mStats->numSep)++;			SepBounds.Update(thisXl->ctcDist);			neighborXl = (Crystal *) mTheXls->GetItemPtr(thisXl->neighbor);			if (neighborXl->r > 0) {				mStats->numNNRad++;				NNRadBounds.Update(neighborXl->r);			}	// if this crystal's neighbor's radius is greater than 0 		}	// if radius > 0, neighbor > 0 	} // for i	mTheXls->Unlock();	mStats->minSep = SepBounds.min;	mStats->maxSep = SepBounds.max;	mStats->meanSep = SepBounds.sum / mStats->numSep;	mStats->esdSep = sqrt((mStats->numSep * SepBounds.sumsq - sqr(SepBounds.sum)) / (mStats->numNNRad * (mStats->numNNRad - 1)));		mStats->minNNRad = NNRadBounds.min;	mStats->maxNNRad = NNRadBounds.max;	mStats->meanNNRad = NNRadBounds.sum / mStats->numNNRad;	mStats->esdNNRad = sqrt((mStats->numNNRad * NNRadBounds.sumsq - sqr(NNRadBounds.sum)) / (mStats->numNNRad * (mStats->numNNRad - 1)));	// compute ordering index 	mStats->randSep = 0.554 / CubeRoot(mStats->intensity); //numXls / mStats->BBVolume);	mStats->orderingIndex = mStats->meanSep / mStats->randSep;	// compute ordering t-test 	mStats->orderingTTest = ::fabs(mStats->meanSep - mStats->randSep) / (mStats->esdSep / sqrt((double)mStats->numSep));	// compute isolation index and t-test 	mStats->isolationIndex = ((mStats->meanR - mStats->meanNNRad) / mStats->meanR) * 100.0;				// this is the difference between NNRad and Rad as a % of Rad /*	This code doesn't work - it reads past end of the two shuffle arrays into random memory locations.	This failed to crash in versions < 2.6, but crashed reliably on 2.6.  The algorithm is from Reduce 2D	I think, and I can't figure it out well enough to recode it.	numRad = numXls - mStats->negRadii;	uConst = sqrt((double) (mStats->numNNRad / numRad));	uSum = 0;	uSumSq = 0;	uNum = 0;	currNNRad = 1;	currRad = 0;			mProgress->SetActionDescriptor("\pCalculating isolation stats...");	mProgress->SetValues(0, mStats->numNNRad, 0);	short *iNNRad = new short[mTheXls->GetCount()+1];	iNNRad[0] = mTheXls->GetCount();	MakeShuffleArray(iNNRad);		short *iRad = new short[mTheXls->GetCount()+1];	iRad[0] = mTheXls->GetCount();	MakeShuffleArray(iRad);		mTheXls->Lock();	short elementToGet;	Crystal *otherXl;	while (uNum < mStats->numNNRad) {		mProgress->Progress(uNum);			// Skip through index lists until the next valid record is found in each		do{			currRad++;			elementToGet = iRad[currRad];			thisXl = (Crystal *) mTheXls->GetItemPtr(elementToGet);		} while (thisXl->r <= 0);		do {			elementToGet = iNNRad[currNNRad];			thisXl = (Crystal *) mTheXls->GetItemPtr(elementToGet);			if ((thisXl->r <= 0) || (thisXl->neighbor == 0))				kosher = false;			else {				neighborXl = (Crystal *) mTheXls->GetItemPtr(thisXl->neighbor);				if (neighborXl->r <= 0)					kosher = false;				else					kosher = true;			}			if (!kosher)				currNNRad++;		} while (!kosher);		uNum++;		elementToGet = iRad[currNNRad];		thisXl = (Crystal *) mTheXls->GetItemPtr(elementToGet);		elementToGet = iNNRad[currNNRad];		otherXl = (Crystal *) mTheXls->GetItemPtr(elementToGet);		neighborXl = (Crystal *) mTheXls->GetItemPtr(otherXl->neighbor);		u = thisXl->r - neighborXl->r * uConst;		uSum += u;		uSumSq += sqr(u);		currNNRad++;		currRad++;	}	mTheXls->Unlock();	delete[] iNNRad;	delete[] iRad;	q = mStats->numNNRad * uSumSq - sqr(uSum);	mStats->isolationTTest = (mStats->meanNNRad - mStats->meanR) / sqrt(q / (sqr(mStats->numNNRad) * (mStats->numNNRad - 1)));*/}// ---------------------------------------------------------------------------//		¥ MakeShuffleArray// ---------------------------------------------------------------------------// This fills an array of shorts with the values from 1 to numElements in a random order// Array should already be allocated, and the size of the array should be in element 0.voidCReduceApp::MakeShuffleArray(short *inArray){	if (!inArray) return;		short	numElements = inArray[0];	short	*extraList = new short[numElements+1];	short	i, randNum;	for (i=1; i<=numElements; i++)		extraList[i] = i;	extraList[0] = numElements;		for (i=1; i<=numElements; i++) {		randNum = RandomShort(1, extraList[0]);		SignalIf_(randNum < 1 || randNum > numElements);		inArray[i] = extraList[randNum];		for (short j=randNum+1; j<=extraList[0]; j++) {			extraList[j-1] = extraList[j];		}		(extraList[0])--;	}	delete[] extraList;}// ---------------------------------------------------------------------------//		¥ ComputeAvramiTest// ---------------------------------------------------------------------------voidCReduceApp::ComputeAvramiTest(){	short	currXl;		mStats->actualVol = 0.0;	mStats->extendedVol = 0.0;	mTheXls->Lock();	for (currXl = 1; currXl <= mTheXls->GetCount(); currXl++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(currXl);		mStats->actualVol += ::fabs(thisXl->actV);		mStats->extendedVol += ::fabs(thisXl->extV);	}	mTheXls->Unlock();	mStats->actualVol /= mStats->BBVolume;	mStats->extendedVol /= mStats->BBVolume;	mStats->extendedVolRand = log(1.0 / (1.0 - mStats->actualVol));	mStats->avramiRatio = mStats->extendedVol / mStats->extendedVolRand;}// ---------------------------------------------------------------------------//		¥ ComputeQuadrat// ---------------------------------------------------------------------------voidCReduceApp::ComputeQuadrat(){	float			quadSize,	// for cube, this is the length of a side, for a sphere, it's									// the radius.  Either way, it's the size that should enclose 2									// crystals on average					quadSizeSq, avgDensity, diff, expected, cumExpectation;	short			numInQuad, numBins;	short			currRep, i;	short			quadBin[kMaxNumBins];	CFloatArray		results;	float			thisResult;	Boolean			goodData = true;	Point3DFloat	thePt, minPt, maxPt, pt1, pt2;	float			minDim;	Crystal			*thisXl;	for (short circOrQuad = kSphere; circOrQuad <= kSphere; circOrQuad++) {   //Change the first back to "cube" if you want to do the "original" form		if (circOrQuad == kCube)			mProgress->SetActionDescriptor("\pComputing quadrat test...");		else			mProgress->SetActionDescriptor("\pComputing spherical quadrat test...");									// Calculate optimum quadrat size 		if (circOrQuad == kCube) {			quadSize = CubeRoot(mStats->BBVolume * 2.0 / mTheXls->GetCount());			avgDensity = pow(quadSize, 3) * mTheXls->GetCount() / mStats->BBVolume;		} else {			quadSize = CubeRoot((3.0 * mStats->BBVolume * 2.0 / mTheXls->GetCount()) / (4.0 * gPI));			quadSizeSq = sqr(quadSize);			avgDensity = 2.0;		}						// See if either is too big for the sample space... 		minDim = mStats->xMax - mStats->xMin;		if (minDim > (mStats->yMax - mStats->yMin))			minDim = mStats->yMax - mStats->yMin;		if (minDim > (mStats->zMax - mStats->zMin))			minDim = mStats->zMax - mStats->zMin;		if ((circOrQuad == kCube) && (quadSize >= minDim)) {			if (mRunType == kSingle)				ErrorAlert theAlert("\pQuadrat Failed", "\pCan't do a quadrat test on this sample.  Evidently, the sample space is too lopsided to be able to fit the right sized cube.", 0.5);			mStats->quadratStatMean = 0.0;			mStats->quadratStatEsd = 0.0;			throw QuadratFailed();		} else if ((circOrQuad == kSphere) && (quadSize * 2 >= minDim)) {			if (mRunType == kSingle)				ErrorAlert theAlert2("\pQuadrat Failed", "\pCan't do a spherical quadrat test on this sample.  Evidently the sample space is too lopsided to be able to fit the right sized sphere inside.", 0.5);			mStats->circQuadratStatMean = 0.0;			mStats->circQuadratStatEsd = 0.0;			throw QuadratFailed();		}					// Figure out when to start lumping bins together (when expected value < 5, according to Kretz, 1969) 		numBins = 0;		do {			numBins++;			expected = mPrefs->quadratNumPlacings * exp(-avgDensity) * pow(avgDensity, numBins) / factorial(numBins);		} while (expected >= 5.0);		mStats->quadratStatDOF = numBins - 1;   // According to Kretz, DOF == numBins (i.e. categories) - 2, and our count starts with 0 		mProgress->SetValues(0, mPrefs->quadratNumReps, 0);		for (currRep = 1; currRep <= mPrefs->quadratNumReps; currRep++) {			mProgress->Progress(currRep);			for (i = 0; i <= numBins; i++)				quadBin[i] = 0;			for (i = 1; i <= mPrefs->quadratNumPlacings; i++) {				if (circOrQuad == kCube) {					thePt = Get3DRandQuad(quadSize);				} else {					thePt = Get3DRandSphere(quadSize);				}				numInQuad = 0;				mTheXls->Lock();				for (long thisXlNum = 1; thisXlNum <= mTheXls->GetCount(); thisXlNum++) {					thisXl = (Crystal *) mTheXls->GetItemPtr(thisXlNum);					if (circOrQuad == kCube) {						if ((thisXl->ctr.x > thePt.x) &&							(thisXl->ctr.x < thePt.x + quadSize) &&							(thisXl->ctr.y > thePt.y) &&							(thisXl->ctr.y < thePt.y + quadSize) &&							(thisXl->ctr.z > thePt.z) &&							(thisXl->ctr.z < thePt.z + quadSize))										numInQuad++;					} else {	// else kSphere						if (sqr(thePt.Distance(thisXl->ctr)) <= quadSizeSq)							numInQuad++;					}				}				mTheXls->Unlock();				if (numInQuad > numBins)					numInQuad = numBins;				quadBin[numInQuad]++;			}   // for i			thisResult = 0;			cumExpectation = 0;			for (i = 0; i <= numBins - 1; i++) {				expected = mPrefs->quadratNumPlacings * exp(-avgDensity) * pow(avgDensity, i) / factorial(i);				cumExpectation = cumExpectation + expected;				diff = quadBin[i] - expected;				thisResult += diff * diff / expected;			}			diff = quadBin[numBins] - (mPrefs->quadratNumPlacings - cumExpectation);			thisResult += sqr(diff) / (mPrefs->quadratNumPlacings - cumExpectation);			results.Push(&thisResult);		}   // for currRep 		if (circOrQuad == kCube) {			if (mPrefs->quadratNumReps == 1) {				mStats->quadratStatMean = results[1];				mStats->quadratStatEsd = 0.0;			} else {				mStats->quadratStatMean = 0.0;				mStats->quadratStatEsd = 0.0;				for (i = 1; i <= mPrefs->quadratNumReps; i++) {					mStats->quadratStatMean +=  results[i];					mStats->quadratStatEsd += sqr(results[i]);				}				mStats->quadratStatMean /=  mPrefs->quadratNumReps;				mStats->quadratStatEsd = sqrt((mStats->quadratStatEsd - (mPrefs->quadratNumReps * sqr(mStats->quadratStatMean))) / (mPrefs->quadratNumReps - 1));			}		} else {			if (mPrefs->quadratNumReps == 1) {				mStats->circQuadratStatMean = results[1];				mStats->circQuadratStatEsd = 0.0;			} else {				mStats->circQuadratStatMean = 0.0;				mStats->circQuadratStatEsd = 0.0;				for (i = 1; i <= mPrefs->quadratNumReps; i++) {					mStats->circQuadratStatMean += results[i];					mStats->circQuadratStatEsd += sqr(results[i]);				}				mStats->circQuadratStatMean /= mPrefs->quadratNumReps;				mStats->circQuadratStatEsd = sqrt((mStats->circQuadratStatEsd - (mPrefs->quadratNumReps * sqr(mStats->circQuadratStatMean))) / (mPrefs->quadratNumReps - 1));			}		}	}}// ---------------------------------------------------------------------------//		¥ CorrectedXlVol// ---------------------------------------------------------------------------doubleCReduceApp::CorrectedXlVol(short curIndex, Crystal currXl){	float	vol;		// volume of the crystal - total volume minus sectors							// belonging to other xls 	float	dist;		// dist between 2 sphere ctrs 	float	sumRad;		// sum of two sphere radii 	float	cosAlpha;	// cos(angle between line connecting 2 xl ctrs &							// the bdry of their intersxn) 	float	h;			// distance between dividing plane and the edge of							// the sphere whose volume we want 	float	segmentVol;	// volume of the part of the sphere shaved							// off by the dividing plane 	Crystal	*thisXl;	short numXls = mTheXls->GetCount();		vol = ((4.0/3.0) * gPI * pow((double)(currXl.r), (double)(3)));	mTheXls->Lock();	for (short i = 1; (i <= numXls && (vol > 0)); i++) {		if (i != curIndex) {			thisXl = (Crystal *) mTheXls->GetItemPtr(i);			dist = thisXl->ctr.Distance(currXl.ctr);			sumRad = thisXl->r + currXl.r;			if (sumRad > dist) {	// radii longer than dist between spheres, so spheres intersect 				if ((dist + currXl.r) < thisXl->r) {	// other sphere engulfs this one 					mStats->numEngulfed++;					vol = 0;				} else if ((dist + thisXl->r) > currXl.r) {	// make sure other xl isn't engulfed 					cosAlpha = sqr(dist) + sqr(currXl.r) - sqr(thisXl->r);	// law of cosines 					cosAlpha /= (2.0 * dist * currXl.r);					// law of cosines, ctd. 					if (cosAlpha > 0) {						h = currXl.r * (1.0 - cosAlpha);						segmentVol = gPI * sqr(h) * (3.0 * currXl.r - h) / 3.0;	// segment vol, from CRC handbook 						vol -= segmentVol;					} else if (cosAlpha == 0) {						vol -= 2.0 * gPI * pow((double)(currXl.r), (double)(3)) / 3.0;					} else {						cosAlpha = cos(gPI - acos(cosAlpha));						h = currXl.r * (1.0 - cosAlpha);						vol = gPI * sqr(h) * (3.0 * currXl.r - h) / 3.0;	// segment vol, from CRC handbook 					}				}	// engulfing checks 			}	// if sumRad > dist 		}	// if i != currXl 	}	// for i 	if (vol < 0)		vol = 0;	mTheXls->Unlock();	return vol;}// ---------------------------------------------------------------------------//		¥ FindSwissVolume// ---------------------------------------------------------------------------/*	Can't just subtract sum of volumes of holes, because there will be overlap.	Ironing that issue out would be difficult, and very CPU-time-consuming for	large numbers of hole crystals, so we'll just Monte Carlo it.  */floatCReduceApp::FindSwissVolume(){	Point3DFloat minPoint, maxPoint, tryPoint;	long inPoints = 0;	static double vol;		minPoint.x = mBBox->xMin.x;	minPoint.y = mBBox->yMin.y;	minPoint.z = mBBox->zMin.z;	maxPoint.x = mBBox->xMax.x;	maxPoint.y = mBBox->yMax.y;	maxPoint.z = mBBox->zMax.z;	// these two points define opposite corners of a rectangular								// prism that just fits around the Bounding Box	srand(::TickCount());	long MCTries = mPrefs->MCReps;	for (long i = 1; i <= MCTries; i++) {		tryPoint = RandPtNearBox(minPoint, maxPoint);		if (InBoxNotHole(tryPoint))			inPoints++;	}	vol = (maxPoint.x - minPoint.x) * (maxPoint.y - minPoint.y) * (maxPoint.z - minPoint.z);	vol *= ((double) inPoints) / ((double) MCTries);	// multiply volume by fraction																	// of tries that were "hits"	return vol;}// ---------------------------------------------------------------------------//		¥ RandPtNearBox// ---------------------------------------------------------------------------/*	Returns a 3D Point that is within the rectangular prism defined by inMinPoint	and inMaxPoint.  */Point3DFloat &CReduceApp::RandPtNearBox(Point3DFloat &inMinPoint, Point3DFloat &inMaxPoint){	static Point3DFloat outPt;	outPt.x = RandomDbl(inMinPoint.x, inMaxPoint.x);	outPt.y = RandomDbl(inMinPoint.y, inMaxPoint.y);	outPt.z = RandomDbl(inMinPoint.z, inMaxPoint.z);	return outPt;}// ---------------------------------------------------------------------------//		¥ InBoxNotHole// ---------------------------------------------------------------------------BooleanCReduceApp::InBoxNotHole(Point3DFloat &inPoint){	return ((mBBox->PointInBox(inPoint)) && !(mHoles->PointInHole(inPoint)));}// ---------------------------------------------------------------------------//		¥ FindInsertIndex// ---------------------------------------------------------------------------// returns index of array corr. to first value greater than inValshortCReduceApp::FindInsertIndex(DistArrayElem *inArray, short inNumElems, float &inVal){	short cur, top, bot, lastCur;		cur = 0;	top = inNumElems-1;	bot = 0;	if (inNumElems == 0)		return 0;	if (inVal < inArray[0].dist)		return 0;	if (inVal > inArray[inNumElems-1].dist)		return inNumElems;		do {		lastCur = cur;		cur = (top + bot) / 2;		if (inArray[cur].dist > inVal) {			top = cur;		} else if (inArray[cur].dist == inVal) {			while (cur < inNumElems-1 && inArray[cur+1].dist == inArray[cur].dist)				cur++;			return cur + 1;		} else {			bot = cur;		}	} while (cur != lastCur);	while (cur < inNumElems-1 && inArray[cur+1].dist == inArray[cur].dist)		cur++;	return cur + 1;}// ---------------------------------------------------------------------------//		¥ Get3DRandPt// ---------------------------------------------------------------------------/*	Returns a 3D Point that is within the Bounding Box, and not in a hole. */voidCReduceApp::Get3DRandPt(Point3DFloat *outPt){	if (mHoles != nil) {		do {			mBBox->RandPtInPrimitive(*outPt);		} while (mHoles->PointInHole(*outPt));	} else {		mBBox->RandPtInPrimitive(*outPt);	}}// ---------------------------------------------------------------------------//		¥ NearestSideHoleDist// ---------------------------------------------------------------------------doubleCReduceApp::NearestSideHoleDist(Point3DFloat *inPt){	if (mHoles != nil) {		return min(mBBox->NearestSideDist(*inPt), mHoles->NearestHoleDist(*inPt));	} else {		return mBBox->NearestSideDist(*inPt);	}}// ---------------------------------------------------------------------------//		¥ Get3DRandQuad// ---------------------------------------------------------------------------Point3DFloat &CReduceApp::Get3DRandQuad(float quadSize){	Point3DFloat 		savePt;	static Point3DFloat	outPt,		// this represents the low-coordinate corner of the quadrat cube						maxPt, minPt;	Boolean				valid;		if (minPt.x != mStats->xMin  || maxPt.x != mStats->xMax - quadSize) {	// haven't been here yet		minPt.x = mStats->xMin;		minPt.y = mStats->yMin;		minPt.z = mStats->zMin;		maxPt.x = mStats->xMax - quadSize;		maxPt.y = mStats->yMax - quadSize;		maxPt.z = mStats->zMax - quadSize;	}	do {		outPt = RandPtNearBox(minPt, maxPt);		savePt = outPt;		valid = mBBox->PointInBox(outPt);	// x, y, z		if (valid) {			outPt.x += quadSize;			valid = mBBox->PointInBox(outPt);	// x+qS, y, z		}		if (valid) {			outPt.y += quadSize;			valid = mBBox->PointInBox(outPt);	// x+qS, y+qS, z		}		if (valid) {			outPt.z += quadSize;			valid = mBBox->PointInBox(outPt);	// x+qS, y+qS, z+qS		}		if (valid) {			outPt.y = savePt.y;			valid = mBBox->PointInBox(outPt);	// x+qS, y, z+qS		}		if (valid) {			outPt.x = savePt.x;			valid = mBBox->PointInBox(outPt);	// x, y, z+qS		}		if (valid) {			outPt.y += quadSize;			valid = mBBox->PointInBox(outPt);	// x, y+qS, z+qS		}		if (valid) {			outPt.z = savePt.z;			valid = mBBox->PointInBox(outPt);	// x, y+qS, z		}	} while (!valid);	return outPt;}// ---------------------------------------------------------------------------//		¥ Get3DRandSphere// ---------------------------------------------------------------------------Point3DFloat &CReduceApp::Get3DRandSphere(float quadSize){	static Point3DFloat	outPt,		// this represents the center of the quadrat sphere						maxPt, minPt;	if (minPt.x != mStats->xMin  || maxPt.x != mStats->xMax - quadSize) {	// haven't been here yet		minPt.x = mStats->xMin;		minPt.y = mStats->yMin;		minPt.z = mStats->zMin;		maxPt.x = mStats->xMax;		maxPt.y = mStats->yMax;		maxPt.z = mStats->zMax;	}	if (mHoles) {		do {			outPt = RandPtNearBox(minPt, maxPt);		} while (!(mBBox->PointInBox(outPt))				 && (mBBox->NearestSideDist(outPt) < quadSize)				 && (mHoles->NearestHoleDist(outPt) < quadSize));	} else {		do {			outPt = RandPtNearBox(minPt, maxPt);		} while (!(mBBox->PointInBox(outPt)) && (mBBox->NearestSideDist(outPt) < quadSize));	}	return outPt;}// ---------------------------------------------------------------------------//		¥ GetPercentSphereInsideBoxNotHoles// ---------------------------------------------------------------------------/* Although there are probably more elegant ways to do this, we'll use a Monte Carlo	to minimize programming time.  We get even sampling over a sphere by randomizing	an azimuth in the x-y plane, and then randomizing a normalized inclination. */floatCReduceApp::GetPercentSphereInsideBoxNotHoles(Point3DFloat inCtr, float inRadius, short inNumSpherePts){	long	numInBox = 0;	double azimuth;	double radiusAtZ;	Point3DFloat thisPt;		for (long i = 1; i <= inNumSpherePts; i++) {		thisPt.z = inRadius * cos(RandomDbl(0, gPI));		radiusAtZ = sqrt(sqr(inRadius) - sqr(thisPt.z));		azimuth = RandomDbl(0, 2*gPI);		thisPt.x = radiusAtZ * cos(azimuth);		thisPt.y = radiusAtZ * sin(azimuth);		thisPt += inCtr;		if (InBoxNotHole(thisPt))			numInBox++;	}	return ((float) numInBox / (float) inNumSpherePts);}