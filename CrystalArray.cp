// =================================================================================//	CrystalArray.cp 						// =================================================================================#include "CrystalArray.h"#include <stdio.h>#include <string.h>#include "ErrorAlert.h"#include "CReduceApp.h"#include "CReducePrefs.h"#include "SideSet.h"#include<LString.h>extern long double gPI;// ---------------------------------------------------------------------------//		¥ CrystalArray// ---------------------------------------------------------------------------//	Constructor for an empty CrystalArrayCrystalArray::CrystalArray(	long		inNumExpected,	PP::LComparator	*inComparator,	Boolean		inKeepSorted)		: PP::LArray(sizeof(Crystal), inComparator, inKeepSorted){	mProgress = (LProgressDialog *)		PP::LWindow::CreateWindow( kProgressDialogID, PP::LCommander::GetTopCommander() );	ThrowIfNil_( mProgress );		CReduceApp *theApp = (CReduceApp *) PP::LCommander::GetTopCommander();	mPrefs = theApp->GetPrefs();	mNegRadii = 0;	mNuclProb = nil;	mXListSizeAllocated = inNumExpected;	if (inNumExpected) {		mXList = new XYZListElement[mXListSizeAllocated+1];	} else {		mXList = new XYZListElement[1];		mXListSizeAllocated = 1;	}	mListSize = 0;}// ---------------------------------------------------------------------------//		¥ CrystalArray(CrystalArray &inXls)// ---------------------------------------------------------------------------CrystalArray::CrystalArray(CrystalArray &inXls)	:LArray(inXls){	mProgress = (LProgressDialog *)		PP::LWindow::CreateWindow( kProgressDialogID, PP::LCommander::GetTopCommander() );	ThrowIfNil_( mProgress );	CReduceApp *theApp = (CReduceApp *) PP::LCommander::GetTopCommander();	mPrefs = theApp->GetPrefs();	mNuclProb = nil;	mXList = nil;	mXListSizeAllocated = 0;	InitXlArray(&inXls);}// ---------------------------------------------------------------------------//		¥ CrystalArray(CrystalArray *inXls)// ---------------------------------------------------------------------------CrystalArray::CrystalArray(CrystalArray *inXls)	:LArray(*inXls){	mProgress = (LProgressDialog *)		PP::LWindow::CreateWindow( kProgressDialogID, PP::LCommander::GetTopCommander() );	ThrowIfNil_( mProgress );	CReduceApp *theApp = (CReduceApp *) PP::LCommander::GetTopCommander();	mPrefs = theApp->GetPrefs();	mNuclProb = nil;	mXList = nil;	mXListSizeAllocated = 0;	InitXlArray(inXls);}// ---------------------------------------------------------------------------//		¥ InitXlArray(CrystalArray &inXls)// ---------------------------------------------------------------------------voidCrystalArray::InitXlArray(CrystalArray *inXls){	mFile = inXls->mFile;	mIntComment = inXls->mIntComment;	mNumCrystals = inXls->mNumCrystals;	mTotalVolume = inXls->mTotalVolume;	mHasBounds = inXls->mHasBounds;	mNegRadii = inXls->mNegRadii;	mLower = inXls->LowerBound();	mUpper = inXls->UpperBound();	if (inXls->mNuclProb)		mNuclProb = new nuclProbType(*(inXls->mNuclProb));	if (mXListSizeAllocated < inXls->mXListSizeAllocated) {		if (mXList) delete[] mXList;		mXList = new XYZListElement[inXls->mXListSizeAllocated];		mXListSizeAllocated = inXls->mXListSizeAllocated;	}	mListSize = 0;}// ---------------------------------------------------------------------------//		¥ Copy(CrystalArray *inXls)// ---------------------------------------------------------------------------voidCrystalArray::Copy(CrystalArray *inXls){	Clear();	mFile = inXls->mFile;	mIntComment = inXls->mIntComment;	mNumCrystals = inXls->mNumCrystals;	mTotalVolume = inXls->mTotalVolume;	mHasBounds = inXls->mHasBounds;	mNegRadii = inXls->mNegRadii;	mLower = inXls->LowerBound();	mUpper = inXls->UpperBound();	if (mNuclProb) {		delete mNuclProb;		mNuclProb = nil;	}	if (inXls->mNuclProb)		mNuclProb = new nuclProbType(*(inXls->mNuclProb));	if (mXListSizeAllocated < inXls->mXListSizeAllocated) {		if (mXList) delete[] mXList;		mXList = new XYZListElement[inXls->mXListSizeAllocated];		mXListSizeAllocated = inXls->mXListSizeAllocated;	}	mListSize = 0;	inXls->Lock();	for (long i = 1; i <= inXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) inXls->GetItemPtr(i);		PushXl(*thisXl);	}	inXls->Unlock();	}// ---------------------------------------------------------------------------//		¥ ~CrystalArray// ---------------------------------------------------------------------------//	Destructor for CrystalArrayCrystalArray::~CrystalArray(){	if (mProgress != nil) {		delete mProgress;		mProgress = nil;	}	if (mNuclProb != nil) {		delete mNuclProb;		mNuclProb = nil;	}	if (mXList) {		delete[] mXList;		mXList = nil;	}	Clear();}// ---------------------------------------------------------------------------------//		¥ PopXl//// ---------------------------------------------------------------------------------CrystalCrystalArray::PopXl(){	static Boolean XlFound;	static Crystal outXl;		XlFound = FetchItemAt(GetCount(), &outXl);	if (XlFound) {		RemoveFromList(mXList, outXl.ctr.x, GetCount());		mListSize--;		RemoveItemsAt(1, GetCount());	} else {		throw ArrayIOErr();	}		return outXl;}// ---------------------------------------------------------------------------------//		¥ RemoveItemWithLists// ---------------------------------------------------------------------------------voidCrystalArray::RemoveItemWithLists(	PP::ArrayIndexT		inAtIndex){	Boolean rebuild = false;	if (mListSize > 0) {		static Boolean XlFound;		static Crystal outXl;		XlFound = FetchItemAt(inAtIndex, &outXl);		if (XlFound) {			if (!RemoveFromList(mXList, outXl.ctr.x, inAtIndex))				rebuild = true;			mListSize--;		} else {			throw ArrayIOErr();		}	}	PP::LArray::RemoveItemsAt(1, inAtIndex);	if (rebuild)		RebuildLists();}// ---------------------------------------------------------------------------------//		¥ PushXl// ---------------------------------------------------------------------------------voidCrystalArray::PushXl(Crystal &inXl){	InsertItemsAt(1, index_Last, &inXl);	if (mListSize == mXListSizeAllocated) {		XYZListElement *holderX = mXList;		mXListSizeAllocated += 50;		mXList = new XYZListElement[mXListSizeAllocated+1];		for (long i = 0; i <= mXListSizeAllocated - 50; i++) {			mXList[i] = holderX[i];		}	}	mXList[mListSize].index = GetCount();	mXList[mListSize].location = inXl.ctr.x;	mListSize++;}// ---------------------------------------------------------------------------------//		¥ Clear// ---------------------------------------------------------------------------------voidCrystalArray::Clear(){	RemoveItemsAt(GetCount(), 1);	mListSize = 0;	mNumCrystals = 0;	mTotalVolume = 0;	mNegRadii = 0;}// ---------------------------------------------------------------------------------//		¥ CrystalIntersects// ---------------------------------------------------------------------------------/*	The Interface-control placement criterion is:		(a)  The later-nucleated crystal cannot have nucleated within the volume of				the earlier-nucleated one as that one existed at the time of the nucleation				of the later-nucleated one.		Assuming interface-controlled growth, all crystals grow as r=kt, so				radius increments are proportional to time.  */// this is the easy-to-read but slower version:/*			double rMaxAtTauOne = bigXl->r - smallXl->r;	// the radius of the largest Xl at Tau = 1			double tauNucl = (rMaxAtTauOne - (thisXl.r - smallXl->r)) / rMaxAtTauOne;	// the tau at which cur Xl would've nucleated			double otherRadAtNucl = otherXl->r - smallXl->r - (rMaxAtTauOne * (1 - tauNucl));	// the radius the other crystal had when cur Xl nucleated			double overlapAtNucl = otherRadAtNucl + 0 - otherXl->ctr.Distance(thisXl.ctr);			if (overlapAtNucl > 0)				return true;*/BooleanCrystalArray::CrystalIntersects(Crystal &thisXl, Boolean inMatchingCTDataSet, float inVolFraction, float betafactorfactor){	float separation;	if (GetCount() == 0)		return false;	Lock();	Crystal *otherXl;	if (mPrefs->observabilityFilter && inMatchingCTDataSet) {		for (short i = 1; i <= GetCount(); i++) {			otherXl = (Crystal *) GetItemPtr(i);			separation = thisXl.ctr.Distance(otherXl->ctr);			float minOKDist;			if (mPrefs->makeDCEnv) {				float betaFactor = pow(inVolFraction, -1.0/3.0);				minOKDist = betaFactor * std::fabs(otherXl->r - thisXl.r) * betafactorfactor;				if (minOKDist >= separation) {					Unlock();					return 3;				}			} else {				minOKDist = std::fabs(otherXl->r - thisXl.r);				if (separation < (thisXl.r + otherXl->r))	{	// if they overlap at all, then do placement checks:					// IC Criterion:					if (minOKDist >= separation) {						Unlock();						return 3;					}					// is this pair observable?					Crystal *smaller, *larger;					if (thisXl.r < otherXl->r) {						smaller = &thisXl;						larger = otherXl;					} else {						smaller = otherXl;						larger = &thisXl;					}					float IntPlaneDist = (sqr(larger->r) - sqr(smaller->r) + sqr(separation)) / (2 * separation);					if (separation < mPrefs->crit1Factor * IntPlaneDist) {	// criterion (1)						Unlock();						return 1;					} else {						float totalLength = separation + larger->r + smaller->r;						if (totalLength < mPrefs->crit2Factor * smaller->r) {	// criterion (2)							Unlock();							return 2;						}					}				}			}		}	} else {		for (short i = 1; i <= GetCount(); i++) {			otherXl = (Crystal *) GetItemPtr(i);			separation = thisXl.ctr.Distance(otherXl->ctr);			// this is the less obvious, but faster(?) version:			float minOKDist;			if (mPrefs->makeDCEnv) {				float betaFactor = pow(inVolFraction, -1.0/3.0);				minOKDist = betaFactor * std::fabs(otherXl->r - thisXl.r) * betafactorfactor;			} else {				minOKDist = std::fabs(otherXl->r - thisXl.r);			}			if (minOKDist >= separation) {				Unlock();				return 3;			}		}	}	Unlock();	return false;}// ---------------------------------------------------------------------------------//		¥ GetMeanRadius// ---------------------------------------------------------------------------------floatCrystalArray::GetMeanRadius(){	float rsum = 0;	Crystal *thisXl;	Lock();	for (short i=1; i <= GetCount() - 1; i++) {		thisXl = (Crystal *) GetItemPtr(i);		rsum += thisXl->r;	}	Unlock();		return rsum / GetCount();}// ---------------------------------------------------------------------------------//		¥ ChangeRadii// ---------------------------------------------------------------------------------voidCrystalArray::ChangeRadii(double *outRadiiList, float inDelta){	Crystal *thisXl;	Lock();	for (long i=1; i <= GetCount(); i++) {		thisXl = (Crystal *) GetItemPtr(i);		outRadiiList[i] = thisXl->r + inDelta;	}	Unlock();}// ---------------------------------------------------------------------------------//		¥ AdjustLocations// ---------------------------------------------------------------------------------BooleanCrystalArray::AdjustLocations(){	Crystal *thisXl;	Lock();	Boolean neededAdjustment = false;	for (short i=1; i <= GetCount() - 1; i++) {		thisXl = (Crystal *) GetItemPtr(i);		// test for intersections		Crystal *otherXl;		for (short j=i+1; j <= GetCount(); j++) {			otherXl = (Crystal *) GetItemPtr(j);				// This is the Interface-Controlled placing criterion:/*// this is the easy-to-read but slower version:			double rMaxAtTauOne = bigXl->r - smallXl->r;	// the radius of the largest Xl at Tau = 1			double tauNucl = (rMaxAtTauOne - (thisXl.r - smallXl->r)) / rMaxAtTauOne;	// the tau at which cur Xl would've nucleated			double otherRadAtNucl = otherXl->r - smallXl->r - (rMaxAtTauOne * (1 - tauNucl));	// the radius the other crystal had when cur Xl nucleated			double overlapAtNucl = otherRadAtNucl + 0 - otherXl->ctr.Distance(thisXl.ctr);			if (overlapAtNucl > 0)				return true;*/// this is the less obvious, but faster(?) version:			if ((otherXl->r - thisXl->r - otherXl->ctr.Distance(thisXl->ctr)) > 0) {				neededAdjustment = true;				// too much overlap, so move the later-nucleated (smaller) one away				Crystal *moveXl;				Crystal *holdXl;				if (thisXl->r > otherXl->r) {					moveXl = otherXl;					holdXl = thisXl;				} else {					holdXl = otherXl;					moveXl = thisXl;				}				Point3DFloat originalLoc = moveXl->ctr;				// try moving it				Point3DFloat newCtr = ((moveXl->ctr - holdXl->ctr).Unit()) * (holdXl->r - moveXl->r) + holdXl->ctr;				moveXl->ctr = newCtr;								// see if it now has too much overlap with any others				Crystal *thirdXl;				CrystalArray *overlapXls = nil;				float overlap = 0;				for (short k=1; k <= GetCount(); k++) {					thirdXl = (Crystal *) GetItemPtr(k);					if ((moveXl->r - thirdXl->r - moveXl->ctr.Distance(thirdXl->ctr)) > 0) {						overlap += moveXl->r - thirdXl->r - moveXl->ctr.Distance(thirdXl->ctr);						if (overlapXls == nil) {							overlapXls = new CrystalArray(GetCount());						}						overlapXls->PushXl(*thirdXl);					}				}								if (overlap > 0) {	// if so, then negotiate the best location					Point3DFloat direction = (moveXl->ctr - holdXl->ctr).Unit();					float magnitude = (moveXl->ctr - holdXl->ctr).Magnitude();					float factor = 1.0;					Boolean done = false;					float lastOverlap = overlap;					float thisOverlap = 0;										do {						factor -= 0.1;						moveXl->ctr = holdXl->ctr + direction * magnitude * factor;						for (short l=1; l <= overlapXls->GetCount(); l++) {							thirdXl = (Crystal *) overlapXls->GetItemPtr(l);							if ((moveXl->r - thirdXl->r - moveXl->ctr.Distance(thirdXl->ctr)) > 0) {								thisOverlap += moveXl->r - thirdXl->r - moveXl->ctr.Distance(thirdXl->ctr);							}						}												if (thisOverlap > lastOverlap) {							done = true;							factor += 0.1;							moveXl->ctr = holdXl->ctr + direction * magnitude * factor;						}					} while (!done);					delete overlapXls;				} else {					// do nothing - we've got the right location.				}			}		}	}	Unlock();	return neededAdjustment;}// ---------------------------------------------------------------------------------//		¥ FindCrystalAt// ---------------------------------------------------------------------------------BooleanCrystalArray::FindCrystalAt(Point3DFloat inPt, Crystal *thisXl){	Crystal *curXl;	Boolean found = false;	Lock();	for (short i=1; (i <= GetCount()) && (!found); i++) {		curXl = (Crystal *) GetItemPtr(i);		if (curXl->ctr == inPt) {			found = true;			*thisXl = *curXl;		}	}	Unlock();	return found;}// ---------------------------------------------------------------------------------//		¥ Average// ---------------------------------------------------------------------------------Point3DFloat &CrystalArray::Average(){	Crystal *thisXl;	static Point3DFloat outPt;	Lock();	for (short i=1; i <= GetCount(); i++) {		thisXl = (Crystal *) GetItemPtr(i);		outPt += thisXl->ctr;	}	outPt /= GetCount();	Unlock();	return outPt;}// ---------------------------------------------------------------------------------//		¥ AverageRad// ---------------------------------------------------------------------------------doubleCrystalArray::AverageRad(){	Crystal *thisXl;	double meanR = 0;	Lock();	for (short i=1; i <= GetCount(); i++) {		thisXl = (Crystal *) GetItemPtr(i);		meanR += thisXl->r;	}	meanR /= GetCount();	Unlock();	return meanR;}// ---------------------------------------------------------------------------//		¥ ReadMergeHeader// ---------------------------------------------------------------------------voidCrystalArray::ReadMergeHeader(){	char	tempStr[kMaxGetPutLineSize];	char	tempStr2[kMaxGetPutLineSize];	char	*strLoc;				// read header	mFile->getOneLine(tempStr);		/* Throw away Integrate header line */	mFile->getOneLine(tempStr);		/* Comment line */	mFile->peekLine(tempStr2);		/* Number of crystals line */	if (tempStr2[0] != 'N') {		mFile->getOneLine(tempStr2);		/* Comment line */		// squish tempStr		PP::LStr255 ts1 = tempStr;		PP::LStr255 ts2 = tempStr2;		UInt8 pos;		while ((pos = ts1.Find(" ,", 2)) != NULL) {			ts1.Remove(pos, 1);		}		while ((pos = ts1.Find(", ", 2)) != NULL) {			ts1.Remove(pos+1, 1);		}		while ((pos = ts1.Find("  ", 2)) != NULL) {			ts1.Remove(pos, 1);		}		while ((pos = ts2.Find(" ,", 2)) != NULL) {			ts1.Remove(pos, 1);		}		while ((pos = ts2.Find(", ", 2)) != NULL) {			ts1.Remove(pos+1, 1);		}		while ((pos = ts2.Find("  ", 2)) != NULL) {			ts1.Remove(pos, 1);		}		mIntComment = ts1 + ts2;	} else {		mIntComment.Assign(tempStr, PP::LString::CStringLength(tempStr));	}/* Figure out what produced the input file, based on what's in the comment line.	In order to detect Crystallize 2 files, it looks for the string ", Qd = ", which	is (at this point) unique to these simulations.  A hack, I know.  Otherwise, if	the key words "diffusion", "interface" or "heat flow" appear in the comment line,	the file is taken to be a Crystallize 1 simulation of the appropriate type.  If	none of these things hold true, it is assumed to be real data. */	if ((mIntComment.Find("Qd", 2) != NULL) || (mIntComment.Find("diffusion", 9) != NULL))		mFileType = kDiffSimulation;	else if (mIntComment.Find("interface", 9) != NULL)		mFileType = kIntSimulation;	else if (mIntComment.Find("heat flow", 9) != NULL)		mFileType = kHFSimulation;	else		mFileType = kReal;// parse comment for probability data	// is there a pdf?	short paramLoc = mIntComment.Find("\ppdf");	if (paramLoc && mPrefs->matchPDF) {		mNuclProb = new nuclProbType;		while (!ISNUMCHAR((char)mIntComment[paramLoc])) {			paramLoc++;		}		short nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->x.halfSines = (SInt32) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->x.start = (SInt32) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->x.minProb = (double) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->y.halfSines = (SInt32) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->y.start = (SInt32) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->y.minProb = (double) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->z.halfSines = (SInt32) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		nextComma = mIntComment.Find(',', paramLoc);		mNuclProb->z.start = (SInt32) (mIntComment(paramLoc, nextComma-paramLoc));		paramLoc = nextComma+1;		mNuclProb->z.minProb = (double) (mIntComment(paramLoc, mIntComment.Length()));	} else {		mNuclProb = nil;	}	mFile->getOneLine(tempStr);		/* Number of crystals line */	if (tempStr[0] != 'N') {		mFile->getOneLine(tempStr);		/* Number of crystals line */		}	if ((strLoc = strchr(tempStr, '\t')) == NULL)	// no tab present		sscanf(tempStr, "%*25c%hi", &mNumCrystals);	else		sscanf(strLoc, "%hi", &mNumCrystals);	mFile->getOneLine(tempStr);		/* Total volume line */	if ((strLoc = strchr(tempStr, '\t')) == NULL)	// no tab present		sscanf(tempStr, "%*25c%f", &mTotalVolume);	else		sscanf(strLoc, "%f", &mTotalVolume);	mFile->peekLine(tempStr);		/* Bounds line */	if (strstr(tempStr, "Bound") != NULL) {		// "Bound" present		mFile->getOneLine(tempStr);		/* Bounds line */		sscanf(tempStr, "Bounds:\t%f%f%f%f%f%f", &(mLower.x), &(mLower.y), &(mLower.z),												 &(mUpper.x), &(mUpper.y), &(mUpper.z));		mHasBounds = true;	} else if (isSim(mFileType)) {	// then it's a simulation with volume=mTotalVolume		mHasBounds = true;		mLower.Set(0,0,0);		float dimension = CubeRoot(mTotalVolume);		mUpper.Set(dimension,dimension,dimension);	} else  {		mHasBounds = false;	}}// ---------------------------------------------------------------------------//		¥ ReadMergeFile// ---------------------------------------------------------------------------voidCrystalArray::ReadMergeFile(){	char	tempStr[kMaxGetPutLineSize];	short	checkCrystalNum;	short	curCrystal;	Crystal	oneCrystal;	//	mProgress->SetPauseClicked(false);	mProgress->Show();	mProgress->SetTitle("\pReading File");	mProgress->SetActionDescriptor("\pReading File Header...");	mProgress->SetValues(0, 1, 0);	try {		mFile->OpenDataFork(fsRdWrPerm);		ReadMergeHeader();		mProgress->ThisMuchCompleted(1);		mProgress->SetActionDescriptor("\pReading Crystals...");		mProgress->SetValues(0, mNumCrystals, 0);				mXList = ResizeList(mXList, mNumCrystals);//		mYList = ResizeList(mYList, mNumCrystals);//		mZList = ResizeList(mZList, mNumCrystals);		mXListSizeAllocated = mNumCrystals;				for (curCrystal = 1; curCrystal <= mNumCrystals; curCrystal++) {			mProgress->Progress(curCrystal);			try {				mFile->getOneLine(tempStr);			} catch (myLFileStream::UnexpectedEOF) {				if (curCrystal < mNumCrystals)	{ // hit EOF before last line - bad					throw;	// toss it up the chain				}			}			sscanf(tempStr, "%hi%f%f%f%f%hi%li", 				&checkCrystalNum,				&oneCrystal.ctr.x,				&oneCrystal.ctr.y,				&oneCrystal.ctr.z,				&oneCrystal.r,				&oneCrystal.ctrSlice,				&oneCrystal.ctrID);			if (oneCrystal.r == 0)				continue;	// run next for() loop			if (oneCrystal.r < 0) {				mNegRadii++;				if (!mPrefs->discardNegs) {// now done in ComputeVolumes/CorrectedXlVolume://					oneCrystal.r = -(oneCrystal.r);					PushXl(oneCrystal);				}			} else {	// else r is positive				PushXl(oneCrystal);			}			if (checkCrystalNum != curCrystal)  {	// this crystal number isn't the one we expected next 				BadOrderErr thisErr;				thisErr.expectedNum = curCrystal;				thisErr.foundNum = checkCrystalNum;				throw thisErr;			}		}		mFile->CloseDataFork();		SortInternalLists();	} catch (myLFileStream::UnexpectedEOF) {		ErrorAlert theAlert("\pBoo Hoo.", "\pThere was a problem reading data from the file.  Unexpected End-Of-File. So sad.");		throw CReduceApp::CancelErr();	} catch (BadOrderErr thisErr) {		sprintf(tempStr, "There seems to be a problem (out of order).  I expected crystal number %hi next, but found number %hi instead.", thisErr.expectedNum, thisErr.foundNum);		ErrorAlert theAlert2("\pCrystal Number Problem", c2pstr(tempStr));		Clear();	}	mProgress->Hide();}// ---------------------------------------------------------------------------//		¥ RemoveIllegalOverlaps// ---------------------------------------------------------------------------/*		** Currently, clusters of >1 crystal are dealt with by examining the set pairwise*/voidCrystalArray::RemoveIllegalOverlaps(){	mProgress->SetActionDescriptor("\pRemoving illegal crystals");	mProgress->SetValues(0, GetCount(), 0);	mProgress->Show();	Crystal *thisXl, *otherXl;	mListSize = 0;	// kill lists since we're going to be munging up the array	for (short i = 1; i <= GetCount(); i++) {		thisXl = (Crystal *) GetItemPtr(i);		mProgress->Progress(i);		for (short j=i+1; j <= GetCount(); j++) {			otherXl = (Crystal *) GetItemPtr(j);			float separation = thisXl->ctr.Distance(otherXl->ctr);			if (separation < (thisXl->r + otherXl->r))	{	// if they overlap at all, then check for observability:				Crystal *smaller, *larger;				if (thisXl->r < otherXl->r) {					smaller = thisXl;					larger = otherXl;				} else {					smaller = otherXl;					larger = thisXl;				}				if (separation + smaller->r <= larger->r) {	// then smaller is completely inside larger					// this is a bit kludgy, but for ease of coding, I'm going to copy much of my FilterForObservability code					Crystal newXl;					newXl = *larger;					RemoveItemWithLists(j);					RemoveItemWithLists(i);					PushXl(newXl);					mListSize = 0;	// re-kill Lists					// force routine to redo this "i" loop by breaking out of j loop and					// decrementing i so it will be incremented to the current value the					// next time the for is executed.					j = GetCount();					i--;				}			}		}	}	mProgress->Hide();	RebuildLists();}// ---------------------------------------------------------------------------//		¥ FilterForObservability// ---------------------------------------------------------------------------/*	This function examines each pair of crystals to see if they would be observable	in a real dataset.  If not, the pair are combined into one with a slightly larger	volume, the idea being that this is what a human operator would interpret if the	crystals wrere in a CT dataset.	There are two criteria; either will make the pair of crystals be unobservable.	(1)  The center of the smaller sphere is at least 10% closer to the center of the larger sphere		than is the plane of intersection of the sphere surfaces.	(2)  The total length of the pair is less than 3 times the radius of the smaller sphere.	** Currently, clusters of >1 crystal are dealt with by examining the set pairwise*/voidCrystalArray::FilterForObservability(){	Boolean unobservable;	myLFileStream *debugOutputFile;	PP::LStr255 debugStr;	if (mPrefs->verbose) {		CReduceApp *theApp = (CReduceApp *) PP::LCommander::GetTopCommander();		debugOutputFile = theApp->GetDebugFile();		debugOutputFile->OpenDataFork(fsRdWrPerm);		debugStr = "\pBeginning Observability Filter\n";		debugOutputFile->SetMarker(0, PP::streamFrom_End);		debugOutputFile->putOneLine(debugStr);		debugOutputFile->CloseDataFork();	}	Crystal *thisXl, *otherXl;	mListSize = 0;	// kill lists since we're going to be munging up the array	for (short i = 1; i <= GetCount(); i++) {		thisXl = (Crystal *) GetItemPtr(i);		for (short j=i+1; j <= GetCount(); j++) {			otherXl = (Crystal *) GetItemPtr(j);			float separation = thisXl->ctr.Distance(otherXl->ctr);			if (separation < (thisXl->r + otherXl->r))	{	// if they overlap at all, then check for observability:				// is this pair observable?				unobservable = false;				Crystal *smaller, *larger;				if (thisXl->r < otherXl->r) {					smaller = thisXl;					larger = otherXl;				} else {					smaller = otherXl;					larger = thisXl;				}				float IntPlaneDist = (sqr(larger->r) - sqr(smaller->r) + sqr(separation)) / (2 * separation);				if (separation < mPrefs->crit1Factor * IntPlaneDist) {	// criterion (1)					unobservable = 1;				} else {					float totalLength = separation + larger->r + smaller->r;					if (totalLength < mPrefs->crit2Factor * smaller->r) {	// criterion (2)						unobservable = 2;					}				}								if (unobservable) {	// then we need to combine them as a human would in fuzzy CT data					Crystal newXl;					// put center at combined center-of-mass					float smallVol = (4.0 * pi * pow(smaller->r, 3) / 3.0);					float largeVol = (4.0 * pi * pow(larger->r, 3) / 3.0);					newXl.ctr = (larger->ctr * (largeVol/(largeVol + smallVol)));					newXl.ctr += (smaller->ctr * (smallVol/(largeVol + smallVol)));					// make volume (via radius) be combined volume: we need to add the two volumes, and subtract					// the spherical caps of each one that form the intersection volume (spherical cap					// volume formula is taken from pg. 314 of CRC Math Tables, 30th Ed.)					float h = larger->r - IntPlaneDist;					float largeCapVol = pi * sqr(h) * (3.0 * larger->r - h) / 3.0;					h = smaller->r - separation + IntPlaneDist;					float smallCapVol = pi * sqr(h) * (3.0 * smaller->r - h) / 3.0;					float totalVol = smallVol + largeVol - largeCapVol - smallCapVol;					newXl.r = CubeRoot(0.75 * totalVol / pi);										if (mPrefs->verbose) {						CReduceApp *theApp = (CReduceApp *) PP::LCommander::GetTopCommander();						myLFileStream *debugOutputFile = theApp->GetDebugFile();						debugOutputFile->OpenDataFork(fsRdWrPerm);						debugStr = "\pTossed out a pair dur to criterion #";						debugStr += (SInt32) unobservable;						debugStr += "\p; numbers were ";						debugStr += (SInt32) i;						debugStr += "\p and ";						debugStr += (SInt32) j;						debugStr += "\p, and added a new one, number ";						debugStr += (SInt32) GetCount() - 1;						debugStr += "\p\n";						debugOutputFile->SetMarker(0, PP::streamFrom_End);						debugOutputFile->putOneLine(debugStr);						debugOutputFile->CloseDataFork();					}					RemoveItemWithLists(j);					RemoveItemWithLists(i);					PushXl(newXl);					mListSize = 0;	// re-kill Lists					// force routine to redo this "i" loop by breaking out of j loop and					// decrementing i so it will be incremented to the current value the					// next time the for is executed.					j = GetCount();					i--;				}			}		}	}	RebuildLists();}// ---------------------------------------------------------------------------//		¥ CorrectForImpingement// ---------------------------------------------------------------------------/*CorrectForImpingement -- This routine nudges up the radius and vext for a crystal to compensate for impingement.It is written under the assumption that the radius read from the INTEGRATE file is directly from CRYSTALLIZE, without any prior volume corrections.  In this event, the radius will be solely function of domain volume, and willthus be underestimated if the crystal is impinged.  On the other hand, we do know that the radius does reflect the true actual volume.  The correction scheme is fairly simple, consisting of adding volume to "vext" to make up forthe amount of impingement reflected by "CorrectedCrystalVolume", and then recalculating the radius accordingly.This has some inherent shortcomings, such as not accounting for the fact that some of the added volume will alsobe impinged away, not to mention the fact that the impinging crystal is growing too.  Thus, we iterate (making this routine perhaps take a while) until the percentage error is less than the global variable volumeErrorTolerance.	*/voidCrystalArray::CorrectForImpingement(){	Boolean maxErrorSmallEnough, meanErrorSmallEnough, notConverging;	short	currXl, itNum, sign;	float	volumeDifference, currErr, maxErr, avgErr, oldAvgErr, maxTol, meanTol,			currVol;	Crystal *thisXl;		itNum = 0;	oldAvgErr = 0;	notConverging = false;	maxTol = mPrefs->impingementMaxErr / 100;	meanTol = mPrefs->impingementMeanErr / 100;	Lock();	do {		maxErrorSmallEnough = true;		itNum++;		maxErr = 0.0;		oldAvgErr = avgErr;		avgErr = 0.0;		for (currXl = 1; currXl <= GetCount(); currXl++) {			thisXl = (Crystal *) GetItemPtr(currXl);			currVol = CorrectedCrystalVolume(thisXl);			if (currVol > 0) {	// ignore engulfed crystals				volumeDifference = thisXl->actV - currVol;				thisXl->extV = volumeDifference + thisXl->extV;				currErr = volumeDifference / thisXl->actV;				avgErr = avgErr + currErr;				if (currErr > maxErr)					maxErr = currErr;				if (currErr > maxTol)					maxErrorSmallEnough = false;			}		}		for (currXl = 1; currXl <= GetCount(); currXl++) {			thisXl = (Crystal *) GetItemPtr(currXl);			if (thisXl->r < 0)				sign = -1;			else				sign = 1;			thisXl->r = sign * CubeRoot(thisXl->extV * 3 / (4 * gPI));		}		avgErr = avgErr / GetCount();		meanErrorSmallEnough = (avgErr <= meanTol);		if ((itNum > 1) && (avgErr > oldAvgErr))			notConverging = true;	} while (!(notConverging || (maxErrorSmallEnough && meanErrorSmallEnough)));	Unlock();}// ---------------------------------------------------------------------------//		¥ CorrectedCrystalVolume// ---------------------------------------------------------------------------floatCrystalArray::CorrectedCrystalVolume (Crystal *inXl){	short i;	float volume;		// volume of the crystal -- total volume minus sectors belonging to other crystals	float dist;			// distance between two sphere centers	float sumRad;		// sum of two sphere radii	float cosAlpha;		// cosine of the angle between the line connecting two crystal centers and the boundary of their intersection	float h;			// distance between the dividing plane and the edge of the sphere whose volume we want	float segmentVol;	// volume of the part of the sphere shaved off by the dividing plane	float absXlRad, absCurrRad;	// Since radii are sometimes negative here for flagging purposes, these store Abs(radius)	Crystal *thisXl;	Boolean	dontbreak = true;	absXlRad = std::fabs(inXl->r);	volume = 4.0 * gPI * absXlRad * absXlRad * absXlRad / 3.0;	Lock();	for (i = 1; (i <= GetCount()) && dontbreak; i++) {		thisXl = (Crystal *) GetItemPtr(i);		if (thisXl != inXl) {			absCurrRad = std::fabs(thisXl->r);			dist = thisXl->ctr.Distance(inXl->ctr);			sumRad = absXlRad + absCurrRad;			if (sumRad > dist) {	// radii longer than distance between centers - spheres intersect				if (dist + absXlRad < absCurrRad) {//					numEngulfed++;					volume = 0;					dontbreak = false;  // Leave the "for i..." loop				} else if (dist + absCurrRad > absXlRad) {	// Make sure other crystal is not engulfed					cosAlpha = sqr(dist) + sqr(absXlRad) - sqr(absCurrRad);	// law of cosines					cosAlpha = cosAlpha / (2.0 * dist * absXlRad);				// law of cosines, cont.					if (cosAlpha > 0) {						h = absXlRad * (1.0 - cosAlpha);						segmentVol = gPI * h * h * (3.0 * absXlRad - h) / 3.0;	// volume of segment, from CRC handbook						volume = volume - segmentVol;					} else if (cosAlpha == 0) {						volume = volume - 2.0 * gPI * absXlRad * absXlRad * absXlRad / 3.0;					} else {						cosAlpha = cos(gPI - acos(cosAlpha));						h = absXlRad * (1.0 - cosAlpha);						segmentVol = gPI * h * h * (3.0 * absXlRad - h) / 3.0;	// volume of segment, from CRC handbook						volume = volume - segmentVol;					}				}			}		}	}	Unlock();	if (volume < 0)		volume = 0;	return volume;}// ---------------------------------------------------------------------------//		¥ UpdateXl// ---------------------------------------------------------------------------voidCrystalArray::UpdateXl(short index, Crystal inXl){	AssignItemsAt(1, index, (void *) &inXl);}// ---------------------------------------------------------------------------//		¥ GetFileName// ---------------------------------------------------------------------------voidCrystalArray::GetFileName(Str63 ioStr){	static FSSpec theSpec;	mFile->GetSpecifier(theSpec);	PP::LString::CopyPStr(theSpec.name, ioStr);}// ---------------------------------------------------------------------------//		¥ GetNuclProb// ---------------------------------------------------------------------------nuclProbType*CrystalArray::GetNuclProb(){	return mNuclProb;}#pragma mark ======== XlList Optimization Routines ========// ---------------------------------------------------------------------------------//		¥ VerifyList// ---------------------------------------------------------------------------------// This assumes that the list is an X-coordinate listBooleanCrystalArray::VerifyList() //XYZListElement *inList){	XYZListElement *inList = mXList;	float lastLoc = -FLT_MAX;	float thisLoc;	Boolean good = true;	Crystal *thisXl = nil;		Lock();	// Check to see if list is sorted, and that indices are correct	for (long i=0; (i <= mListSize-1) && good; i++) {		thisLoc = (inList[i]).location;		if (thisLoc < lastLoc) {			good = false;		}		lastLoc = thisLoc;		thisXl = (Crystal *) GetItemPtr((inList[i]).index);		if (thisXl->ctr.x != thisLoc) {			good = false;		}	}	Unlock();	return good;}// ---------------------------------------------------------------------------------//		¥ RemoveFromList// ---------------------------------------------------------------------------------BooleanCrystalArray::RemoveFromList(XYZListElement *inList, float inVal, long inIndex){	if (mListSize > 0) {		// find location		float	frxn = min(1.0, inVal / ((inList[mListSize-1]).location - (inList[0]).location) - (inList[0]).location);		long	curLoc = (mListSize-1) * frxn;	// start at approx location		short	direction = sign(inVal - (inList[curLoc]).location);		while ((curLoc >= 0) && (curLoc <= mListSize-1) && 				(inVal * direction - (inList[curLoc]).location * direction > std::fabs(inVal/100))) {			curLoc += direction;		}		while (inVal - (inList[curLoc]).location <= std::fabs(inVal/100)) {			if (inIndex == (inList[curLoc]).index) {				::BlockMove(inList + ((curLoc+1) * sizeof(XYZListElement)),							inList + ((curLoc) * sizeof(XYZListElement)),							sizeof(XYZListElement) * max(0, (mListSize - curLoc - 1)));	// shift to make room				return true;			} else {				curLoc += direction;			}		}		SignalPStr_("\pTried to remove from a list, but item wasn't there!");		return false;	}	return true;	// shouldn't get here}// ---------------------------------------------------------------------------------//		¥ SortInternalLists// ---------------------------------------------------------------------------------voidCrystalArray::SortInternalLists(){	QuickSortXYZList(mXList, mListSize);}// ---------------------------------------------------------------------------------//		¥ RebuildLists// ---------------------------------------------------------------------------------voidCrystalArray::RebuildLists(){	Lock();	mListSize = 0;	for (long i = 1; i<= GetCount(); i++) {		if (mListSize >= mXListSizeAllocated) {			XYZListElement *holderX = mXList;			mXListSizeAllocated += 50;			mXList = new XYZListElement[mXListSizeAllocated+1];			for (long j = 0; j <= mXListSizeAllocated - 50; j++) {				mXList[j] = holderX[j];			}		}		Crystal *thisXl = (Crystal *) GetItemPtr(i);		mXList[mListSize].index = i;		mXList[mListSize].location = thisXl->ctr.x;		mListSize++;	}	Unlock();	SortInternalLists();}// ---------------------------------------------------------------------------------//		¥ AddToList// ---------------------------------------------------------------------------------voidCrystalArray::AddToList(XYZListElement *inList, float inVal, long inIndex, long *ioListSizeAlloc){	if (mListSize == 0) {		(inList[mListSize]).index = inIndex;		(inList[mListSize]).location = inVal;	} else {		if (mListSize+1 >= *ioListSizeAlloc) {			// need to re-allocate, larger			*ioListSizeAlloc = (float) *ioListSizeAlloc * 1.1;					// increase by 10%			inList = ResizeList(inList, *ioListSizeAlloc);		}		// find insert location		float	frxn = min(1.0, inVal / ((inList[mListSize-1]).location - (inList[0]).location) - (inList[0]).location);		long	curLoc = max(0, (mListSize * frxn) - 1);	// start at approx location		short	direction = sign(inVal - (inList[curLoc]).location);		while ((curLoc >= 0) && (curLoc <= mListSize-1) && 				(inVal * direction > (inList[curLoc]).location * direction)) {			curLoc += direction;		}		curLoc += -((direction - 1) / 2);	// does nothing if direction was +1, adds 1 if direction was -1		if (mListSize > curLoc)			::BlockMove(inList + ((curLoc) * sizeof(XYZListElement)),						inList + ((curLoc+1) * sizeof(XYZListElement)),						sizeof(XYZListElement) * (mListSize - curLoc));	// shift to make room//			::BlockMove(inList+ (curLoc]), &(inList[curLoc+1]), sizeof(XYZListElement) //							* (mListSize - curLoc));	// shift to make room		(inList[curLoc]).index = inIndex;		(inList[curLoc]).location = inVal;	}}// ---------------------------------------------------------------------------------//		¥ ResizeList// ---------------------------------------------------------------------------------XYZListElement *CrystalArray::ResizeList(XYZListElement *inList, long ioListSizeAlloc){	XYZListElement *doomed = inList;	inList = new XYZListElement[ioListSizeAlloc];	// allocate new	::BlockMove(doomed, inList, sizeof(XYZListElement) * mListSize);	// copy data from old		// delete old list	delete[] doomed;	return inList;}// ---------------------------------------------------------------------------------//		¥ NearbyXls// ---------------------------------------------------------------------------------XlListCrystalArray::NearbyXls(Point3DFloat inPt, float inDistance){	short lower, upper;	short listSize = NearbyCount(mXList, inPt.x, inDistance, lower, upper);	XlList firstList;	XlList newList;	if (listSize <= 0) {		newList = new short[2];		newList[0] = 0;	} else {		firstList = new short[listSize + 2];		if (firstList == nil) {			throw MemErr();		}		firstList[0] = 0;		for (long curLoc = lower; curLoc <= upper; curLoc++) {			firstList[firstList[0]+1] = (mXList[curLoc]).index;			(firstList[0])++;		}				// look through list, and see if each crystal is in range		newList = new short[firstList[0]+2];		newList[0] = 0;		Lock();		Crystal *thisXl;		for (long i = 1; i <= firstList[0]; i++) {			thisXl = (Crystal *) GetItemPtr(firstList[i]);			if ((std::fabs(thisXl->ctr.y - inPt.y) < inDistance) &&				(std::fabs(thisXl->ctr.z - inPt.z) < inDistance)) {				newList[0]++;				newList[newList[0]] = firstList[i];			}		}		Unlock();				delete[] firstList;	}	return newList;}// ---------------------------------------------------------------------------------//		¥ NearbyCount// ---------------------------------------------------------------------------------shortCrystalArray::NearbyCount(XYZListElement *inList, float inVal, float inDistance,						short &outLowerIndex, short &outUpperIndex){	#define MinListSizeForSearchAlgorithm 30		float lowerValue = inVal - inDistance;	float upperValue = inVal + inDistance;	outLowerIndex = -1;	outUpperIndex = -1;		if (mListSize < MinListSizeForSearchAlgorithm) {		short inCount = 0;		for (short i = 0; i <= mListSize-1; i++) {			if ((inList[i].location >= lowerValue) && (inList[i].location <= upperValue)) {				inCount++;				outUpperIndex = i;				if (outLowerIndex == -1)					outLowerIndex = i;			} else {				break;			}		}		return inCount;	} else {		float	frxn;		long	curLoc;		short	direction;		short lowerIndex, upperIndex;		// find lower element to include in ioNearbyList		frxn = min(1.0, lowerValue / ((inList[mListSize-1]).location - (inList[0]).location) - (inList[0]).location);		curLoc = max(0, (mListSize * frxn) - 1);	// start at approx location		direction = sign(lowerValue - (inList[curLoc]).location);		while ((curLoc >= 0) && (curLoc <= mListSize-1) && 				(lowerValue * direction > (inList[curLoc]).location * direction)) {			curLoc += direction;		}		curLoc += -((direction - 1) / 2);	// does nothing if direction was +1, adds 1 if direction was -1		// need to account for series of values present in list that are equal to lowerValue		if (direction == -1) {			while ((curLoc-1 >= 0) && (lowerValue == (inList[curLoc-1]).location)) {				curLoc--;			}		}		// curLoc is now the smallest value equal to or greater than lowerValue		lowerIndex = curLoc;		// find upper element to include in ioNearbyList		frxn = min(1.0, upperValue / ((inList[mListSize-1]).location - (inList[0]).location) - (inList[0]).location);		curLoc = max(0, (mListSize * frxn) - 1);	// start at approx location		direction = sign(upperValue - (inList[curLoc]).location);		while ((curLoc >= 0) && (curLoc <= mListSize-1) && 				(upperValue * direction > (inList[curLoc]).location * direction)) {			curLoc += direction;		}		curLoc += -((direction - 1) / 2);	// does nothing if direction was +1, adds 1 if direction was -1		// need to account for series of values present in list that are equal to upperValue		if (direction == 1) {			while ((curLoc-1 <= mListSize) && (upperValue == (inList[curLoc-1]).location)) {				curLoc++;			}		}		// curLoc is now the smallest value equal to or less than upperValue		upperIndex = curLoc;		outLowerIndex = lowerIndex;		outUpperIndex = upperIndex;		return (upperIndex - lowerIndex + 1);	}		// should never get here	return -1;}// ---------------------------------------------------------------------------------//		¥ QuickSortXYZList// ---------------------------------------------------------------------------------voidCrystalArray::QuickSortXYZList(XYZListElement *inList, short inSize){// Pseudo-recursion version:  (Closely follows Numerical Recipes algorithm)	short PSRMaxSize =  (2 * (log(inSize) / log(2)) * 1.2) + 4;	// extras for good measure, 2 for 2 elements per stack entry	short	*PSRStack;	Boolean done = false;	while (!done) {		try {			#define QS_SWAP(a, b) temp = (a); (a)=(b); (b) = temp;			#define MinSubarraySizeForQuickSort 5			PSRStack = new short[PSRMaxSize+1];			short PSRSize = 0;						short curL = 0;	// "l" of NR text			short curR = inSize-1;	// "ir" of NR text			register short i, j, k;			XYZListElement v;	// "a" of NR text			XYZListElement temp;	// "temp" of NR text			for (;;) {				if (curR - curL < MinSubarraySizeForQuickSort) {	// Insertion sort when subarray small enough					for (j = curL+1; j <= curR; j++) {						v = inList[j];						for (i = j-1; i >= curL; i--) {							if (inList[i].location <= v.location) break;							inList[i+1] = inList[i];						}						inList[i+1] = v;					}					if (PSRSize == 0) break;	// done!					curR = PSRStack[PSRSize--];	// pop stack and start again					curL = PSRStack[PSRSize--];				} else {					k = (curL + curR) >> 1;		// k is mean of curL & curR, since ">>" divides by two						// Choose the median of left, center, and right elements as the pivot, value, v, and rearrange so that						// inList[curL] <= inList[curL+1] <= inList[curR].					QS_SWAP(inList[k], inList[curL+1]);					if (inList[curL].location > inList[curR].location) {						QS_SWAP(inList[curL], inList[curR]);					}					if (inList[curL+1].location > inList[curR].location) {						QS_SWAP(inList[curL+1], inList[curR]);					}					if (inList[curL].location > inList[curL+1].location) {						QS_SWAP(inList[curL], inList[curL+1]);					}					i = curL + 1;					j = curR;					v = inList[curL+1];					// for the whole section, put everything less than the pivot (v) 					// to the left, and greater than the pivot to the right					for (;;) {						do i++; while (inList[i].location < v.location) ;						do j--; while (inList[j].location > v.location) ;						if (j < i) break;						QS_SWAP(inList[j], inList[i]);					}					inList[curL+1] = inList[j];		// insert pivot value					inList[j] = v;										PSRSize += 2;										// Push pointers to larger subarray on stack, process smaller subarray immediately					if (PSRSize > PSRMaxSize)	throw PSRProblem();					if (curR - i + 1 >= j-1) {						// push the right side						PSRStack[PSRSize] = curR;						PSRStack[PSRSize-1] = i;						curR = j-1;					} else {						// push the left side						PSRStack[PSRSize] = j-1;						PSRStack[PSRSize-1] = curL;						curL = i;					}				}			}			done = true;		} catch (PSRProblem) {			delete[] PSRStack;			PSRMaxSize *= 2;		}	}	delete[] PSRStack;}/*// ---------------------------------------------------------------------------------//		¥ MakeNearbyXlsList// ---------------------------------------------------------------------------------voidCrystalArray::MakeNearbyXlsList(XYZListElement *inList, short *ioNearbyList,									 short *ioNLUsed, short inLower, short inUpper){	float lowerValue;	float upperValue;	float	frxn;	long	curLoc;	short	direction;	// find lower element to include in ioNearbyList	lowerValue = inVal - inDistance;	upperValue = inVal + inDistance;	frxn = min(1.0, lowerValue / (inList[mListSize-1]).location);	curLoc = max(0, (mListSize * frxn) - 1);	// start at approx location	direction = sign(lowerValue - (inList[curLoc]).location);	while ((curLoc >= 0) && (curLoc <= mListSize-1) && 			(lowerValue * direction > (inList[curLoc]).location * direction)) {		curLoc += direction;	}	curLoc += -((direction - 1) / 2);	// does nothing if direction was +1, adds 1 if direction was -1	// need to account for series of values present in list that are equal to lowerValue	if (direction == -1) {		while ((curLoc-1 >= 0) && (lowerValue == (inList[curLoc-1]).location)) {			curLoc--;		}	}	// curLoc is now the smallest value equal to or greater than lowerValue		// walk through inList, copying indices to ioNearbyList, until we hit upperValue	while ((curLoc <= mListSize-1) && (upperValue >= (inList[curLoc]).location)) {		ioNearbyList[*ioNLUsed] = (inList[curLoc]).index;		(*ioNLUsed)++;		curLoc++;	}		for (long curLoc = inLower; curLoc <= inUpper; curLoc++) {		ioNearbyList[*ioNLUsed] = (inList[curLoc]).index;		(*ioNLUsed)++;	}}// ---------------------------------------------------------------------------------//		¥ QuickSortXlList// ---------------------------------------------------------------------------------voidCrystalArray::QuickSortXlList(short *inList, short inSize){////	Recursion version:////	if (r > l) {//		short i, j;//		short v;//		short temp;//		v = inList[r];//		i = l - 1;//		j = r;//		// for the whole section, put everything less than the pivot (j) //		// to the left, and greater than the pivot to the right//		for (;;) {//			while (inList[++i] < v) ;//			while (inList[--j] > v) ;//			if (i >= j) break;//			temp = inList[j]; inList[j] = inList[i]; inList[i] = temp;	// swap elements i & j//		}//		temp = inList[r]; inList[r] = inList[i]; inList[i] = temp;	// swap elements i & r//		QuickSortXlList(inList, l, i-1);		// sort the left side//		QuickSortXlList(inList, i+1, r);		// sort the right side//	}//// Pseudo-recursion version:  (Closely follows Numerical Recipes algorithm)	short PSRMaxSize =  (2 * (log(inSize) / log(2)) * 1.2) + 4;	// extras for good measure, 2 for 2 elements per stack entry	short	*PSRStack;	Boolean done = false;	while (!done) {		try {			#define QS_SWAP(a, b) temp = (a); (a)=(b); (b) = temp;			#define MinSubarraySizeForQuickSort 5			PSRStack = new short[PSRMaxSize];			short PSRSize = 0;						short curL = 0;	// "l" of NR text			short curR = inSize-1;	// "ir" of NR text			register short i, j, k;			short v;	// "a" of NR text			short temp;	// "temp" of NR text			for (;;) {				if (curR - curL < MinSubarraySizeForQuickSort) {	// Insertion sort when subarray small enough					for (j = curL+1; j <= curR; j++) {						v = inList[j];						for (i = j-1; i >= curL; i--) {							if (inList[i] <= v) break;							inList[i+1] = inList[i];						}						inList[i+1] = v;					}					if (PSRSize == 0) break;	// done!					curR = PSRStack[PSRSize--];	// pop stack and start again					curL = PSRStack[PSRSize--];				} else {					k = (curL + curR) >> 1;		// k is mean of curL & curR, since ">>" divides by two						// Choose the median of left, center, and right elements as the pivot, value, v, and rearrange so that						// inList[curL] <= inList[curL+1] <= inList[curR].					QS_SWAP(inList[k], inList[curL+1]);					if (inList[curL] > inList[curR]) {						QS_SWAP(inList[curL], inList[curR]);					}					if (inList[curL+1] > inList[curR]) {						QS_SWAP(inList[curL+1], inList[curR]);					}					if (inList[curL] > inList[curL+1]) {						QS_SWAP(inList[curL], inList[curL+1]);					}					i = curL + 1;					j = curR;					v = inList[curL+1];					// for the whole section, put everything less than the pivot (v) 					// to the left, and greater than the pivot to the right					for (;;) {						do i++; while (inList[i] < v) ;						do j--; while (inList[j] > v) ;						if (j < i) break;						QS_SWAP(inList[j], inList[i]);					}					inList[curL+1] = inList[j];		// insert pivot value					inList[j] = v;										PSRSize += 2;										// Push pointers to larger subarray on stack, process smaller subarray immediately					if (PSRSize > PSRMaxSize)	throw PSRProblem();					if (curR - i + 1 >= j-1) {						// push the right side						PSRStack[PSRSize] = curR;						PSRStack[PSRSize-1] = i;						curR = j-1;					} else {						// push the left side						PSRStack[PSRSize] = j-1;						PSRStack[PSRSize-1] = curL;						curL = i;					}				}			}			done = true;		} catch (PSRProblem) {			delete[] PSRStack;			PSRMaxSize *= 2;		}	}	delete[] PSRStack;}// ---------------------------------------------------------------------------------//		¥ WinnowNearbyList// ---------------------------------------------------------------------------------voidCrystalArray::WinnowNearbyList(XYZListElement *inList, float inVal, float inDistance, short *ioNearbyList, short *ioNLUsed){	float lowerValue;	float upperValue;	float	frxn;	long	curLoc;	short	direction; if (*ioNLUsed > 0) {	// we have a list that needs to be winnowed		// find lower element to include in ioNearbyList		lowerValue = inVal - inDistance;		upperValue = inVal + inDistance;		frxn = min(1.0, lowerValue / (inList[mListSize-1]).location);		curLoc = max(0, (mListSize * frxn) - 1);	// start at approx location		direction = sign(lowerValue - (inList[curLoc]).location);		while ((curLoc >= 0) && (curLoc <= mListSize-1) && 				(lowerValue * direction > (inList[curLoc]).location * direction)) {			curLoc += direction;		}		curLoc += -((direction - 1) / 2);	// does nothing if direction was +1, adds 1 if direction was -1		// need to account for series of values present in list that are equal to lowerValue		if (direction == -1) {			while ((curLoc-1 >= 0) && (lowerValue == (inList[curLoc-1]).location)) {				curLoc--;			}		}		// curLoc is now the smallest value equal to or greater than lowerValue				// sort ioNearbyList, for easier examination		SortXlList(ioNearbyList, *ioNLUsed);				XlList newList = new short[*ioNLUsed];		short newUsed = 0;		// walk through inList, comparing indices to ioNearbyList, until we hit upperValue		while ((curLoc >= 0) && (curLoc <= mListSize-1) && 				(upperValue >= (inList[curLoc]).location)) {			short thisIndex = (inList[curLoc]).index;			// if this index is in ioNearbyList, then add it to newList			// find thisIndex in ioNearbyList			float ionl_frxn = min(1.0, (float)thisIndex / (float)ioNearbyList[*ioNLUsed-1]);			short ionl_curLoc = max(0, (*ioNLUsed * ionl_frxn) - 1);	// start at approx location			short ionl_direction = sign(thisIndex - ioNearbyList[ionl_curLoc]);			while ((ionl_curLoc >= 0) && (ionl_curLoc <= *ioNLUsed-1) && 					(thisIndex * ionl_direction > ioNearbyList[ionl_curLoc] * ionl_direction)) {				ionl_curLoc += ionl_direction;			}			ionl_curLoc = max(0, min((*ioNLUsed-1), ionl_curLoc));			if (thisIndex == ioNearbyList[ionl_curLoc]) {				// add it to newList				newList[newUsed++] = thisIndex;			}			curLoc++;		}		::BlockMove(newList, ioNearbyList, sizeof(short)*(newUsed));		delete[] newList;		*ioNLUsed = newUsed;	}}// ---------------------------------------------------------------------------------//		¥ SortXlList// ---------------------------------------------------------------------------------voidCrystalArray::SortXlList(short *inList, short inSize){//	ShellSortXlList(inList, inSize);	QuickSortXlList(inList, inSize);}// ---------------------------------------------------------------------------------//		¥ ShellSortXlList// ---------------------------------------------------------------------------------voidCrystalArray::ShellSortXlList(short *inList, short inSize){	short h, i, j;	short v;	for (h = 1; h <= inSize/9; h = ( 3 * h + 1 ) ) {}      // determine the value for h	for ( ; h > 0; h /= 3 ) {		// h = 40, 13, 4, 1 ...		for ( i = h + 1; i <= inSize; i += 1 ) {			v = inList[i];			j = i;			while ( ( j > h ) && ( inList[j - h] > v ) ) {				inList[j] = inList[j-h];				j -= h;			}			inList[j] = v;		}	}}*/