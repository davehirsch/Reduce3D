//**************************************************************************************// Filename:	CrystalHashTable.cpp// Copyright © 1998 <YourNameHere>. All rights reserved.//// Description:	////**************************************************************************************// Revision History:// Monday, November 30, 1998 - Original//**************************************************************************************#include "CrystalHashTable.h"#include "MathStuff.h"//**************************************************************************************// Function:	Default Constructor//// Description: Builds the CrystalHashTable class.//// Inputs:	none//		// Outputs:	none	////**************************************************************************************CrystalHashTable::CrystalHashTable(void){}CrystalHashTable::CrystalHashTable(BoundingBox *inBBox, short inDim){	if (inBBox->GetType() == kSidesBox)		mSSet = inBBox->mExscribedCube;	else		mSSet = inBBox;	mXls = inBBox->theXls;	mType = mSSet->GetType();	mDim = inDim;		try {		InitDimensions();		InitializeHash();	} catch (MemErr) {		CleanUp();		throw;	}}//**************************************************************************************// Function:	Destructor//// Description: Destroys the CrystalHashTable class.//// Inputs:	none//		// Outputs:	none	////**************************************************************************************CrystalHashTable::~CrystalHashTable(void){	CleanUp();}// ---------------------------------------------------------------------------------//		¥ Copy(CrystalHashTable &inHash)// ---------------------------------------------------------------------------------voidCrystalHashTable::Copy(CrystalHashTable &inHash){	mSSet = inHash.mSSet;	mXls = inHash.mXls;	mType = inHash.mType;	mXUnit = inHash.mXUnit;	mYUnit = inHash.mYUnit;	mZUnit = inHash.mZUnit;	mHUnit = inHash.mHUnit;	mRUnit = inHash.mRUnit;	mThetaUnit = inHash.mThetaUnit;	mXMin = inHash.mXMin;	mYMin = inHash.mYMin;	mZMin = inHash.mZMin;	mHMin = inHash.mHMin;	mXCtr = inHash.mXCtr;	mYCtr = inHash.mYCtr;	mDim = inHash.mDim;	mHash = nil;	// needs to be initialized}// ---------------------------------------------------------------------------------//		¥ NearbyCrystals(Point3DFloat &inLoc)// ---------------------------------------------------------------------------------/* Need the check, because if inLoc.x == 0.99999999, then the trunc comes out with	i == mDim */BooleanCrystalHashTable::NearbyCrystals(Point3DFloat &inLoc, XlList &ioXlListPtr){	short i, j, k;	i = trunc((inLoc.x - mXMin) / mXUnit);	j = trunc((inLoc.y - mYMin) / mYUnit);	k = trunc((inLoc.z - mZMin) / mZUnit);	short index = ((i >= mDim) ? i-1 : i) * mDim * mDim				+ ((j >= mDim) ? j-1 : j) * mDim				+ ((k >= mDim) ? k-1 : k);	SignalIf_(index >= (mDim * mDim * mDim));	short *arrayLoc = mHash[index];	ioXlListPtr = (arrayLoc + 2);	// moves past arraySize and engulfed elements	return *(arrayLoc+1);}// ---------------------------------------------------------------------------------//		¥ CleanUp()// ---------------------------------------------------------------------------------voidCrystalHashTable::CleanUp(){	if (mHash) {		for (short i = 0; i <= mDim - 1; i++) {			for (short j = 0; j <= mDim - 1; j++) {				for (short k = 0; k <= mDim - 1; k++) {					if (mHash[i*mDim*mDim + j*mDim + k])						delete[] mHash[i*mDim*mDim + j*mDim + k];				}			}		}		delete[] mHash;		mHash = nil;	}}// ---------------------------------------------------------------------------------//		¥ InitDimensions// ---------------------------------------------------------------------------------voidCrystalHashTable::InitDimensions(){	switch (mType) {		case kRPBox:			mXUnit = mSSet->mSideLenX / mDim;			mYUnit = mSSet->mSideLenY / mDim;			mZUnit = mSSet->mSideLenZ / mDim;			mXMin = mSSet->mCtr.x - mSSet->mSideLenX / 2;			mYMin = mSSet->mCtr.y - mSSet->mSideLenY / 2;			mZMin = mSSet->mCtr.z - mSSet->mSideLenZ / 2;		break;		case kCubeBox:			mXUnit = mSSet->mSideLen / mDim;			mYUnit = mSSet->mSideLen / mDim;			mZUnit = mSSet->mSideLen / mDim;			mXMin = mSSet->mCtr.x - mSSet->mSideLen / 2;			mYMin = mSSet->mCtr.y - mSSet->mSideLen / 2;			mZMin = mSSet->mCtr.z - mSSet->mSideLen / 2;			mType = kRPBox;		break;		case kCylBox:			mHUnit = mSSet->mHeight / mDim;			mRUnit = mSSet->mRadius / mDim;			mThetaUnit = 360.0 / mDim;			mHMin = mSSet->mCtr.z - mSSet->mHeight / 2;			mXCtr = mSSet->mCtr.x;			mYCtr = mSSet->mCtr.y;		break;	}}// ---------------------------------------------------------------------------------//		¥ ReHash// ---------------------------------------------------------------------------------voidCrystalHashTable::ReHash(){	if (mType == kRPBox) {		// initialize cells		for (short i = 0; i <= mDim - 1; i++) {			for (short j = 0; j <= mDim - 1; j++) {				for (short k = 0; k <= mDim - 1; k++) {					mHash[i*mDim*mDim + j*mDim + k][1] = 0;	// not engulfed					mHash[i*mDim*mDim + j*mDim + k][2] = 0;	// first element of XlList has # of filled cells				}			}		}		AssignXlsRP();	} else {	// kCylBox		SignalPStr_("\pCylBox Not coded yet! Have Dave finish XlHashTable");	}}// ---------------------------------------------------------------------------------//		¥ AssignXlsRP// ---------------------------------------------------------------------------------voidCrystalHashTable::AssignXlsRP(){	float cellDiag = sqrt(sqr(mXUnit) + sqr(mYUnit) + sqr(mZUnit)) / 2.0;	// examine each crystal, and add it to appropriate cells	Crystal *thisXl;	mXls->Lock();	for (short XlNum=1; XlNum <= mXls->GetCount(); XlNum++) {		thisXl = (Crystal *) mXls->GetItemPtr(XlNum);				// iterate over the small RP of cells within which the crystal lies		short botX = max(0, floor(((thisXl->ctr.x - thisXl->r) - mXMin) / mXUnit) - 1);		short topX = min(mDim-1, floor(((thisXl->ctr.x + thisXl->r) - mXMin) / mXUnit) + 1);		short botY = max(0, floor(((thisXl->ctr.y - thisXl->r) - mYMin) / mYUnit) - 1);		short topY = min(mDim-1, floor(((thisXl->ctr.y + thisXl->r) - mYMin) / mYUnit) + 1);		short botZ = max(0, floor(((thisXl->ctr.z - thisXl->r) - mZMin) / mZUnit) - 1);		short topZ = min(mDim-1, floor(((thisXl->ctr.z + thisXl->r) - mZMin) / mZUnit) + 1);		for (short x = botX; x <= topX; x++) {			for (short y = botY; y <= topY; y++) {				for (short z = botZ; z <= topZ; z++) {					// for each cell, add this crystal to its list if it's close enough					Point3DFloat thisLoc(	mXMin + mXUnit * (x+0.5),											mYMin + mYUnit * (y+0.5),											mZMin + mZUnit * (z+0.5));					if (thisXl->ctr.Distance(thisLoc) - cellDiag < thisXl->r) {						XlList element = mHash[x*mDim*mDim + y*mDim + z];						short oldCount;						if (thisXl->ctr.Distance(thisLoc) + cellDiag < thisXl->r) {	// over-conservative but quick test for engulfing							element[1] = true;							oldCount = 0;	// since this cell is engulfed, discard records for other Xls that just intersect it											// also, since every cell will always have a list of at least kArrayIncrement, we don't need											// to check the array size						} else {							// close enough, so add to list							short oldSize = element[0];							oldCount = element[2];							if (oldCount == oldSize - 3) {	// then array is full & need to re-allocate								XlList newList = new short[oldSize + kArrayIncrement];																// copy from old to new								::BlockMove((Ptr)element, (Ptr)newList, sizeof(short) * oldSize);																// make spot in mHash point to newList								mHash[x*mDim*mDim + y*mDim + z] = newList;																// dispose of old list's memory								delete[] element;																// make element point to good list								element = newList;								// set new size element								element[0] = oldSize + kArrayIncrement;							}						}						element[2] = oldCount+1;						element[oldCount+3] = XlNum;					}				}	// for z			}	// for y		}	// for x	}	// for XlNum	mXls->Unlock();}// ---------------------------------------------------------------------------------//		¥ InitializeHash// ---------------------------------------------------------------------------------voidCrystalHashTable::InitializeHash(){	if (mType == kRPBox) {		mHash = new XlList[mDim*mDim*mDim];		if (!mHash) throw MemErr();		// initialize cells		for (short i = 0; i <= mDim - 1; i++) {			for (short j = 0; j <= mDim - 1; j++) {				for (short k = 0; k <= mDim - 1; k++) {					mHash[i*mDim*mDim + j*mDim + k] = new short[kArrayIncrement + 3];					mHash[i*mDim*mDim + j*mDim + k][0] = kArrayIncrement + 3;	// first element of XlList has arraySize					mHash[i*mDim*mDim + j*mDim + k][1] = 0;	// 2nd element of XlList has engulfed status					mHash[i*mDim*mDim + j*mDim + k][2] = 0;	// first element of XlList has # of filled cells				}			}		}		AssignXlsRP();	} else {	// kCylBox		SignalPStr_("\pCylBox Not coded yet! Have Dave finish XlHashTable");	}}