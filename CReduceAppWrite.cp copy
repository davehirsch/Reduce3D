// =================================================================================//	CReduceAppComp.cp						// =================================================================================#include "CReduceApp.h"#include "CReducePrefs.h"#include "myLFileStream.h"#include "BoundingBox.h"#include "ErrorAlert.h"#include <string.h>extern long double gPI;// ---------------------------------------------------------------------------//		¥ DoMeanCumCSD// ---------------------------------------------------------------------------voidCReduceApp::DoMeanCumCSD(){	float		rad, meanRad;	CFloatArray	meanCSD;	float		thisCSDVal;	short		i, index;	long		numXls=0;	rad = 0.0;	// temp use of rad	for (i=1; i<= mPrefs->numClassesMeanCSD; i++) {		meanCSD.Push(&rad);	}		mTheXls->Lock();	meanRad = CubeRoot(3.0 * mStats->meanActV / (4.0 * gPI));	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {//			rad = CubeRoot(3.0 * (*mTheXls)[i].actV / (4.0 * gPI));			rad = thisXl->r;	// uses extV instead of actV 			index = mPrefs->numClassesMeanCSD - trunc((rad /					(mStats->meanR * mPrefs->maxValueMeanCSD)) *					(mPrefs->numClassesMeanCSD)) + 1;//			index = mPrefs->numClassesMeanCSD - trunc((rad ///					(mStats->meanR * mPrefs->maxValueMeanCSD)) *//					(mPrefs->numClassesMeanCSD - 0.0001));			if (index < 1)				index = 1;			numXls++;			meanCSD.Update(index, (meanCSD[index] + 1));		}	}	mTheXls->Unlock();		for (i=1; i <= mPrefs->numClassesMeanCSD; i++) {	// convert to percent 		thisCSDVal = meanCSD[i];		thisCSDVal *= (100.0 / numXls);		meanCSD.Update(i, thisCSDVal);	}	SaveCSD(meanCSD, kMeanCumCSD);}#include <LString.h>#include <string.h>// ---------------------------------------------------------------------------------//		¥ SaveCSD// ---------------------------------------------------------------------------------voidCReduceApp::SaveCSD(CFloatArray &inCSD, short inCSDKind, float binSize){	FSSpec theSpec;	mInputFile->GetSpecifier(theSpec);	PP::LStr255 newName = MakeCSDFileName(theSpec.name, inCSDKind);		FSSpec outSpec;	outSpec.vRefNum = (mInputFile->GetSpec()).vRefNum;	outSpec.parID = (mInputFile->GetSpec()).parID;	PP::LString::CopyPStr(newName, outSpec.name, sizeof(Str63));		mCSDOutputFile = new myLFileStream(outSpec);	switch (inCSDKind) {		case kReduce:			mCSDOutputFile->CreateNewDataFile(GraphCFsFileCreator, 'TEXT');		break;		default:			mCSDOutputFile->CreateNewDataFile(CW_fileCreator, 'TEXT');		break;	}	mCSDOutputFile->OpenDataFork(fsRdWrPerm);	WriteCSD(inCSD, inCSDKind, binSize);	mCSDOutputFile->CloseDataFork();	delete mCSDOutputFile;	mCSDOutputFile = nil;}#include <string.h>// ---------------------------------------------------------------------------------//		¥ MakeCSDFileName// ---------------------------------------------------------------------------------PP::LStr255CReduceApp::MakeCSDFileName(Str63 inOldName, short inCSDKind){	static PP::LStr255 outName;	PP::LStr255 tryStr;	PP::TString<Str63> tempStr;	PP::TString<Str63> newName;	UInt8 suffix = NULL;	Boolean goodName = true;	short tryNumber = 0;	static Boolean alreadyShownAlert = false;		tempStr = inOldName;	newName = tempStr;	suffix = newName.ReverseFind(".int", 4);	if (suffix == NULL)		suffix = newName.ReverseFind(".Int", 4);	if (suffix == NULL)		suffix = newName.ReverseFind(".INT", 4);	if (suffix != NULL) {		newName.Remove(suffix, newName.Length());	}	if (newName.Length() > (31-5)) {		if (!alreadyShownAlert) {			ErrorAlert theAlert("\pName Too Long", "\pYour integrate file's name is too long to use as a root for the save files.  The name will be truncated.", 0.1);			alreadyShownAlert = true;		}		newName.Remove(27, newName.Length());	// Truncate to 26 chars	}	do {		switch (inCSDKind) {			case kMeanCumCSD:				if (newName.Length() < 24)					newName.Append(".MeanCSD", 8);				else					newName.Append(".CSD1", 5);			break;			case kMaxCumCSD:				if (newName.Length() < 25)					newName.Append(".MaxCSD", 7);				else					newName.Append(".CSD2", 4);			break;			case kLogCSD:				if (newName.Length() < 25)					newName.Append(".LogCSD", 7);				else					newName.Append(".CSD3", 5);			break;			case kNNCSD:				if (newName.Length() < 26)					newName.Append(".NNCSD", 6);				else					newName.Append(".CSD5", 5);			break;			case kRegCSD:				if (newName.Length() < 25)					newName.Append(".RegCSD", 7);				else					newName.Append(".CSD4", 5);			break;			case kRedStats:				if (newName.Length() < 21)					newName.Append(".MeanCSD", 11);				else					newName.Append(".R3ST", 5);			break;			case kReduce:				if (newName.Length() < 23)					newName.Append(".Reduce3D", 9);				else					newName.Append(".RED3", 5);			break;			case kEnvelope:				if (newName.Length() < 23)					newName.Append(".Envelope", 9);				else					newName.Append(".ENV", 4);			break;			case kIntegrate:				if (newName.Length() < 26)					newName.Append(".Shave", 6);				else					newName.Append(".SHAV", 5);			break;		}		FSSpec tempSpec;		::FSMakeFSSpec((mInputFile->GetSpec()).vRefNum, (mInputFile->GetSpec()).parID, newName, &tempSpec);		if (myLFileStream::FileExists(tempSpec) || (mPrefs->doShave && tryNumber == 0)) { 			tryNumber++;			tryStr.Assign((SInt32)tryNumber);			tryStr = "\p." + tryStr;			newName.Remove(newName.ReverseFind('.'), 63);	// remove whatever suffix we'd appended			if (tryNumber > 1)	// if this is the second time through here				newName.Remove(newName.ReverseFind('.'), 63);	// then we need to remove the try number string we added last time			short overage;			if ((overage = newName.Length() + tryStr.Length() - (31-5)) > 0)	// truncate base to make room for try number string				newName.Remove(newName.Length() + 1 - overage, 63);			newName += tryStr;			goodName = false;		} else {			goodName = true;		}	} while (!goodName);	outName = newName;	return outName;}#include <stdio.h>// ---------------------------------------------------------------------------------//		¥ WriteCSD// ---------------------------------------------------------------------------------voidCReduceApp::WriteCSD(CFloatArray &inCSD, short inCSDKind, float binSize){	char	theStr[kStdStringSize];	char	theTitleStr[kStdStringSize];	short	numBins;//, numClasses;	float	cumPct;	short	i;		switch (inCSDKind) {		case kMeanCumCSD:			mCSDOutputFile->putOneLine("Mean Cumulative CSD (CSD1); Reduce3D 2.2\n");			sprintf(theTitleStr, "Mean (x%3.2f) normalized size distribution data\n", mPrefs->maxValueMeanCSD);//			numBins =  mPrefs->numClassesMeanCSD;//			numClasses = mPrefs->numClassesMeanCSD;		break;		case kMaxCumCSD:			mCSDOutputFile->putOneLine("Max Cumulative CSD (CSD2); Reduce3D 2.2\n");			sprintf(theTitleStr, "Max normalized size distribution data\n");//			numBins = mPrefs->numClassesMaxCSD;//			numClasses = mPrefs->numClassesMaxCSD;		break;		case kLogCSD:			mCSDOutputFile->putOneLine("Log CSD (CSD3); Reduce3D 2.2\n");			sprintf(theTitleStr, "Logarithmic size distribution data\n");//			numBins = mPrefs->numClassesLogCSD;//			numClasses = mPrefs->numClassesLogCSD;		break;		case kNNCSD:			mCSDOutputFile->putOneLine("Nearest-Neighbor CSD (CSD5); Reduce3D 2.2\n");			sprintf(theTitleStr, "Nearest-neighbor size distribution data\n");//			numBins = kNumBinsNNCSD;//			numClasses = mPrefs->numClassesMeanCSD;		break;		case kRegCSD:			mCSDOutputFile->putOneLine("Regular CSD (CSD4); Reduce3D 2.2\n");			sprintf(theTitleStr, "Regular size distribution data, delta L = %3.3f cm\n", mPrefs->deltaLRegCSD);//			numBins = kNumBinsRegCSD;//			numClasses = mPrefs->numClassesMaxCSD;		break;		case kRedStats:			WriteRedStatsFile();		break;		case kReduce:			WriteReduceFile();		break;		case kIntegrate:			WriteIntFile();		break;	}	if (inCSDKind != kRedStats && inCSDKind != kReduce && inCSDKind != kIntegrate) {		numBins = inCSD.GetCount();		mCSDOutputFile->putOneLine(mTheXls->GetIntComment());		mCSDOutputFile->putOneLine("\n");//		sprintf(theStr, "%s\n", mTheXls->GetIntComment());//		mCSDOutputFile->putOneLine(theStr);		if (inCSDKind == kNNCSD) {			sprintf(theStr, "Number of valid crystals:\t%hi\n", mStats->numNNRad);			mCSDOutputFile->putOneLine(theStr);			sprintf(theStr, "Mean nearest neighbor size:\t%f\n", mStats->meanNNRad);			mCSDOutputFile->putOneLine(theStr);		} else {			sprintf(theStr, "Number of positive crystals:\t%hi\n", mStats->totalPosXls);			mCSDOutputFile->putOneLine(theStr);		}		mCSDOutputFile->putOneLine(theTitleStr);//		sprintf(theStr, "Number of size classes:  %5hi\n", numClasses);//		mCSDOutputFile->putOneLine(theStr);		switch (inCSDKind) {			case kMeanCumCSD:			case kMaxCumCSD:				mCSDOutputFile->putOneLine("bin\tcum\tnoncum\n");			break;			case kLogCSD:			case kNNCSD:			case kRegCSD:				mCSDOutputFile->putOneLine("bin\tpercent\n");			break;		}		cumPct = 0.0;		for (i=1; i <= numBins; i++) {			cumPct += inCSD[i];			switch (inCSDKind) {				case kMeanCumCSD:				case kMaxCumCSD:					sprintf(theStr, "%10.5f\t%10.5f\t%10.5f\n",  (1.0 * i / numBins), cumPct, inCSD[i]);					mCSDOutputFile->putOneLine(theStr);				break;				case kLogCSD:					sprintf(theStr, "%10.5f\t%10.5f\n",  (1.0 * i / numBins), inCSD[i]);					mCSDOutputFile->putOneLine(theStr);				break;				case kNNCSD:				case kRegCSD:					sprintf(theStr, "%10.5f\t%10.5f\n", (i * binSize), inCSD[i]);					mCSDOutputFile->putOneLine(theStr);				break;			}		}	}}// ---------------------------------------------------------------------------//		¥ DoMaxCumCSD// ---------------------------------------------------------------------------voidCReduceApp::DoMaxCumCSD(){	float		rad, maxRad;	CFloatArray	maxCSD;	float		thisCSDVal;	short		i, index;	rad = 0.0;	// temp use of rad	for (i=1; i<= mPrefs->numClassesMaxCSD; i++) {		maxCSD.Push(&rad);	}	maxRad = CubeRoot(3.0 * mStats->maxActV / (4.0 * gPI));	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {//			rad = CubeRoot(3.0 * (*mTheXls)[i].actV / (4.0 * gPI));			rad = thisXl->r;	// uses extV instead of actV 			index = mPrefs->numClassesMaxCSD - trunc((rad / mStats->maxR) *					(mPrefs->numClassesMaxCSD - 0.0001));			if (index < 1)				index = 1;			maxCSD.Update(index, (maxCSD[index] + 1));		}	}	mTheXls->Unlock();		for (i=1; i <= mPrefs->numClassesMaxCSD; i++) {	// convert to percent 		thisCSDVal = maxCSD[i];		thisCSDVal *= (100.0 / mStats->numCrystals);		maxCSD.Update(i, thisCSDVal);	}	SaveCSD(maxCSD, kMaxCumCSD);}// ---------------------------------------------------------------------------//		¥ DoLogCsd// ---------------------------------------------------------------------------voidCReduceApp::DoLogCsd(){	float	rad, maxRad;	CFloatArray	logCSD, tempCSD;	short	i, index;	float	binWidth, avgSlope, slope1, slope2;	rad = 0.0;	// temp use of rad	for (i=1; i<= mPrefs->numClassesLogCSD; i++) {		logCSD.Push(&rad);		tempCSD.Push(&rad);	}	maxRad = CubeRoot(3.0 * mStats->maxActV / (4.0 * gPI));			// allocate crystals to bins 	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {//			rad = CubeRoot(3.0 * (*mTheXls)[i].actV / (4.0 * gPI));			rad = thisXl->r;	// uses extV instead of actV 			index = 1 + trunc((rad / mStats->maxR) * (mPrefs->numClassesLogCSD - 0.0001));			if (index < 1)				index = 1;			tempCSD.Update(index, (tempCSD[index] + 1));		}	}	mTheXls->Unlock();			// convert to cumulate totals 	for (i=2; i <= mPrefs->numClassesLogCSD; i++) {	// convert to percent		tempCSD.Update(i, (tempCSD[i] + tempCSD[i-1]));	}			// normalize to unit volume 	for (i=1; i <= mPrefs->numClassesLogCSD; i++) {	// convert to percent 		tempCSD.Update(i, (tempCSD[i] / mStats->BBVolume));	}			// convert to logarithms of slopes of cumulate curves 	binWidth = mStats->maxR / mPrefs->numClassesLogCSD;	avgSlope = (tempCSD[2] - tempCSD[1]) / binWidth;	if (avgSlope > 0)		logCSD.Update(1, log(avgSlope));	else		logCSD.Update(1, 0.0);		avgSlope = (tempCSD[mPrefs->numClassesLogCSD] - tempCSD[mPrefs->numClassesLogCSD - 1]) / binWidth;	if (avgSlope > 0)		logCSD.Update(mPrefs->numClassesLogCSD, log(avgSlope));	else		logCSD.Update(mPrefs->numClassesLogCSD, 0.0);	for (i=2; i <= mPrefs->numClassesLogCSD-1; i++) {		slope1 = (tempCSD[i] - tempCSD[i-1]) / binWidth;		slope2 = (tempCSD[i+1] - tempCSD[i]) / binWidth;		avgSlope = (slope1 + slope2) / 2.0;		if (avgSlope > 0)			logCSD.Update(i, log(avgSlope));		else			logCSD.Update(i, 0.0);	}		SaveCSD(logCSD, kLogCSD);}// ---------------------------------------------------------------------------//		¥ DoNNCSD// ---------------------------------------------------------------------------voidCReduceApp::DoNNCSD(){	CFloatArray	NNCSD;	short		i, index;	Boolean		overstepCSD;	long		numXls=0;	overstepCSD = false;		float maxNNRad = mStats->maxNNRad;	float binSize = maxNNRad / kNumBinsNNCSD;	float dummy = 0.0;	for (i=1; i<=kNumBinsNNCSD; i++) {		NNCSD.Push(&dummy);	}	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		Crystal *neighborXl = (Crystal *) mTheXls->GetItemPtr(thisXl->neighbor);		if ((thisXl->r > 0) && (thisXl->neighbor > 0)) {			index = trunc(neighborXl->r / binSize) + 1;			if (index > kNumBinsNNCSD) {				index = kNumBinsNNCSD;				overstepCSD = true;			}			numXls++;			NNCSD.Update(index, (NNCSD[index] + 1));		}	}	mTheXls->Unlock();		for (i=1; i <= kNumBinsNNCSD; i++) {	// convert to percent //		NNCSD.Update(i, NNCSD[i] * 100.0 * NNCSD[i] / mStats->numNNRad);		NNCSD.Update(i, NNCSD[i] * 100.0 / numXls);	}	SaveCSD(NNCSD, kNNCSD, binSize);}// ---------------------------------------------------------------------------//		¥ DoRegCSD// ---------------------------------------------------------------------------voidCReduceApp::DoRegCSD(){	CFloatArray	regCSD;	short		i, index;	Boolean		overstepCSD;	long		numXls=0;	overstepCSD = false;		float dummy = 0.0;	for (i=1; i<=kNumBinsRegCSD; i++) {		regCSD.Push(&dummy);	}	float maxRad = mStats->maxR;	float binSize = maxRad / kNumBinsRegCSD;	mTheXls->Lock();	for (i=1; i <= mTheXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);		if (thisXl->r > 0) {			index = trunc(thisXl->r / binSize) + 1;	// CFloatArray is 1-based			if (index > kNumBinsRegCSD) {				index = kNumBinsRegCSD;				overstepCSD = true;			}			numXls++;			regCSD.Update(index, (regCSD[index] + 1));		}	}//	for (i=1; i <= mTheXls->GetCount(); i++) {//		Crystal *thisXl = (Crystal *) mTheXls->GetItemPtr(i);//		if (thisXl->r > 0) {//			index = trunc(thisXl->r / mPrefs->deltaLRegCSD) + 1;//			if (index > kNumBinsRegCSD) {//				index = kNumBinsRegCSD;//				overstepCSD = true;//			}//			numXls++;//			regCSD.Update(index, (regCSD[index] + 1));//		}//	}	mTheXls->Unlock();		for (i=1; i <= kNumBinsRegCSD; i++) {	// convert to percent 		regCSD.Update(i, regCSD[i] * (100.0 / numXls));	}	SaveCSD(regCSD, kRegCSD, binSize);}// ---------------------------------------------------------------------------//		¥ DoReduce3DFile// ---------------------------------------------------------------------------voidCReduceApp::DoReduce3DFile(){	CFloatArray	regCSD;		SaveCSD(regCSD, kReduce);}// ---------------------------------------------------------------------------//		¥ DoRedStatsFile// ---------------------------------------------------------------------------voidCReduceApp::DoRedStatsFile(){	CFloatArray	regCSD;		SaveCSD(regCSD, kRedStats);}// ---------------------------------------------------------------------------//		¥ WriteRedStatsFile// ---------------------------------------------------------------------------voidCReduceApp::WriteRedStatsFile(){	ErrorAlert theAlert("\pObsolete", "\pAttempt to call obsolete function: WriteRedStatsFile.  Data will be written, but not complete.");	char	theStr[kStdStringSize];	short	i;		sprintf(theStr, "%s\n", (mCSDOutputFile->GetSpec()).name);	mCSDOutputFile->putOneLine(theStr);// write identifier for file type	mCSDOutputFile->putOneLine("Reduce3D 2.2\n");// write number of crystals	sprintf(theStr, "%5hi\n", mStats->numCrystals);	mCSDOutputFile->putOneLine(theStr);// write total area or volume	sprintf(theStr, "%10.5f\n", mStats->BBVolume);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->surfaceArea);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->surfaceToVolRatio);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->xlVolFraction);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->xlDensity);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for radius	sprintf(theStr, "%10.5f\n", mStats->minR);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxR);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanR);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdRadius);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->skewness);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->kurtosis);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for extended volume	sprintf(theStr, "%10.5f\n", mStats->minExtV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxExtV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanExtV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdExtVol);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for actual volume	sprintf(theStr, "%10.5f\n", mStats->minActV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxActV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanActV);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdActVol);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->numEngulfed);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for nearest-neighbor distance	sprintf(theStr, "%10.5f\n", mStats->minSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->maxSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->meanSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdSep);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->numSep);	mCSDOutputFile->putOneLine(theStr);// write ordering index	sprintf(theStr, "%10.5f\n", mStats->orderingIndex);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->orderingTTest);	mCSDOutputFile->putOneLine(theStr);// write "isolation index" stats	sprintf(theStr, "%10.5f\n", mStats->meanNNRad);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->esdNNRad);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->numNNRad);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->isolationIndex);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->isolationTTest);	mCSDOutputFile->putOneLine(theStr);// write quadrat stat// WriteLn(outputFile, 'Quadrat stat mean:       ', quadratStatMean : 10 : 5);// WriteLn(outputFile, 'Quadrat stat esd:        ', quadratStatEsd : 10 : 5);	sprintf(theStr, "n/c\n");	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "n/c\n");	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->circQuadratStatMean);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->circQuadratStatEsd);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%5hi\n", mStats->quadratStatDOF);	mCSDOutputFile->putOneLine(theStr);// write random point stat	sprintf(theStr, "%10.5f\n", mStats->RPStatMean);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->RPStatEsd);	mCSDOutputFile->putOneLine(theStr);// write Avrami test parameters// fixif ((mStats->fileType != kDiffSimulation) || mPrefs->doImpingement) {		sprintf(theStr, "%10.5f\n", mStats->actualVol);		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "%10.5f\n", mStats->extendedVol);		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "%10.5f\n", mStats->extendedVolRand);		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "%10.5f\n", mStats->avramiRatio);		mCSDOutputFile->putOneLine(theStr);	} else {		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "n/c\n");		mCSDOutputFile->putOneLine(theStr);	}// write new stats, deciles	sprintf(theStr, "%10.5f\n", mStats->myStat1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%10.5f\n", mStats->myStat2);	mCSDOutputFile->putOneLine(theStr);	for (i = 1; i <= 9; i++) {		sprintf(theStr, "%10.5f\n", mStats->deciles[i]);		mCSDOutputFile->putOneLine(theStr);	}	for (i = 1; i <= mStats->numLPoints; i++) {		// write h Distances		sprintf(theStr, "%10.5f\n", mStats->hDistances[i]);		mCSDOutputFile->putOneLine(theStr);	}	for (i = 1; i <= mStats->numLPoints; i++) {		// write K values		sprintf(theStr, "%10.5f\n", mStats->LValues[i]);		mCSDOutputFile->putOneLine(theStr);	}}// ---------------------------------------------------------------------------//		¥ WriteIntFile// ---------------------------------------------------------------------------voidCReduceApp::WriteIntFile(short inEnvRun, float inOldMeanR, float inNewMeanR){	PP::LStr255	firstLine("Reduce3D 2.3 ||");	mProgress->SetTitle("\pOutput Progress");	if (inEnvRun == -1) {		mProgress->SetActionDescriptor("\pWriting Integrate File");	// write identifier for file type		if (mPrefs->doShave) {			firstLine = TrimNL(firstLine) + "\pShaved "						+ FltStr(mShaveIteration * mPrefs->shaveIncrement, 2)						+ "\p%, ";			if (mPrefs->keepAspectRatios) {				firstLine += "\pkeeping AR,";			} else switch (mPrefs->shaveXYZ) {				case kX: firstLine += "\pin X, "; break;				case kY: firstLine += "\pin Y, "; break;				case kZ: firstLine += "\pin Z, "; break;			}			switch (mPrefs->direction) {				case kFromMax: firstLine += "\pfrom lg.values"; break;				case kSymmetric: firstLine += "\pfrom outside"; break;				case kFromMin: firstLine += "\pfrom sm.values"; break;			}		}	} else {		mProgress->SetActionDescriptor("\pWriting Envelope File");	// write identifier for envelope file		firstLine += "\p Envelope Output; Run number ";		firstLine += (PP::LStr255) (SInt32) inEnvRun;		firstLine += "\p; Original Mean Radius = ";		firstLine += FltStr(inOldMeanR, 5);		firstLine += "\p; New Mean Radius = ";		firstLine += FltStr(inNewMeanR, 5);	}	firstLine += "\p\n";	mCSDOutputFile->putOneLine(firstLine);	CrystalArray *curXls = mBBox->GetXls();// write incoming comment line	PP::LStr255 theStr(curXls->GetIntComment());	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write NumXls line	theStr = "\pNumber of crystals:\t" + (PP::LStr255)(SInt32)curXls->GetCount() + "\p\n";	mCSDOutputFile->putOneLine(theStr);// write Volume line	theStr = "\pTotal volume:\t" + FltStr(mBBox->Volume(), 5) + "\p\n";	mCSDOutputFile->putOneLine(theStr);// write Bounds line	if ((mBBox->GetType() == kRPBox) || (mBBox->GetType() == kCubeBox)) {		theStr = "\pBounds:\t";		Point3DFloat lower, upper;		lower = (mBBox->GetXls())->LowerBound();		upper = (mBBox->GetXls())->UpperBound();		theStr += FltStr(lower.x, 3);		theStr += '\t';		theStr += FltStr(lower.y, 3);		theStr += '\t';		theStr += FltStr(lower.y, 3);		theStr += '\t';		theStr += FltStr(upper.x, 3);		theStr += '\t';		theStr += FltStr(upper.y, 3);		theStr += '\t';		theStr += FltStr(upper.z, 3);		theStr += '\n';		mCSDOutputFile->putOneLine(theStr);	}// write Xl data	mProgress->SetValues(1,curXls->GetCount(),1);	mProgress->Show();	Crystal thisXl;	for (short i = 1; i <= curXls->GetCount(); i++) {		mProgress->Progress(i);		curXls->FetchItemAt(i, &thisXl);		theStr = (PP::LStr255)(SInt32)i + "\p\t" + FltStr(thisXl.ctr.x, 5) +			+ "\p\t" + FltStr(thisXl.ctr.y, 5) + "\p\t" + FltStr(thisXl.ctr.z, 5)			+ "\p\t" + FltStr(thisXl.r, 5) + "\p\t" + (PP::LStr255)(SInt32) thisXl.ctrSlice			+ "\p\t" + (PP::LStr255)(SInt32) thisXl.ctrID + "\p\n";		mCSDOutputFile->putOneLine(theStr);	}	mProgress->Hide();}// ---------------------------------------------------------------------------//		¥ WritePrefsSettings// ---------------------------------------------------------------------------voidCReduceApp::WritePrefsSettings(){	PP::LStr255	theStr;	theStr = "\pincludeMeanCSD: ";	theStr += mPrefs->includeMeanCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pincludeMaxCSD: ";	theStr += mPrefs->includeMaxCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pincludeLogCSD: ";	theStr += mPrefs->includeLogCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pincludeRegCSD: ";	theStr += mPrefs->includeRegCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoQuadrat: ";	theStr += mPrefs->doQuadrat;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoOthers: ";	theStr += mPrefs->doOthers;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoRandomPt: ";	theStr += mPrefs->doRandomPt;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmake3DModel: ";	theStr += mPrefs->make3DModel;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputSigmas: ";	theStr += mPrefs->outputSigmas;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputCrystals: ";	theStr += mPrefs->outputCrystals;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputR3STT: ";	theStr += mPrefs->outputR3STT;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poutputReduce: ";	theStr += mPrefs->outputReduce;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoImpingement: ";	theStr += mPrefs->doImpingement;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumClassesMeanCSD: ";	theStr += mPrefs->numClassesMeanCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumClassesMaxCSD: ";	theStr += mPrefs->numClassesMaxCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumClassesLogCSD: ";	theStr += mPrefs->numClassesLogCSD;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pquadratNumPlacings: ";	theStr += mPrefs->quadratNumPlacings;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pquadratNumReps: ";	theStr += mPrefs->quadratNumReps;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pRPNumPlacings: ";	theStr += mPrefs->RPNumPlacings;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pRPNumReps: ";	theStr += mPrefs->RPNumReps;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmaxValueMeanCSD: ";	theStr += FltStr(mPrefs->maxValueMeanCSD, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdeltaLRegCSD: ";	theStr += FltStr(mPrefs->deltaLRegCSD, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pimpingementMeanErr: ";	theStr += FltStr(mPrefs->impingementMeanErr, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pimpingementMaxErr: ";	theStr += FltStr(mPrefs->impingementMaxErr, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdoLMcfPcf: ";	theStr += mPrefs->doLMcfPcf;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumNNDist: ";	theStr += mPrefs->numNNDist;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumCFOffsetVolPts: ";	theStr += mPrefs->numCFOffsetVolPts;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pEpanecnikovCVal: ";	theStr += FltStr(mPrefs->EpanecnikovCVal, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumQD3DEqPts: ";	theStr += mPrefs->numQD3DEqPts;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumQD3DLngPts: ";	theStr += mPrefs->numQD3DLngPts;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\psampleShape: ";	theStr += mPrefs->sampleShape;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pnumEnvelopeRuns: ";	theStr += mPrefs->numEnvelopeRuns;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pgreediness: ";	theStr += mPrefs->greediness;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pinflateBBox: ";	theStr += mPrefs->inflateBBox;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pobservabilityFilter: ";	theStr += mPrefs->observabilityFilter;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pcrit1Factor: ";	theStr += FltStr(mPrefs->crit1Factor, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pcrit2Factor: ";	theStr += FltStr(mPrefs->crit2Factor, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	if (mPrefs->doShave) {		theStr = TrimNL(theStr) + "\pShaved "					+ FltStr(mShaveIteration * mPrefs->shaveIncrement, 2)					+ "\p%, ";		if (mPrefs->keepAspectRatios) {			theStr += "\pkeeping AR,";		} else switch (mPrefs->shaveXYZ) {			case kX: theStr += "\pin X, "; break;			case kY: theStr += "\pin Y, "; break;			case kZ: theStr += "\pin Z, "; break;		}		switch (mPrefs->direction) {			case kFromMax: theStr += "\pfrom lg.values\n"; break;			case kSymmetric: theStr += "\pfrom outside\n"; break;			case kFromMin: theStr += "\pfrom sm.values\n"; break;		}	} else {		theStr = "\pNot shaved\n";	}	mCSDOutputFile->putOneLine(theStr);//	theStr = "\pdoShave";//	theStr += mPrefs->doShave;//	theStr += "\p\n";//	theStr = "\pkeepAspectRatios";//	theStr += mPrefs->keepAspectRatios;//	theStr += "\p\n";//	theStr = "\pshaveXYZ";//	theStr += mPrefs->shaveXYZ;//	theStr += "\p\n";//	theStr = "\pshaveIncrement";//	theStr += mPrefs->shaveIncrement;//	theStr += "\p\n";//	theStr = "\pdirection";//	theStr += mPrefs->direction;//	theStr += "\p\n";	theStr = "\pminPercent: ";	theStr += FltStr(mPrefs->minPercent, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pminPopulation: ";	theStr += mPrefs->minPopulation;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmaxAspectRatio: ";	theStr += FltStr(mPrefs->maxAspectRatio, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\psmaller: ";	theStr += mPrefs->smaller;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pShaveSave: ";	theStr += mPrefs->ShaveSave;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pdiscardNegs: ";	theStr += mPrefs->discardNegs;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\puseRaeburn: ";	theStr += mPrefs->useRaeburn;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pconfidence: ";	theStr += mPrefs->confidence;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pseed: ";	theStr += mPrefs->seed;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMCReps: ";	theStr += mPrefs->MCReps;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\ptidyUp: ";	theStr += mPrefs->tidyUp;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\puseVolume: ";	theStr += mPrefs->useVolume;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\poverlap: ";	theStr += mPrefs->overlap;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmatchVF: ";	theStr += mPrefs->matchVF;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmakeDCEnv: ";	theStr += mPrefs->makeDCEnv;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pverbose: ";	theStr += mPrefs->verbose;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pVFPercent: ";	theStr += FltStr(mPrefs->VFPercent, 3);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pmatchPDF: ";	theStr += mPrefs->matchPDF;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);}// ---------------------------------------------------------------------------//		¥ WriteReduceFile// ---------------------------------------------------------------------------voidCReduceApp::WriteReduceFile(){//	char	theStr[kStdStringSize];	Str63	tempStr;	short	i;	Crystal	thisXl;	PP::LStr255	theStr;	theStr = (mInputFile->GetSpec()).name;	theStr += "\n";	mCSDOutputFile->putOneLine(theStr);// write identifier for file type	theStr = "\pReduce3D ";	theStr += mPrefsHolder->GetVersStr();	theStr += "\n";	mCSDOutputFile->putOneLine(theStr);// write incoming comment line	PP::LStr255 commentStr(mTheXls->GetIntComment());	commentStr += "\p\n";	mCSDOutputFile->putOneLine(commentStr);// write our processing params	mCSDOutputFile->putOneLine("\pProcessing Parameters:\n");	WritePrefsSettings();// write holes file reference	if (mHolesFile != nil) {		FSSpec theSpec;		theSpec = mHolesFile->GetSpec();		theStr = "\pHoles File: ";		theStr += theSpec.name;		theStr += "\p\n";	} else {		theStr = "Holes File: none\n";	}	mCSDOutputFile->putOneLine(theStr);// write number of crystals	theStr = "\pNumber of crystals:\t";	theStr += mStats->numCrystals;	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	// write total area or volume	theStr = "\pTotal Volume (cubic cm):\t";	theStr += FltStr(mStats->BBVolume, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSurface Area (sq cm):\t";	theStr += FltStr(mStats->surfaceArea, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSurface to Volume Ratio:\t";	theStr += FltStr(mStats->surfaceToVolRatio, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal Volume Fraction:\t";	theStr += FltStr(mStats->xlVolFraction, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal density:\t";	theStr += FltStr(mStats->xlDensity, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal intensity:\t";	theStr += FltStr(mStats->intensity, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal Intensity Sqd:\t";	theStr += FltStr(mStats->intensitySqd, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCrystal Volume Fraction (MC Method):\t";	theStr += FltStr(mStats->volFrxn, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for radius	theStr = "\pMinimum radius:\t";	theStr += FltStr(mStats->minR, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum radius:\t";	theStr += FltStr(mStats->maxR, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean radius:\t";	theStr += FltStr(mStats->meanR, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltStr(mStats->esdRadius, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSkewness:\t";	theStr += FltStr(mStats->skewness, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pExcess Kurtosis:\t";	theStr += FltStr(mStats->kurtosis, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for extended volume	theStr = "\pMinimum ext volume:\t";	theStr += FltStr(mStats->minExtV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum ext volume:\t";	theStr += FltStr(mStats->maxExtV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr += FltStr(mStats->meanExtV, 5);	theStr = (mPrefs->outputSigmas ? "\p\tEnv Mean:\t" : "\p\tEnv Min:\t");	theStr += FltStr((mPrefs->outputSigmas ? mStats->MeanEVEnvMean : mStats->MeanEVEnvMin), 5);	theStr = (mPrefs->outputSigmas ? "\p\tEnv SD:\t" : "\p\tEnv Max:\t");	theStr += FltStr((mPrefs->outputSigmas ? mStats->MeanEVEnvStdDev : mStats->MeanEVEnvMax), 5);	theStr += "\p\n";	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Mean ext volume:", mStats->meanExtV, mStats->MeanEVEnvMean, mStats->MeanEVEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Mean ext volume:", mStats->meanExtV, mStats->MeanEVEnvMin, mStats->MeanEVEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltStr(mStats->esdExtVol, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for actual volume	theStr = "\pMinimum act volume:\t";	theStr += FltStr(mStats->minActV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum act volume:\t";	theStr += FltStr(mStats->maxActV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMean act volume:\t";	theStr += FltStr(mStats->meanActV, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltStr(mStats->esdActVol, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Num engulfed crystals:", mStats->numEngulfed);	mCSDOutputFile->putOneLine(theStr);// write min, max, mean and esd for nearest-neighbor distance	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Minimum separation:", mStats->minSep, mStats->MinSepEnvMean, mStats->MinSepEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Minimum separation:", mStats->minSep, mStats->MinSepEnvMin, mStats->MinSepEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pMaximum separation:\t";	theStr += FltStr(mStats->maxSep, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Mean separation:", mStats->meanSep, mStats->MeanSepEnvMean, mStats->MeanSepEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Mean separation:", mStats->meanSep, mStats->MeanSepEnvMin, mStats->MeanSepEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pStd deviation:\t";	theStr += FltStr(mStats->esdSep, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Num valid crystals:", mStats->numSep);	mCSDOutputFile->putOneLine(theStr);// write ordering index	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Ordering index:", mStats->orderingIndex, mStats->OIEnvMean, mStats->OIEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Ordering index:", mStats->orderingIndex, mStats->OIEnvMin, mStats->OIEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pOrdering index t-test:\t";	theStr += FltStr(mStats->orderingTTest, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write "isolation index" stats	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Mean NN radius:", mStats->meanNNRad, mStats->MeanNNEnvMean, mStats->MeanNNEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Mean NN radius:", mStats->meanNNRad, mStats->MeanNNEnvMin, mStats->MeanNNEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pEsd NN radius:\t";	theStr += FltStr(mStats->esdNNRad, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Num valid pairs:", mStats->numNNRad);	mCSDOutputFile->putOneLine(theStr);	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Isolation index:", mStats->isolationIndex, mStats->IIEnvMean, mStats->IIEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Isolation index:", mStats->isolationIndex, mStats->IIEnvMin, mStats->IIEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pIsolation index t-test:\t";	theStr += FltStr(mStats->isolationTTest, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write quadrat stat// WriteLn(outputFile, 'Quadrat stat mean:       ', quadratStatMean : 10 : 5);// WriteLn(outputFile, 'Quadrat stat esd:        ', quadratStatEsd : 10 : 5);	sprintf(theStr, "%s\t%10s\n", "Quadrat stat mean:", "n/c");	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%10s\n", "Quadrat stat esd:", "n/c");	mCSDOutputFile->putOneLine(theStr);	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Spherical quad stat mean:", mStats->circQuadratStatMean, mStats->CQSMEnvMean, mStats->CQSMEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Spherical quad stat mean:", mStats->circQuadratStatMean, mStats->CQSMEnvMin, mStats->CQSMEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pSpherical quad stat esd:\t";	theStr += FltStr(mStats->circQuadratStatEsd, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Quadrat stat d.o.f:", mStats->quadratStatDOF);	mCSDOutputFile->putOneLine(theStr);// write random point stat	if (mPrefs->outputSigmas)		sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",			"Random point stat mean:", mStats->RPStatMean, mStats->RPSMEnvMean, mStats->RPSMEnvStdDev);	else		sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",			"Random point stat mean:", mStats->RPStatMean, mStats->RPSMEnvMin, mStats->RPSMEnvMax);	mCSDOutputFile->putOneLine(theStr);	theStr = "\pRandom point std dev:\t";	theStr += FltStr(mStats->RPStatEsd, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);// write Avrami test parameters// fixif ((mStats->fileType != kDiffSimulation) || mPrefs->doImpingement) {		theStr = "\pAvrami act vol:\t";		theStr += FltStr(mStats->actualVol, 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);		theStr = "\pAvrami ext vol:\t";		theStr += FltStr(mStats->extendedVol, 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);		theStr = "\pAvrami ext vol rand:\t";		theStr += FltStr(mStats->extendedVolRand, 5);		theStr += "\p\n";		mCSDOutputFile->putOneLine(theStr);		if (mPrefs->outputSigmas)			sprintf(theStr, "%s\t%10.5f\tEnvMean:\t%10.5f\tEnvSD:\t%10.5f\n",				"Avrami ratio:", mStats->avramiRatio, mStats->AREnvMean, mStats->AREnvStdDev);		else			sprintf(theStr, "%s\t%10.5f\tEnvMin:\t%10.5f\tEnvMax:\t%10.5f\n",				"Avrami ratio:", mStats->avramiRatio, mStats->AREnvMin, mStats->AREnvMax);		mCSDOutputFile->putOneLine(theStr);	} else {		sprintf(theStr, "Avrami act vol:\tn/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "Avrami ext vol:\tn/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "Avrami ext vol rand:\tn/c\n");		mCSDOutputFile->putOneLine(theStr);		sprintf(theStr, "Avrami ratio:\tn/c\n");		mCSDOutputFile->putOneLine(theStr);	}// write new stats, deciles	theStr = "\pCSD shape stat 1 (skew):\t";	theStr += FltStr(mStats->myStat1, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	theStr = "\pCSD shape stat 2 (flat):\t";	theStr += FltStr(mStats->myStat2, 5);	theStr += "\p\n";	mCSDOutputFile->putOneLine(theStr);	mCSDOutputFile->putOneLine("Decile#\tDecile value\n");	for (i = 1; i <= 9; i++) {		sprintf(theStr, "%hi\t%10.5f\n", i, mStats->deciles[i]);		mCSDOutputFile->putOneLine(theStr);	}// write out run parameters	sprintf(theStr, "%s\t%5hi\n", "Mean CSD/Num Classes:", mPrefs->includeMeanCSD ? mPrefs->numClassesMeanCSD : -1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Mean CSD/Max Val:", mPrefs->includeMeanCSD ? mPrefs->maxValueMeanCSD : -1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Max CSD/Num Classes:", mPrefs->includeMaxCSD ? mPrefs->numClassesMaxCSD : -1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Log CSD/Num Classes:", mPrefs->includeLogCSD ? mPrefs->numClassesLogCSD : -1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%10.5f\n", "Reg CSD/Delta L:", mPrefs->includeRegCSD ? mPrefs->deltaLRegCSD : -1.0);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%10.5f\n", "Impingement Correction/Mean Err:", mPrefs->doImpingement ? mPrefs->impingementMeanErr : -1.0);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%10.5f\n", "Impingement Correction/Max Err:", mPrefs->doImpingement ? mPrefs->impingementMaxErr : -1.0);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Number of runs to calculate boundary envelopes:", mPrefs->numEnvelopeRuns);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%5hi\n", "Num points in Offset Interesction Volume Monte Carlo:", mPrefs->doLMcfPcf ? mPrefs->numCFOffsetVolPts : -1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%10.5f\n", "C value for Epanecnikov kernel bandwidth calc:", mPrefs->doLMcfPcf ? mPrefs->EpanecnikovCVal : -1);	mCSDOutputFile->putOneLine(theStr);// write out correlation function results and stuff	sprintf(theStr, "%s\t%5hi\n", "NumXlsUsed in L/PCF/MCF:", mPrefs->doLMcfPcf ? mStats->numXlsForL : -1);	mCSDOutputFile->putOneLine(theStr);	sprintf(theStr, "%s\t%10.5f\n", "Mean R of Xls used in L/PCF/MCF:", mPrefs->doLMcfPcf ? mStats->newMeanR : -1);	mCSDOutputFile->putOneLine(theStr);		if (mDoSigmas) {		mCSDOutputFile->putOneLine("hDistance(cm)\tL value\tL Mean\tL SD\tLgd value\tLgd Mean\tLgd SD\tPCF\tPCF Mean\tPCF SD\tPCFgd\tPCFgd Mean\tPCFgd SD\tMCF\tMCF Mean\tMCF SD\tMCF3\tMCF3 Mean\tMCF3 SD\tMCFgd\tMCFgd Mean\tMCFgd SD\tMCF3gd\tMCF3gd Mean\tMCF3gd SD\n");		for (i = 1; i <= mStats->numLPoints; i++) {			if (mPrefs->numEnvelopeRuns == 0) {				sprintf(theStr, "%10.5G\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\n", mStats->hDistances[i],					mStats->LValues[i], mStats->LgdValues[i], mStats->PCF[i], mStats->PCFgd[i], mStats->MCF[i], mStats->MCF3[i], mStats->MCFgd[i], mStats->MCF3gd[i]);				mCSDOutputFile->putOneLine(theStr);			} else {				sprintf(theStr, "%10.5G\t", mStats->hDistances[i]);				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LValues[i]))					sprintf(theStr, "%10.5G\t", mStats->LValues[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->LValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->LValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LgdValues[i]))					sprintf(theStr, "%10.5G\t", mStats->LgdValues[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LgdValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->LgdValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LgdValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->LgdValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCF[i]))					sprintf(theStr, "%10.5G\t", mStats->PCF[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFgd[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFgd[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFgdValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFgdValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFgdValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFgdValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3ValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3ValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3ValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3ValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFgd[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFgd[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFgdValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFgdValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFgdValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFgdValuesEnvStdDev[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3gd[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3gd[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3gdValuesEnvMean[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3gdValuesEnvMean[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3gdValuesEnvStdDev[i]))					sprintf(theStr, "%10.5G\n", mStats->MCF3gdValuesEnvStdDev[i]);				else					sprintf(theStr, "\n");				mCSDOutputFile->putOneLine(theStr);			}		}	} else {		mCSDOutputFile->putOneLine("hDistance(cm)\tL value\tL Min\tL Max\tLgd value\tLgd Min\tLgd Max\tPCF\tPCF Min\tPCF Max\tPCFgd\tPCFgd Min\tPCFgd Max\tMCF\tMCF Min\tMCF Max\tMCF3\tMCF3 Min\tMCF3 Max\tMCFgd\tMCFgd Min\tMCFgd Max\tMCF3gd\tMCF3gd Min\tMCF3gd Max\n");		for (i = 1; i <= mStats->numLPoints; i++) {			if (mPrefs->numEnvelopeRuns == 0) {				sprintf(theStr, "%10.5G\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\t%10.5G\t\t\n", mStats->hDistances[i],					mStats->LValues[i], mStats->LgdValues[i], mStats->PCF[i], mStats->PCFgd[i], mStats->MCF[i], mStats->MCF3[i], mStats->MCFgd[i], mStats->MCF3gd[i]);				mCSDOutputFile->putOneLine(theStr);			} else {				sprintf(theStr, "%10.5G\t", mStats->hDistances[i]);				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LValues[i]))					sprintf(theStr, "%10.5G\t", mStats->LValues[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->LValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->LValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LgdValues[i]))					sprintf(theStr, "%10.5G\t", mStats->LgdValues[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LgdValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->LgdValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->LgdValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->LgdValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCF[i]))					sprintf(theStr, "%10.5G\t", mStats->PCF[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFgd[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFgd[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFgdValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFgdValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->PCFgdValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->PCFgdValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3ValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3ValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3ValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3ValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFgd[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFgd[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFgdValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFgdValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCFgdValuesEnvMax[i]))					sprintf(theStr, "%10.5G\t", mStats->MCFgdValuesEnvMax[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3gd[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3gd[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3gdValuesEnvMin[i]))					sprintf(theStr, "%10.5G\t", mStats->MCF3gdValuesEnvMin[i]);				else					sprintf(theStr, "\t");				mCSDOutputFile->putOneLine(theStr);				if (GoodCFVal(mStats->MCF3gdValuesEnvMax[i]))					sprintf(theStr, "%10.5G\n", mStats->MCF3gdValuesEnvMax[i]);				else					sprintf(theStr, "\n");				mCSDOutputFile->putOneLine(theStr);			}		}	}	if (mPrefs->outputCrystals) {// write labels for expanded raw data file		sprintf(theStr, "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",			 "n", "x", "y", "z", "r", "vact", "vext", "s", "id", "near", "dist",			 "vpoly", "edgeToEdge");		mCSDOutputFile->putOneLine(theStr);// write data		for (i=1; i <= mStats->numCrystals; i++) {			mTheXls->FetchItemAt(i, &thisXl);			sprintf(theStr, "%hi\t%1.5f\t%1.5f\t%1.5f\t%1.5f\t%1.5f\t%1.5f\t%hi\t%hi\t%hi\t%1.5f\t%1.5f\t%1.5f\n",				 i, thisXl.ctr.x, thisXl.ctr.y, thisXl.ctr.z, thisXl.r, thisXl.actV, thisXl.extV,				 thisXl.ctrSlice, thisXl.ctrID, thisXl.neighbor, thisXl.ctcDist, thisXl.polyV, thisXl.diffV);			mCSDOutputFile->putOneLine(theStr);		}	}}// ---------------------------------------------------------------------------//		¥ GoodCFVal// ---------------------------------------------------------------------------BooleanCReduceApp::GoodCFVal(double inVal){	if (mDoSigmas) {		if (inVal == 0)	// neither the mean nor the standard deviation will be exactly zero						// if the data was good			return false;	} else {		if (inVal == -(DBL_MAX-1) || inVal == DBL_MAX || isnan(inVal))			return false;	}	return true;}