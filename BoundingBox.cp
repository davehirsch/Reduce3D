// ===========================================================================//	BoundingBox.cp// ===========================================================================//	#include "BoundingBox.h"#include "stdio.h"#include "FixMath.h"#include "CReducePrefs.h"#include "LProgressDialog.h"#include "UModalDialogs.h"#include "SideComp.h"#include "MathStuff.h"#include "ErrorAlert.h"//#include "CrystalHashTable.h"extern long double gPI;// ---------------------------------------------------------------------------//		¥ BoundingBox// ---------------------------------------------------------------------------//	Default ConstructorBoundingBox::BoundingBox()	: SideSet(){	mProgress = nil;	mPtArray = nil;	mInscribedBox = nil;	mExscribedCube = nil;	mTheApp = nil;	theXls = nil;	mPrefs = nil;}// ---------------------------------------------------------------------------//		¥ BoundingBox (myLFileStream*)// ---------------------------------------------------------------------------//	Standard ConstructorBoundingBox::BoundingBox(myLFileStream *inFile)	: SideSet(){	mTheApp = (CReduceApp *) LCommander::GetTopCommander();	mProgress = (LProgressDialog *)		LWindow::CreateWindow( kProgressDialogID, LCommander::GetTopCommander() );	ThrowIfNil_( mProgress );	mPrefs = mTheApp->GetPrefs();	mProgress->SetIncrements(kDefaultNumThermoIncrements);	mPtArray = nil;	mInscribedBox = nil;	mExscribedCube = nil;//	mHashTable = nil;	mShowModels = mPrefs->make3DModel;	theXls = new CrystalArray();	theXls->SetFile(inFile);	theXls->ReadMergeFile();	if (mPrefs->tidyUp) {		theXls->RemoveIllegalOverlaps();	}}// ---------------------------------------------------------------------------//		¥ BoundingBox (BoundingBox&)// ---------------------------------------------------------------------------//	Copy ConstructorBoundingBox::BoundingBox(BoundingBox &inBBox)	: SideSet(inBBox){	mProgress = (LProgressDialog *)		LWindow::CreateWindow( kProgressDialogID, LCommander::GetTopCommander() );	ThrowIfNil_( mProgress );	mShowModels = inBBox.mShowModels;	mPtArray = nil;	xMin = inBBox.xMin;	xMax = inBBox.xMax;	yMin = inBBox.yMin;	yMax = inBBox.yMax;	zMin = inBBox.zMin;	zMax = inBBox.zMax;	mInscribedBox = (inBBox.mInscribedBox == nil ? nil : new SideSet(*(inBBox.mInscribedBox)));	mExscribedCube = (inBBox.mExscribedCube == nil ? nil : new SideSet(*(inBBox.mExscribedCube)));	mTheApp = inBBox.mTheApp;	mPrefs = inBBox.mPrefs;	if (inBBox.theXls)		theXls = new CrystalArray(inBBox.theXls);	else		theXls = nil;}// ---------------------------------------------------------------------------//		¥ BoundingBox// ---------------------------------------------------------------------------voidBoundingBox::Copy(BoundingBox &inBBox){	SideSet::Copy(inBBox);	mPtArray = nil;	if (mInscribedBox != nil)		delete mInscribedBox;	mInscribedBox = new SideSet(*(inBBox.mInscribedBox));	if (mExscribedCube != nil)		delete mExscribedCube;	mExscribedCube = new SideSet(*(inBBox.mExscribedCube));	mTheApp = inBBox.mTheApp;	if (theXls != nil) {		delete theXls;		theXls = nil;	}	if (inBBox.theXls)		theXls = new CrystalArray(inBBox.theXls);}// ---------------------------------------------------------------------------//		¥ ~BoundingBox// ---------------------------------------------------------------------------//	Default DestructorBoundingBox::~BoundingBox(){//	Unlock();	if (mPtArray != nil) {		delete mPtArray;		mPtArray = nil;	}	if (mInscribedBox != nil) {		delete mInscribedBox;		mInscribedBox = nil;	}	if (mExscribedCube != nil) {		delete mExscribedCube;		mExscribedCube = nil;	}	if (mProgress != nil) {		delete mProgress;		mProgress = nil;	}	if (theXls != nil) {		delete theXls;		theXls = nil;	}//	if (mHashTable != nil) {//		delete mHashTable;//		mHashTable = nil;//	}}// ---------------------------------------------------------------------------//		¥ FindConvexHull// ---------------------------------------------------------------------------voidBoundingBox::FindConvexHull(){	short	sideNum=0, edgeNum=0;	short numSides=0;	LStr255 theStr;	//FIX DMH - check this logic	if (((theXls->GetBounds() != kBoundsNone) && CheckedAgainstBounds()) 		&& !(mPrefs->discardNegs && theXls->GetNegRadii())) {			// if we're discarding negatives (and there were negatives discarded), we have to build a sidesBox, because			// the negatives are around the edges!		Crystal thisXl;		for (short i=1; i <= theXls->GetCount(); i++) {			theXls->FetchItemAt(i, &thisXl);			if (!PointInBox(thisXl.ctr)) {				theXls->RemoveItemsAt(1, i);				i--;			}		}		theXls->RebuildLists();	} else {		theXls->SetBounds(kBoundsNone);		mType = kSidesBox;		mPtArray = new NumPtArray(theXls);		FindBoundPoints();		FindCenter();		DiscardInteriorPoints();		FindFirstSide();		while (FindNextEdge(sideNum, edgeNum)) {			FoldEdge(sideNum, edgeNum);			if ((GetCount() >= 10) && (GetCount() % 10 == 0)) {				theStr = (LStr255) "\pFound Side #" + (LStr255)(SInt32) GetCount();				mProgress->SetActionDescriptor(theStr);				mProgress->SetValues(0, 1, 1);			}		}		MakeAllInVects();		// shouldn't need this, but there's some problem occasionally:		Side	curSide;		for (short i = 1; i <= GetCount(); i++) {			curSide = (*this)[i];			AlignSide(curSide);			UpdateSide(i, curSide);		}		FindBetterCenter();	}	mProgress->Hide();	BetterInscribedBox();}// ---------------------------------------------------------------------------//		¥ CheckedAgainstBounds// ---------------------------------------------------------------------------BooleanBoundingBox::CheckedAgainstBounds(){	Crystal *thisXl;	long numOutside = 0;	Point3DFloat Lower, Upper;	Lower = theXls->LowerBound();	Upper = theXls->UpperBound();	mCtr = (Lower + Upper) / 2.0;	mType = kRPBox;	mSideLenX = Upper.x - Lower.x;	mSideLenY = Upper.y - Lower.y;	mSideLenZ = Upper.z - Lower.z;	xMax = yMax = zMax = Upper;	xMin = yMin = zMin = Lower;		theXls->Lock();	for (short i=1; i <= theXls->GetCount(); i++) {		thisXl = (Crystal *) theXls->GetItemPtr(i);		if (!PointInBox(thisXl->ctr)) {			numOutside++;		}	}	theXls->Unlock();	StDialogHandler theHandler(rPPob_DecisionBox, LCommander::GetTopCommander());	LWindow *theDlg = theHandler.GetDialog();	LStaticText *theField = dynamic_cast<LStaticText*>								(theDlg->FindPaneByID(item_NoteST));		if (numOutside > 0) {		LStr255 words("\pThere is a problem: ");		words += (LStr255)(SInt32) numOutside;		words += "\p out of the ";		words += (LStr255)(SInt32) theXls->GetCount();		words += "\p crystals are outside the Bounds stated in the input file.  Do you want ";		words += "\pto toss the crystals outside of the Bounds, or to fit a new bounding box?";		words += "\p  Default choice in 3 sec.";		theField->SetText(words);				LPushButton *theBtn = dynamic_cast<LPushButton*> (theDlg->FindPaneByID(item_AltBtn));		theBtn->SetDescriptor("\pNew Bounding Box");		theBtn = dynamic_cast<LPushButton*> (theDlg->FindPaneByID(item_DefBtn));		theBtn->SetDescriptor("\pToss Out Xls");		unsigned long startTicks = ::TickCount();		MessageT	hitMessage = msg_Nothing;		while (!(hitMessage == msg_AltBtn || hitMessage == msg_DefBtn) && (::TickCount() < startTicks + (60*3))) {			hitMessage = theHandler.DoDialog();		}				if (hitMessage == msg_AltBtn) {			return false;		} else if (hitMessage == msg_DefBtn) {			return true;		} else {	// timed out			if (theXls->GetCount() - numOutside > 1000)				return true;	// bounds okay - don't use bounding box			else				return true;		}	} else {		return true;	}}// ---------------------------------------------------------------------------//		¥ FindBoundPoints// ---------------------------------------------------------------------------// Finds the points with the maximum and minimum values in each dimension.voidBoundingBox::FindBoundPoints(){	NumberedPt thisPt;	short i;	double Dimension;		mPtArray->FetchItemAt(1, &thisPt);	xMin = xMax = yMin = yMax = zMin = zMax = thisPt;	for (i  = 2 ; i  <= mPtArray->GetCount() ; i ++) {		mPtArray->FetchItemAt(i, &thisPt);		if (thisPt.x < xMin.x )			xMin = thisPt;		if (thisPt.x > xMax.x )			xMax = thisPt;		if (thisPt.y < yMin.y )			yMin = thisPt;		if (thisPt.y > yMax.y )			yMax = thisPt;		if (thisPt.z < zMin.z )			zMin = thisPt;		if (thisPt.z > zMax.z )			zMax = thisPt;	}	Dimension = ((xMax.x - xMin.x) + (yMax.y - yMin.y) + (zMax.z - zMin.z)) / 3.0;	mDiscardThreshold = Dimension * kDiscardPointsThreshold;}// ---------------------------------------------------------------------------//		¥ FindCenter// ---------------------------------------------------------------------------/* Given the maximum and minimum values in the x,y, and z dimension, finds a 	point between them all by averaging. This gives a point which is guaranteed 	to be somewhere inside the solid. */voidBoundingBox::FindCenter(){	mCtr.x = (xMax.x + xMin.x) / 2.0;	mCtr.y = (yMax.y + yMin.y) / 2.0;	mCtr.z = (zMax.z + zMin.z) / 2.0;}// ---------------------------------------------------------------------------//		¥ FindBetterCenter// ---------------------------------------------------------------------------/* Finds the average of the coordinates.  If this is inside the BBox (and it	must be), then this point is taken as the new center. */voidBoundingBox::FindBetterCenter(){	Point3DFloat thePt;	thePt = theXls->Average();	if (PointInBox(thePt))		mCtr = thePt;}// ---------------------------------------------------------------------------//		¥ DiscardInteriorPoints// ---------------------------------------------------------------------------/* This routine uses the max and min points of each dimension to construct a box, the inscribed octahedron formed by the mins and maxes in each dimension. All of the points in the set are examined to see if they fall within this box (and not on the edge).  Those that do are discarded, since they automatically won't be on the boundary.  Ideally, this should weed out a considerable number of points so they won't slow the calculation up later.  This inscribed box is superceded by the one made by BetterInscribedBox.  */voidBoundingBox::DiscardInteriorPoints(){	if ((xMax == yMax || xMax == yMin || xMax == zMax || xMax == zMin) ||		 (xMin == yMax || xMin == yMin || xMin == zMax || xMin == zMin) ||		 (yMax == xMax || yMax == xMin || yMax == zMax || yMax == zMin) ||		 (yMin == xMax || yMin == xMin || yMin == zMax || yMin == zMin) ||		 (zMax == xMax || zMax == xMin || zMax == yMax || zMax == yMin) ||		 (zMin == xMax || zMin == xMin || zMin == yMax || zMin == yMin)) {		 mInscribedBox = nil;	} else {		mInscribedBox = new SideSet;		Side thisSide;		thisSide.pt1 = zMax;		thisSide.pt2 = xMax;		thisSide.pt3 = yMin;		mInscribedBox->SetCtr(mCtr);		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMax;		thisSide.pt2 = yMin;		thisSide.pt3 = xMin;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMax;		thisSide.pt2 = xMin;		thisSide.pt3 = yMax;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMax;		thisSide.pt2 = yMax;		thisSide.pt3 = xMax;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = xMax;		thisSide.pt3 = yMax;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = yMax;		thisSide.pt3 = xMin;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = xMin;		thisSide.pt3 = yMin;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = yMin;		thisSide.pt3 = xMax;		mInscribedBox->AlignSide(thisSide);		mInscribedBox->PushSide(thisSide);		mInscribedBox->SetThreshold(0);		mInscribedBox->MakeAllInVects();				short i = 1;		short total = 0;		short numXls = 0;				NumberedPt curPt;//		mProgress->SetPauseClicked(false);		mProgress->Show();		mProgress->SetTitle("\pFinding Convex Hull");		mProgress->SetActionDescriptor("\pDiscarding Interior Points...");		mProgress->SetValues(0, 100, 0);		while (i <= (numXls = mPtArray->GetCount()))	{			mProgress->Progress((i * 100) / numXls);			mPtArray->FetchItemAt(i, &curPt);			if (mInscribedBox->RawPointInBox(curPt)) {				mPtArray->SwapItems(i, mPtArray->GetCount());	// kept for analogy with last version: when testing is done, 																// can be trashed				mPtArray->RemoveItemsAt(1, mPtArray->GetCount());	// kept for analogy with last version	//			mPtArray->RemoveItemsAt(1, i);	// Use me instead once testing is done				total++;			} else				i++;		}		LStr255 theStr;		theStr = "\pDiscarded a total of " + (LStr255)(SInt32)total + "\p points.";		mProgress->SetActionDescriptor(theStr);		mProgress->SetValues(0, 1, 1);		Clear();//		numPoints = mPtArray->GetCount();	}}// ---------------------------------------------------------------------------//		¥ Inflate// ---------------------------------------------------------------------------/*	This expands each vertex of the bounding box by %150 of the radius of the	crystal at that point.  It's not the most efficient algorithm, since it will	do each vertex 3 times. This process ensures that all the crystals will be	inside the bounding box, but creates an artificially low crystal density */voidBoundingBox::Inflate(){	short	i;	Side	curSide;	Crystal thisXl;		for (i = 1; i <= GetCount(); i++) {		FetchItemAt(i, &curSide);		if (theXls->FindCrystalAt(curSide.pt1, &thisXl))			curSide.pt1 += (((curSide.pt1 - mCtr).Unit()) * (thisXl.r * 1.5));		if (theXls->FindCrystalAt(curSide.pt2, &thisXl))			curSide.pt2 += (((curSide.pt2 - mCtr).Unit()) * (thisXl.r * 1.5));		if (theXls->FindCrystalAt(curSide.pt3, &thisXl))			curSide.pt3 += (((curSide.pt3 - mCtr).Unit()) * (thisXl.r * 1.5));		UpdateSide(i, curSide);	}}const short kRoughMCReductionFactor = 10;// ---------------------------------------------------------------------------------//		¥ GetMCVolFracGranularity// ---------------------------------------------------------------------------------floatBoundingBox::GetMCVolFracGranularity(short mode){	long numTries;	switch (mode) {		case kPrefValRough:			numTries = mPrefs->MCReps / kRoughMCReductionFactor;		break;		case kPrefVal:		default:			numTries = mPrefs->MCReps;		break;	}	return (1.0 / numTries);}// ---------------------------------------------------------------------------------//		¥ GetVolumeFraction// ---------------------------------------------------------------------------------/* Since we can't do this accurately enough going crystal-by-crystal, due to possibly	many multiply-intersecting crystals, we'll use a monte carlo method. */floatBoundingBox::GetVolumeFraction(LProgressDialog *inProgress, long Tries, HoleSet *inHoles){	long numInside1=0, numInside2=0, numInside=0;	Point3DFloat boxPt;	Crystal *thisXl;	XlList nearby;	float maxRadius = (mTheApp->GetStats())->maxR;	theXls->Lock();	long numTries;	switch (Tries) {		case kPrefVal:			numTries = mPrefs->MCReps;		break;		case kPrefValRough:			numTries = mPrefs->MCReps / kRoughMCReductionFactor;		break;		default:			numTries = Tries;		break;	}	if (numTries >= 20)		numTries = 20 * (numTries / 20);	// makes it divisible by 100;	if (mPrefs->verbose) {		myLFileStream *mDebugOutputFile;		LStr255 debugStr;		mDebugOutputFile = mTheApp->GetDebugFile();		mDebugOutputFile->OpenDataFork(fsRdWrPerm);		debugStr = "\pVF 1";		mDebugOutputFile->SetMarker(0, streamFrom_End);		mDebugOutputFile->putOneLine(debugStr);		mDebugOutputFile->CloseDataFork();	}#define UseNearby true//	this will give you the exact same "random" simulation every time//	gRandomXSeed =12345678;#if (UseNearby)	ThrowIfNot_(theXls->VerifyList());	if (numTries >= 20) {	// Randomize lots of points in box & keep track of what fraction are in any of the spheres		for (long j=1; j <= numTries/20; j++) {			if (inProgress) inProgress->Progress();			for (long innerJ = 1; innerJ <= 20; innerJ++) {				RandPtInPrimitiveNotHole(boxPt, inHoles);				nearby = theXls->NearbyXls(boxPt, maxRadius);				for (short i = 1; i <= nearby[0]; i++) {					thisXl = (Crystal *) theXls->GetItemPtr(nearby[i]);					if (thisXl->PointInside(boxPt)) {						numInside1++;						break;					}				}				delete[] nearby;			}		}	} else {		for (long j=1; j <= numTries; j++) {			if (inProgress) inProgress->Progress();			RandPtInPrimitiveNotHole(boxPt, inHoles);			nearby = theXls->NearbyXls(boxPt, maxRadius);			for (short i = 1; i <= nearby[0]; i++) {				thisXl = (Crystal *) theXls->GetItemPtr(nearby[i]);				if (thisXl->PointInside(boxPt)) {					numInside1++;					break;				}			}			delete[] nearby;		}	}	numInside = numInside1;#else	if (numTries >= 20) {		for (long j2=1; j2 <= numTries/20; j2++) {			if (inProgress) inProgress->Progress();			for (short innerJ2 = 1; innerJ2 <= 20; innerJ2++) {				RandPtInPrimitiveNotHole(boxPt, inHoles);				for (long k2=1; k2 <= theXls->GetCount(); k2++) {					thisXl = (Crystal *) theXls->GetItemPtr(k2);					if (thisXl->PointInside(boxPt)) {						numInside2++;						break;					}				}			}		}	} else {		for (long j=1; j <= numTries; j++) {			if (inProgress) inProgress->Progress();			RandPtInPrimitiveNotHole(boxPt, inHoles);			for (long k=1; k <= theXls->GetCount(); k++) {				thisXl = (Crystal *) theXls->GetItemPtr(k);				if (thisXl->PointInside(boxPt)) {					numInside2++;					break;				}			}		}	}	numInside = numInside2;#endif	theXls->Unlock();	return ((double) numInside / numTries);}// ---------------------------------------------------------------------------//		¥ RandPtInPrimitiveNotHole// ---------------------------------------------------------------------------voidBoundingBox::RandPtInPrimitiveNotHole(Point3DFloat &outPt, HoleSet *inHoles){	if (inHoles) {		do {			RandPtInPrimitive(outPt);		} while (inHoles->PointInHole(outPt));	} else {		RandPtInPrimitive(outPt);	}}// ---------------------------------------------------------------------------//		¥ MakeRandomSimulation// ---------------------------------------------------------------------------voidBoundingBox::MakeRandomSimulation(double *inRadiiList, LProgressDialog *inProgress, 				Boolean inMatchingCTDataSet, float inVolFraction, HoleSet* inHoles, float betafactorfactor){//	If you uncomment these, you'll get the exact same "random" simulation every time//	gRandomXSeed =12345678;	Crystal	thisXl;	float XlNum;	Boolean badSimulation = true;	nuclProbType	*nuclProb;	short obs1=0, obs2=0;	Boolean intersects;	long	maxPlacingTries = kNumTriesToPlaceXl;//	long	maxPlacingTries = (mPrefs->makeDCEnv) ? kNumTriesToPlaceXl * 10 : kNumTriesToPlaceXl;	theXls->Clear();		if ((nuclProb = theXls->GetNuclProb()) != nil) {		for (short SimTry = 1; SimTry <= kNumSimMakerRestarts && badSimulation; SimTry++) {			theXls->AdjustAllocation(inRadiiList[0]);			try {				for (XlNum = 1; XlNum <= inRadiiList[0]; XlNum++) {					inProgress->Progress(1);	// Spin					long index = XlNum;					thisXl.r = inRadiiList[index];					long numTries = 0;					if (inHoles == nil) {						do {							thisXl.ctr = RandPtInPrimitive(nuclProb);							if (numTries++ > maxPlacingTries) {								throw SimulationErr();							}							intersects = theXls->CrystalIntersects(thisXl, inMatchingCTDataSet, inVolFraction, betafactorfactor);							if (intersects == 1)								obs1++;							if (intersects == 2)								obs2++;						} while (intersects);					} else {						do {							thisXl.ctr = RandPtInPrimitive(nuclProb);							if (numTries++ > maxPlacingTries) {								throw SimulationErr();							}							intersects = theXls->CrystalIntersects(thisXl, inMatchingCTDataSet, inVolFraction, betafactorfactor);							if (intersects == 1)								obs1++;							if (intersects == 2)								obs2++;						} while (intersects || inHoles->PointInHole(thisXl.ctr));					}					theXls->PushXl(thisXl);				}				badSimulation = false;			} catch (SimulationErr) {				// clean up and try again (haven't changed badSimulation)				theXls->Clear();			}		} // end for SimTry	} else {		for (short SimTry = 1; SimTry <= kNumSimMakerRestarts && badSimulation; SimTry++) {			theXls->AdjustAllocation(inRadiiList[0]);			try {				for (XlNum = 1; XlNum <= inRadiiList[0]; XlNum++) {					inProgress->Progress(1);	// Spin					long index = XlNum;					thisXl.r = inRadiiList[index];					long numTries = 0;					if (inHoles == nil) {						do {							RandPtInPrimitive(thisXl.ctr);							if (numTries++ > maxPlacingTries) {								throw SimulationErr();							}							intersects = theXls->CrystalIntersects(thisXl, inMatchingCTDataSet, inVolFraction, betafactorfactor);							if (intersects == 1)								obs1++;							if (intersects == 2)								obs2++;						} while (intersects);					} else {						do {							RandPtInPrimitive(thisXl.ctr);							if (numTries++ > maxPlacingTries) {								throw SimulationErr();							}							intersects = theXls->CrystalIntersects(thisXl, inMatchingCTDataSet, inVolFraction, betafactorfactor);							if (intersects == 1)								obs1++;							if (intersects == 2)								obs2++;						} while (intersects || inHoles->PointInHole(thisXl.ctr));					}					theXls->PushXl(thisXl);				}				badSimulation = false;			} catch (SimulationErr) {				// clean up and try again (haven't changed badSimulation)				theXls->Clear();			}		} // end for SimTry	}	theXls->SortInternalLists();	if (mPrefs->verbose) {		LStr255 debugStr;		myLFileStream *debugOutputFile = mTheApp->GetDebugFile();		debugOutputFile->OpenDataFork(fsRdWrPerm);		debugStr = "\pFailed to place\t";		debugStr += (SInt32) obs1;		debugStr += "\p\tcrystals due to criterion 1, and\t";		debugStr += (SInt32) obs2;		debugStr += "\p\tcrystals due to criterion 2.\n";		debugOutputFile->SetMarker(0, streamFrom_End);		debugOutputFile->putOneLine(debugStr);		debugOutputFile->CloseDataFork();	}		if (badSimulation) {		if (!mPrefs->makeDCEnv) {	// for DC Envelopes, this error msg doesn't apply			ErrorAlert theAlert("\pBad Simulation", "\pCouldn't make IC Simulation for Envelope.  Do not quit - Will try again with finer grain.", 2);		}		throw SimulationErr();	}}// ---------------------------------------------------------------------------//		¥ VolumeMinusGuard// ---------------------------------------------------------------------------/* Returns the volume of the bounding box.  Note that if there are overlapping	triangles on planes, the value will be too high */floatBoundingBox::VolumeMinusGuard(float guardWidth){	HoleSet *holes = mTheApp->GetHoles();	float outVol;	long numBoxPts = 0;	long goodPts = 0;	Point3DFloat tryPoint;	long MCTries = mPrefs->MCReps;	if (!holes) {		switch (mType) {			case kSidesBox:				SideSet *mEC = GetExscribedCube();				for (long i = 1; i <= MCTries; i++) {					mEC->RandPtInPrimitive(tryPoint);					if (RawPointInBox(tryPoint)) {						numBoxPts++;						if (NearestSideDist(tryPoint) > guardWidth) {							goodPts++;						}					}				}				outVol = Volume()*goodPts/numBoxPts;			break;			case kCubeBox:				if (mSideLen - 2 * guardWidth > 0)					outVol = pow((mSideLen - 2 * guardWidth), 3);				else					outVol = 0;			break;			case kRPBox:				if ((mSideLenX - 2 * guardWidth) < 0 ||					(mSideLenY - 2 * guardWidth) < 0 ||					(mSideLenZ - 2 * guardWidth) < 0)					outVol = 0;				else					outVol = ((mSideLenX - 2 * guardWidth) * 						(mSideLenY - 2 * guardWidth) *						(mSideLenZ - 2 * guardWidth));			break;			case kCylBox:				if ((mHeight - 2 * guardWidth) < 0 ||					(mRadius - guardWidth < 0))					outVol = 0;				else					outVol = ((mHeight - 2 * guardWidth) * 						gPI * sqr(mRadius - guardWidth));			break;		}	} else {		switch (mType) {			case kSidesBox:				SideSet *mEC = GetExscribedCube();				for (long i = 1; i <= MCTries; i++) {					mEC->RandPtInPrimitive(tryPoint);					if (RawPointInBox(tryPoint)) {						numBoxPts++;						if ((NearestSideDist(tryPoint) > guardWidth) &&							(holes->NearestHoleDist(tryPoint) > guardWidth)) {							goodPts++;						}					}				}				outVol = Volume()*goodPts/numBoxPts;			break;			case kCubeBox:			case kRPBox:			case kCylBox:				for (long i = 1; i <= MCTries; i++) {					RandPtInPrimitive(tryPoint);					if (RawPointInBox(tryPoint)) {						numBoxPts++;						if ((NearestSideDist(tryPoint) > guardWidth) &&							(holes->NearestHoleDist(tryPoint) > guardWidth)) {							goodPts++;						}					}				}				outVol = Volume()*goodPts/numBoxPts;			break;		}	}	return outVol;}// ---------------------------------------------------------------------------//		¥ PointInBox// ---------------------------------------------------------------------------//BooleanBoundingBox::PointInBox(Point3DFloat &inPt){	if (mType == kSidesBox) {			// if it's inside the inscribed box, which we hope is a cube, then return true		if (mInscribedBox != nil) {			if (mInscribedBox->RawPointInBox(inPt)) {	// this is a fast check, only has 																	// (at most) 8 sides, maybe just math				return true;			}		}			// if it's outside the exscribed box, which is a cube, then return false		if (mExscribedCube != nil) {			if (!mExscribedCube->RawPointInBox(inPt)) {	// this is a really fast check done by math				return false;			}		}	}	return RawPointInBox(inPt);}// ---------------------------------------------------------------------------//		¥ XlTouchesBox// ---------------------------------------------------------------------------//BooleanBoundingBox::XlTouchesBox(Crystal &inXl){	float d = NearestSideDist(inXl.ctr);	return (d <= inXl.r);}// ---------------------------------------------------------------------------//		¥ FindFirstSide// ---------------------------------------------------------------------------/* Finds the first side of the bounding box to start things off.  It does this by using the point with the minimum z-coordinate (zMin) for the first point, rotating a plane around the y-axis to find the second point, and then rotating around the edge defined by the two points to figure out the third. */voidBoundingBox::FindFirstSide(){	NumPtArray coplanars;	NumberedPt thisPt, zMin2, zMin3, betterPt;	short i;		zMin2 = zMin3 = zMax;	for (i  = 1 ; i  <= mPtArray->GetCount() ; i ++) {		mPtArray->FetchItemAt(i, &thisPt);		if (thisPt != zMin) {			if (thisPt.z < zMin2.z ) {				zMin3 = zMin2;				zMin2 = thisPt;			} else if (thisPt.z < zMin3.z ) {				zMin3 = thisPt;			}		}	}		Side thisSide;	thisSide.pt1 = zMin;	thisSide.pt2 = zMin2;	thisSide.pt3 = zMin3;		AlignSide(thisSide);	FindCoplanars(coplanars, thisSide);	while (!VerifySide(thisSide, &betterPt, &coplanars)) {		double dist1 = zMin.Distance(betterPt);		double dist2 = zMin2.Distance(betterPt);		double dist3 = zMin3.Distance(betterPt);		if (myMin(dist1, dist2, dist3) == dist1)			thisSide.pt1 = betterPt;		else if (myMin(dist1, dist2, dist3) == dist2)			thisSide.pt2 = betterPt;		else			thisSide.pt3 = betterPt;		FindCoplanars(coplanars, thisSide);	}	if (coplanars.GetCount() > 0)		DoCoplanars(thisSide, coplanars);	else {		AlignSide(thisSide);		thisSide.MakeInVect(mCtr);		PushSide(thisSide);	}		/*		short otherCoplanars=0, dummy;//	float	lastCoplanarTest;	Matrix4d	trans;	NumberedPt	dummy1, dummy2, newPt, otherPt;	Side thisSide, dumbSide;	NumPtArray coplanars;	dummy1 = dummy2 = zMin;	dummy1.y = zMin.y - 1.0;	dummy2.x = zMin.x - 1.0;	dumbSide.pt1 = zMin;	dumbSide.pt2 = dummy2;	dumbSide.pt3 = dummy1;	// this is the right order: 12 x 13 points towards center		thisSide.pt1 = zMin;	thisSide.pt2 = BendAroundSide(coplanars, zMin, dummy2, dummy1);		// we don't do the coplanars here, because the the plane that		// they are coplanar to isn't a real side of the box	thisSide.pt3 = BendAroundSide(coplanars, zMin, thisSide.pt2, dummy2);	if (coplanars.GetCount() > 0)		DoCoplanars(thisSide, coplanars);	else {		AlignSide(thisSide);		thisSide.MakeInVect(mCtr);		PushSide(thisSide);	}	//	thisSide.pt1 = zMin;//	dummy1 = dummy2 = zMin;//	dummy1.y = zMin.y - 1.0;//	dummy2.y = zMin.x - 1.0;//	thisSide.pt2 = MinThetaPt(zMin, dummy1, zMin, trans, coplanars);//	thisSide.pt3 = mCtr;//				// bends one way along the pt1-pt2 edge//	newPt = BendAroundSide(coplanars, thisSide.pt1, thisSide.pt2, thisSide.pt3);//				// bends other way - only do this for the next coplanar test//	otherPt = BendAroundSide(otherCoplanars, thisSide.pt2, thisSide.pt1, thisSide.pt3);//	lastCoplanarTest = TetrahedronVolume(thisSide.pt1, thisSide.pt2, newPt, otherPt);//	thisSide.pt3 = newPt;//	if ((coplanars > 0) || (lastCoplanarTest < (0.00000000001)))//		DoCoplanars(thisSide);//	else {//		AlignSide(thisSide);//		PushSide(thisSide);//	}*/}// ---------------------------------------------------------------------------//		¥ MinThetaPt// ---------------------------------------------------------------------------/* Finds the point having the minimum angle to the plane of p1, p2 and p3 when it makes a plane with points p1 and p2. The variable coplanars returns the number of additional points coplanar with the point returned and p1 and p2. *//* NO LONGER USED:NumberedPtBoundingBox::MinThetaPt(NumberedPt &inPt1, NumberedPt &inPt2,									 NumberedPt &inPt3, Matrix4d &inMatrix, short &coplanars){	short		i, start, minPoint;	float		minT, newTheta;	NumberedPt		tempPt;	coplanars = 0;	minPoint = 1;	while (((*mPtArray)[minPoint] == inPt1) ||			 ((*mPtArray)[minPoint] == inPt2) ||			 ((*mPtArray)[minPoint] == inPt3))		minPoint++;	tempPt = (*mPtArray)[minPoint];	tempPt = tempPt * inMatrix;	minT = Theta(inPt1.x, inPt1.z, tempPt.x, tempPt.z);	start = minPoint + 1;	for (i = start; i <= mPtArray->GetCount(); i++) {		if (((*mPtArray)[i] != inPt1) &&			 ((*mPtArray)[i] != inPt2) &&			 ((*mPtArray)[i] != inPt3)) {			tempPt = (*mPtArray)[i];			tempPt = tempPt * inMatrix;			newTheta = Theta(inPt1.x, inPt1.z, tempPt.x, tempPt.z);			if (::fabs(newTheta - minT) < kCoplanarThreshold)				(coplanars)++;			else if (newTheta < minT) {					minT = newTheta;					minPoint = i;					coplanars = 0;			}		}	}	if (minT >= 180)		SysBeep(10);   // This should never happen.  There should probably be a warning dialog that something's amiss...	return (*mPtArray)[minPoint];}*/// ---------------------------------------------------------------------------//		¥ Theta// ---------------------------------------------------------------------------/* This function, stolen from Sedgewick, 1983, takes two points and calculates	a number between 0 and 360 which has the same ordering properties as the true	angle between the line defined by the points and horizontal. This is used	instead of an arctan function because it's faster (fewer special cases, no	calls to trig functions). */floatBoundingBox::Theta (float x1, float y1, float x2, float y2){	double	dx, dy, ax, ay, t;		dx = x2 - x1;		ax = ::fabs(dx);		dy = y2 - y1;		ay = ::fabs(dy);		if ((dx == 0.0) && (dy == 0.0))			t = 0.0;		else			t = dy / (ax + ay);		if (dx < 0.0)			t = 2.0 - t;		else if (dy < 0)			t = 4.0 + t;		return (t * 90.0);}  /* Theta function */// ---------------------------------------------------------------------------//		¥ BendAroundSide// ---------------------------------------------------------------------------/* Bends around the edge of the plane defined by pt1, pt2 and pt3 at the	edge defined by pt1 and pt2. Finds the point that makes a side having the	maximum angle between the vectors that go from the common edge (pt1-pt2) to	the third point. The variable coplanars returns the number of additional points	coplanar with the plane defined by the point returned, pt1, and pt2.*/NumberedPt &BoundingBox::BendAroundSide (NumPtArray &coplanars, NumberedPt &inPt1,									NumberedPt &inPt2, NumberedPt &inPt3){	Side	tempSide;	short		i, start, minPoint;	Point3DFloat lastSideOutVect;	double		maxT, newTheta;	NumberedPt		tempPt;	coplanars.Clear();		tempSide.pt1 = inPt1;	tempSide.pt2 = inPt2;	tempSide.pt3 = inPt3;	Side startSide(tempSide);	// copy construct		lastSideOutVect = tempSide.Vect12to3();	minPoint = 1;	while (startSide.PointOnSide((*mPtArray)[minPoint]))		minPoint++;					// can't use any points that make up the current side	tempSide.pt3 = (*mPtArray)[minPoint];	while (tempSide.Area() < kCoplanarThreshold) {	// then collinear points		minPoint++;		while (startSide.PointOnSide((*mPtArray)[minPoint]))			minPoint++;					// can't use any points that make up the current side		tempSide.pt3 = (*mPtArray)[minPoint];	}	maxT = lastSideOutVect.Angle(tempSide.Vect12to3());	start = minPoint + 1;	for (i = start; i <= mPtArray->GetCount(); i++) {		if (!startSide.PointOnSide((*mPtArray)[i])) {			tempSide.pt3 = (*mPtArray)[i];			newTheta = lastSideOutVect.Angle(tempSide.Vect12to3());//			if (::fabs(newTheta - maxT) <= 0)			if (::fabs(newTheta - maxT) <= kCoplanarThreshold)				coplanars.PushPt((*mPtArray)[i]);			else if (newTheta > maxT) {					maxT = newTheta;					minPoint = i;					coplanars.Clear();			}		}	}	tempSide.pt3 = (*mPtArray)[minPoint];	NumberedPt betterPt;	FindCoplanars(coplanars, tempSide);	while (!VerifySide(tempSide, &betterPt, &coplanars)) {		tempSide.pt3 = betterPt;		FindCoplanars(coplanars, tempSide);	}if (!VerifySide(tempSide, &betterPt, &coplanars)) {	SignalPStr_("\pBad News. Hmm.");}		if (maxT < 0 || maxT > gPI)		Throw_(0);   /* This should never happen.  There should probably be a warning dialog that something's amiss... */	return (*mPtArray)[minPoint];//Old Version://	Matrix4d	trans, dummy;//	NumberedPt pt1, pt2, pt3;//	trans = dummy.TransformationMatrix(inPt1, inPt2, inPt3);//	pt1 = inPt1 * trans;//	pt2 = inPt2 * trans;//	pt3 = inPt3 * trans;//	return MinThetaPt(pt1, pt2, pt3, trans, coplanars);}// ---------------------------------------------------------------------------//		¥ FindCoplanars// ---------------------------------------------------------------------------/* Finds all points coplanar with the side. */voidBoundingBox::FindCoplanars (NumPtArray &coplanars, Side &inSide){	Point3DFloat norm = inSide.AwayVect(mCtr);	// orthogonal vect to side; points out	coplanars.Clear();	for (short i = 1; i <= mPtArray->GetCount(); i++) {		if (!inSide.PointOnSide((*mPtArray)[i])) {			double newTheta = norm.Angle((*mPtArray)[i] - inSide.pt1);			if (newTheta - gPI / 2.0 <= kCoplanarThreshold) {	// angle is near 90¡, or less than																// 90¡ (means point is outside																// plane, so include it no matter																// what - by finding that out here,																// we know it must be close) 				coplanars.PushPt((*mPtArray)[i]);			}		}	}}// ---------------------------------------------------------------------------//		¥ VerifySide// ---------------------------------------------------------------------------/* Checks to be sure that new side is not inside any points. */BooleanBoundingBox::VerifySide (Side &inSide, NumberedPt* ioBetterPt, NumPtArray *coplanars){	Point3DFloat away = inSide.AwayVect(mCtr);	double angle, minAngle = gPI;		for (short i = 1; i <= mPtArray->GetCount(); i++) {		NumberedPt curPt = (*mPtArray)[i];		if ((!inSide.PointOnSide(curPt)) &&	// point isn't part of side and...			(coplanars == nil || !coplanars->PointInArray(curPt))) {	// point isn't in coplanars array, if provided			Point3DFloat curVect = curPt - inSide.pt1;			angle = curVect.Angle(away);			if ((angle < gPI / 2.0) && (angle < minAngle)) {				minAngle = angle;				if (ioBetterPt != nil)					*ioBetterPt = curPt;			}		}	}	if (minAngle < gPI / 2.0)		return false;	return true;}// ---------------------------------------------------------------------------//		¥ DoCoplanars// ---------------------------------------------------------------------------/* In the event that we have a bunch of coplanar points on the boundary, we want	to have the most efficient coverage of this area without altering the data.	This way we accomplish this is to find all of the coplanar points, and draw a	2d bounding box around them (egads!).  Then, the most efficient coverage is to	make all of the triangles originate from one point on the boundary and connect	all pairs of consecutive points on the bounding box. The points pt1, pt2 and	pt3 are all in the plane in question... *//* This could be improved to deal with collinear points...  Here's the algorithm idea:	1. You know that ioSide.pt1 & ioSide.pt2 are part of the next side, because they 	were part of the last side.	2. You find the point i whose vector from point 2 makes the biggest angle with	the 2->1 vector.  This is point 3, and it is on the bounding polygon for the	region.  If there are any collinear points, choose the one that's furthest from point 2.	3. You find the point i whose vector from point 3 makes the biggest angle with	the 3->2 vector.  This is point 4, and it is on the bounding polygon for the	region.  If there are any collinear points, choose the one that's furthest from point 3.	[ do 2&3 until you get back to point 1 ]	4.  You now know all the points on the 2-D bounding curve.  Toss out all the others.	5.  Make the sides like: 1-2-3, 1-3-4, 1-4-5, 1-5-6, etc.*/voidBoundingBox::DoCoplanars (Side &ioSide, NumPtArray &coplanars){	short	i, bigAnglePt;	double maxAngle, testAngle, testDist, bigAngleDist;	Boolean backToPt1 = false;	Point3DFloat  vectNtoNm1, vectNtoi, vectNto1, temp;	NumPtArray planarArray, bb2d;	planarArray.PushPt(ioSide.pt3);	for (i = 1; i <= coplanars.GetCount(); i++)		planarArray.PushPt(coplanars[i]);		if (GetCount() > 0) {		bb2d.PushPt(ioSide.pt1);		bb2d.PushPt(ioSide.pt2);	} else {	/* When this function is called from FindFirstSide, there are no sides yet found, so we get here.		In that case, ioSide.p1 and ioSide.pt2 may *not* in fact be at the edge of the 2d bounding box.		So the first thing we'll do is find points on the edge of the set. */		// find an extreme point, by picking the furthest point from a randomly chosen one (ioSide.pt1).  This point		// must be along an edge.		planarArray.PushPt(ioSide.pt2);		planarArray.PushPt(ioSide.pt1);		float curDist, farDist = 0;		NumberedPt	thisPt, farPt;		short	farPtNum = -1;		for (i = 1; i <= planarArray.GetCount(); i++) {			planarArray.FetchItemAt(i, &thisPt);			curDist = ioSide.pt1.Distance(thisPt);			if (curDist > farDist) {				farDist = curDist;				farPt = thisPt;				farPtNum = i;			}		}		bb2d.PushPt(farPt);		planarArray.RemoveItemsAt(1, farPtNum);				// next, we wish to find a point that makes the largest angle with some point in the set, using our extreme point		// as the vertex.  Should there be more than one with the same angle (i.e., collinear), we want the one		// furthest from our extreme point.  We'll use ioSide.pt2 as our random point.		Point3DFloat vectRandToXtrm, vectNtoXtrm;		NumberedPt	maxAnglePt;		short	maxAnglePtNum;		vectRandToXtrm = farPt - ioSide.pt2;		maxAngle = 0;		bigAngleDist = 0;		for (i = 1; i <= planarArray.GetCount(); i++) {			planarArray.FetchItemAt(i, &thisPt);			vectNtoXtrm = farPt - thisPt;			testAngle = vectRandToXtrm.Angle(vectNtoXtrm);			testDist = vectNtoXtrm.Magnitude();			if ((testAngle > maxAngle) || ((testAngle == maxAngle) && (testDist > bigAngleDist))) {				maxAngle = testAngle;				maxAnglePt = thisPt;				maxAnglePtNum = i;				bigAngleDist = testDist;			}		}		bb2d.PushPt(maxAnglePt);		planarArray.RemoveItemsAt(1, maxAnglePtNum);	}	while (!backToPt1) {		maxAngle = 0;		bigAngleDist = 0;		temp = bb2d[bb2d.GetCount()-1];		vectNtoNm1 = temp - bb2d[bb2d.GetCount()];		for (i=1; i <= planarArray.GetCount(); i++) {			temp = planarArray[i];			vectNtoi = temp - bb2d[bb2d.GetCount()];			testAngle = vectNtoNm1.Angle(vectNtoi);			temp = planarArray[i];			testDist = bb2d[bb2d.GetCount()].Distance(temp);			if ((testAngle == maxAngle && testDist > bigAngleDist) || (testAngle > maxAngle)) {				maxAngle = testAngle;				bigAnglePt = i;				bigAngleDist = testDist;			}		}		temp = bb2d[1];		vectNto1 = temp - bb2d[bb2d.GetCount()];		testAngle = vectNtoNm1.Angle(vectNto1);		if (testAngle > maxAngle) {			backToPt1 = true;		} else {			bb2d.PushPt(planarArray[bigAnglePt]);			planarArray.RemoveItemsAt(1, bigAnglePt);		}	}	for (i = 2; i <= bb2d.GetCount() - 1; i++) {		Side newSide;		newSide.pt1 = bb2d[1];		newSide.pt2 = bb2d[i];		newSide.pt3 = bb2d[i+1];		AlignSide(newSide);		newSide.MakeInVect(mCtr);		newSide.edge1 = CheckSides(newSide.pt1, newSide.pt2);		newSide.edge2 = CheckSides(newSide.pt2, newSide.pt3);		newSide.edge3 = CheckSides(newSide.pt1, newSide.pt3);		PushSide(newSide);//		UpdateSide(GetCount(), newSide);	}	//	short		i;//	Matrix4d trans, dummy;//	NumPtArray planarArray;//	short	numPlanars=0, numBox, minPt;//	float	minAngle, v, tempAngle;//	NumberedPt	tempPt;//	trans = dummy.TransformationMatrix(ioSide.pt1, ioSide.pt2, ioSide.pt3);///*// First find all coplanar points, rotated to z == 0//	for (i = 1; i <= mPtArray->GetCount(); i++) {//			tempPt = (*mPtArray)[i];//			tempPt = tempPt * trans;//			if (tempPt.z == 0.0) {//					numPlanars++;//					tempPt.seq = i;  		// Store original array position in seq for later reference//					planarArray.PushPt(tempPt);//			}//	}//	ThrowIf_(numPlanars<4);//*///	coplanars.PushPt(ioSide.pt1);//	coplanars.PushPt(ioSide.pt2);//	coplanars.PushPt(ioSide.pt3);//	for (i = 1; i <= coplanars.GetCount(); i++) {//		tempPt = coplanars[i];//		tempPt = tempPt * trans;//		numPlanars++;//		tempPt.seq = i;  		// Store original array position in seq for later reference//		planarArray.PushPt(tempPt);//	}//// Next find the lowest point (minimum y)//	minPt = 1;//	for (i = 2; i<= numPlanars; i++)//		if (planarArray[i].y < planarArray[minPt].y)//			minPt = i;//	tempPt = planarArray[minPt];////	planarArray.PushPt(tempPt);//	minAngle = 0.0;//	numBox = 0;//// Now, go through the array, and put the bounding box points at the beginning.//	do {//		numBox++;//		planarArray.SwapItems(numBox, minPt);//		minPt = numPlanars + 1;//		v = minAngle;//		minAngle = 360.0;//		for (i = numBox + 1; i <= numPlanars + 1; i++) {//				tempAngle = Theta(planarArray[numBox].x, planarArray[numBox].y,//										planarArray[i].x, planarArray[i].y);//				if (tempAngle > v)//					if (tempAngle < minAngle) {//							minPt = i;//							minAngle = tempAngle;//					}//		}//	} while (!(minPt == numPlanars + 1));//// Lastly, make a bunch of triangles!  Remember that numSides has already been incremented in the calling routine (FoldEdge)//	for (i = 2; i <= numBox - 1; i++) {//		Side newSide;//		newSide.pt1 = coplanars[planarArray[1].seq];//		newSide.pt2 = coplanars[planarArray[i].seq];//		newSide.pt3 = coplanars[planarArray[i+1].seq];//		AlignSide(newSide);//		newSide.MakeInVect(mCtr);//		PushSide(newSide);//		newSide.edge1 = CheckSides(newSide.pt1.seq, newSide.pt2.seq);//		newSide.edge2 = CheckSides(newSide.pt2.seq, newSide.pt3.seq);//		newSide.edge3 = CheckSides(newSide.pt1.seq, newSide.pt3.seq);//		UpdateSide(GetCount(), newSide);//	}//// Used to say here: "As an afterthought, put all points within (i.e. not on)//// the plane bounding box to the end of pArray, since they can't be in the 3d box,//// and they might as well not slow down future calculations..."  But, since we then//// decremented the index (*numPts), we effectively removed these points from ALL//// further consideration.  That's what I do here instead.  We keep the swapping for//// analogy with version 2.1////	for (i = numBox + 1; i <= numPlanars; i++) {////		mPtArray->SwapItems(planarArray[i].seq, mPtArray->GetCount());////		mPtArray->RemoveItemsAt(1, mPtArray->GetCount());////	}}   /* DoCoplanars procedure */// ---------------------------------------------------------------------------//		¥ CheckSides// ---------------------------------------------------------------------------/* This routine is used for bookkeeping -- once a new side is found, it looks	through all of the extant sides and sees if the new side adjoins any -- if	so, the appropriate sides are marked as "FINISHED". */shortBoundingBox::CheckSides (Point3DFloat inPt1, Point3DFloat inPt2){	short result = kUnfinished;	Side curSide;	short numSides = GetCount();	short i;		for (i=1; i <= numSides && result != kFinished; i++) {		curSide = (*this)[i];		if (((inPt1 == curSide.pt1) && (inPt2 == curSide.pt2)) ||			 ((inPt1 == curSide.pt2) && (inPt2 == curSide.pt1)))	{				curSide.edge1 = kFinished;				result = kFinished;		} else if (((inPt1 == curSide.pt2) && (inPt2 == curSide.pt3)) ||					  ((inPt1 == curSide.pt3) && (inPt2 == curSide.pt2))) {				curSide.edge2 = kFinished;				result = kFinished;		} else if (((inPt1 == curSide.pt3) && (inPt2 == curSide.pt1)) ||					  ((inPt1 == curSide.pt1) && (inPt2 == curSide.pt3))) {				curSide.edge3 = kFinished;				result = kFinished;		}	}	// this increments i when it leaves, even though the condition was false, so		// we need to:	i--;	if (result == kFinished) {		UpdateSide(i, curSide);	}	return result;}// ---------------------------------------------------------------------------//		¥ FindNextEdge// ---------------------------------------------------------------------------/* This routine looks through the list of sides and finds the next edge which	is unfinished (i.e. only has one surface attached to it).  Returns the number	of the side and edge which it selects.  The boolean value returned is true if	it finds something, or false if it does not (i.e. everything is finished!) */BooleanBoundingBox::FindNextEdge (short &nextSide, short &nextEdge){	Side curSide;	short numSides = GetCount();		nextEdge = 0;	for (short i=1; (i <= numSides) && (nextEdge == 0); i++) {		curSide = (*this)[i];		if (curSide.edge1 == kUnfinished ) {			nextEdge = 1;			nextSide = i;		} else if (curSide.edge2 == kUnfinished ) {			nextEdge = 2;			nextSide = i;		} else if (curSide.edge3 == kUnfinished ) {			nextEdge = 3;			nextSide = i;		}	}	return (nextEdge > 0);}  /* FindNextEdge procedure */// ---------------------------------------------------------------------------//		¥ FoldEdge// ---------------------------------------------------------------------------/* This routine takes one side and finds the next one adjoining one of its edges.	The edge dealt with is specified in the variable "nextEdge": 1 == between points	1 and 2, 2 == between points 2 and 3, and 3 == between points 3 and 1. */voidBoundingBox::FoldEdge (short nextSide, short nextEdge){	NumberedPt newPt;	short	edgeVal=0;	NumPtArray coplanars;	Side	newSide, curSide;		curSide = (*this)[nextSide];	if (nextEdge == 1 ) {		newPt = BendAroundSide(coplanars, curSide.pt1, curSide.pt2, curSide.pt3);		newSide.pt1 =  curSide.pt2;		newSide.pt2 =  curSide.pt1;		curSide.edge1 = kFinished;	}	if (nextEdge == 2 ) {		newPt = BendAroundSide(coplanars, curSide.pt2, curSide.pt3, curSide.pt1);		newSide.pt1 =  curSide.pt3;		newSide.pt2 =  curSide.pt2;		curSide.edge2 = kFinished;	}	if (nextEdge == 3 ) {		newPt = BendAroundSide(coplanars, curSide.pt3, curSide.pt1, curSide.pt2);		newSide.pt1 =  curSide.pt1;		newSide.pt2 =  curSide.pt3;		curSide.edge3 = kFinished;	}	UpdateSide(nextSide, curSide);	newSide.pt3 = newPt;	Boolean goodSide = VerifySide(newSide, nil, nil);	if (goodSide) {		if (coplanars.GetCount() > 0 )			DoCoplanars(newSide, coplanars);		else {			AlignSide(newSide);			newSide.MakeInVect(mCtr);			newSide.edge1 = CheckSides(newSide.pt1, newSide.pt2);			newSide.edge2 = CheckSides(newSide.pt2, newSide.pt3);			newSide.edge3 = CheckSides(newSide.pt3, newSide.pt1);			PushSide(newSide);		}	}}// ---------------------------------------------------------------------------//		¥ SurfaceArea// ---------------------------------------------------------------------------floatBoundingBox::SurfaceArea(){	float	area = 0.0;	switch (mType) {		case kCubeBox:			area = GetSideLen() * GetSideLen() * 6.0;		break;		case kRPBox:			area = 2.0 * (GetXLen() * GetYLen() + GetXLen() * GetZLen() + GetZLen() * GetYLen());		break;		case kCylBox:			area = 2.0 * gPI * sqr(GetRadius()) + GetHeight() * 2.0 * gPI * GetRadius();		break;		case kSidesBox:			short	i;			Side	curSide;						for (i = 1; i <= GetCount(); i++) {				curSide = (*this)[i];				area += curSide.Area();			}		break;	}	return area;}// ---------------------------------------------------------------------------//		¥ GetXls// ---------------------------------------------------------------------------CrystalArray *BoundingBox::GetXls(){	return theXls;}// ---------------------------------------------------------------------------//		¥ GetMaxDimension// ---------------------------------------------------------------------------floatBoundingBox::GetMaxDimension(){	float outMax;	switch (mType) {		case kCubeBox:			outMax = GetSideLen() * sqrt(3.0);		break;		case kRPBox:			outMax = sqrt(sqr(GetXLen()) + sqr(GetYLen()) + sqr(GetZLen()));		break;		case kCylBox:			outMax = sqrt(sqr(2*GetRadius()) + sqr(GetHeight()));		break;		case kSidesBox:				// This is a quick hack to get a reasonably large dimension, but will not be the				//	true maximum dimension.  However, we probably don't really care about that,				//	since the KValue at that length scale will be meaningless.			outMax = myMax(xMax.Distance(xMin), yMax.Distance(yMin), zMax.Distance(zMin));		break;		default:			Throw_(0);		break;	}	return outMax;}// ---------------------------------------------------------------------------//		¥ GetMinDimension// ---------------------------------------------------------------------------floatBoundingBox::GetMinDimension(){	float outMin;		switch (mType) {		case kCubeBox:			outMin = GetSideLen();		break;		case kRPBox:			outMin = myMin(GetXLen(), GetYLen(), GetZLen());		break;		case kCylBox:			outMin = min(GetRadius()*2, GetHeight());		break;		case kSidesBox:				// This is a quick hack to get a reasonably small dimension, but will not be the				//	true minimum dimension.			outMin = myMin(xMax.Distance(xMin), yMax.Distance(yMin), zMax.Distance(zMin));		break;		default:			Throw_(0);		break;	}	return outMin;}// ---------------------------------------------------------------------------//		¥ GetPercentSphereInside// ---------------------------------------------------------------------------/* Although there are probably more elegant ways to do this, we'll use a Monte Carlo	to minimize programming time.  We get even sampling over a sphere by randomizing	an azimuth in the x-y plane, and then randomizing a normalized inclination. */floatBoundingBox::GetPercentSphereInside(Point3DFloat inCtr, float inRadius, short inNumSpherePts){// this will slow things down.  Trust the caller to have checked.//	if (NearestSideDist(inCtr) > inRadius)//		return 1.0;	long	numInBox = 0;	double azimuth;	Point3DFloat thisPt;	double	radiusAtZ;		for (long i = 1; i <= inNumSpherePts; i++) {//old://		inclination = asin(1.0 - 2.0 * RandomDbl(0, 1));	// have to normalize in order//		thisPt.z = inRadius * sin(inclination);				// to not oversample poles		thisPt.z = inRadius * cos(RandomDbl(0, gPI));		radiusAtZ = sqrt(sqr(inRadius) - sqr(thisPt.z));		azimuth = RandomDbl(0, 2*gPI);		thisPt.x = radiusAtZ * cos(azimuth);		thisPt.y = radiusAtZ * sin(azimuth);		thisPt += inCtr;		if (BoundingBox::PointInBox(thisPt))			numInBox++;	}	return ((float) numInBox / (float) inNumSpherePts);}// ---------------------------------------------------------------------------//		¥ NearestSideDist// ---------------------------------------------------------------------------/* NearestSide -- The distance from a point to the nearest side of the bounding	box. From CRC Handbook, 25th edition, p.297 */doubleBoundingBox::NearestSideDist(Point3DFloat &inPt){	float xDist, yDist, zDist;	Point3DFloat pt1, pt2, pt3;	Side thisSide;	switch (mType) {		case kCubeBox:			xDist = (mSideLen / 2.0) - ::fabs(inPt.x - (mCtr.x + mOffset.x));			yDist = (mSideLen / 2.0) - ::fabs(inPt.y - (mCtr.y + mOffset.y));			zDist = (mSideLen / 2.0) - ::fabs(inPt.z - (mCtr.z + mOffset.z));			return myMin(xDist, yDist, zDist);		break;		case kRPBox:			xDist = (mSideLenX / 2.0) - ::fabs(inPt.x - (mCtr.x + mOffset.x));			yDist = (mSideLenY / 2.0) - ::fabs(inPt.y - (mCtr.y + mOffset.y));			zDist = (mSideLenZ / 2.0) - ::fabs(inPt.z - (mCtr.z + mOffset.z));			return myMin(xDist, yDist, zDist);		break;		case kCylBox:			float rDist;			rDist = mRadius - sqrt(sqr(inPt.x - (mCtr.x + mOffset.x)) +														sqr(inPt.y - (mCtr.y + mOffset.y)));			zDist = (mHeight / 2.0) - ::fabs(inPt.z - (mCtr.z + mOffset.z));			return min(rDist, zDist);		break;		case kSidesBox:			double	minDist, thisDist;			float	a, b, c, d;		/* coefficients of the plane equation */			short	numSides;			numSides = GetCount();			minDist = HUGE_VAL;			for (short i  = 1 ; i  <= numSides; i ++) {				thisSide = (*this)[i];				pt1 = thisSide.pt1;				pt2 = thisSide.pt2;				pt3 = thisSide.pt3;				a = (pt2.y - pt1.y) * (pt3.z - pt1.z);				a -= (pt2.z - pt1.z) * (pt3.y - pt1.y);				b = (pt2.z - pt1.z) * (pt3.x - pt1.x);				b -= (pt2.x - pt1.x) * (pt3.z - pt1.z);				c = (pt2.x - pt1.x) * (pt3.y - pt1.y);				c -= (pt2.y - pt1.y) * (pt3.x - pt1.x);				d = -(pt1.x * a) - (pt1.y * b) - (pt1.z * c);				thisDist = ::fabs(a * inPt.x + b * inPt.y + c * inPt.z + d) / sqrt(a * a + b * b + c * c);				if (thisDist < minDist )					minDist = thisDist;			}   /* for i */		return minDist;		break;		default:			Throw_(0);		break;	}	SignalPStr_("\pShouldn't Be Here!");	return positiveInfinity; 	// should never get here!}   /* NearestSide function */// ---------------------------------------------------------------------------//		¥ BetterInscribedBox// ---------------------------------------------------------------------------voidBoundingBox::BetterInscribedBox(){	// First, delete the old inscribed box made in DiscardInteriorPoints	if (mInscribedBox != nil) {		delete mInscribedBox;		mInscribedBox = nil;	}	if (mType == kRPBox) {//		mInscribedBox = new SideSet(*this);//		mExscribedCube = new SideSet;//		mExscribedCube->SetCtr(mCtr);//		mExscribedCube->SetType(kCubeBox);//		mExscribedCube->SetSideLen(myMax(mSideLenX, mSideLenY, mSideLenZ));		mInscribedBox = mExscribedCube = nil;	} else {		// no Bounding Rectangular Prism given			NumberedPt			xMin, xMax, yMin, yMax, zMin, zMax;		float					increment;		increment = GetMinDimension() / 100.0;				// Push each point out from the center in the six orthogonal directions, by 1% increments,		// until it's just outside the box, then pull it back by one increment.  The octahedron		// formed by these points is a decent inscribed box, having 8 sides, but we still have to		// do PointInBox side by side.				xMin = mCtr;		xMax = mCtr;		yMin = mCtr;		yMax = mCtr;		zMin = mCtr;		zMax = mCtr;				do {			xMin.x -= increment;		} while (PointInBox(xMin));		xMin.x += increment;		do {			yMin.y -= increment;		} while (PointInBox(yMin));		yMin.y += increment;		do {			zMin.z -= increment;		} while (PointInBox(zMin));		zMin.z += increment;				do {			xMax.x += increment;		} while (PointInBox(xMax));		xMax.x -= increment;				do {			yMax.y += increment;		} while (PointInBox(yMax));		yMax.y -= increment;		do {			zMax.z += increment;		} while (PointInBox(zMax));		zMax.z -= increment;				SideSet *OctahedronBox;		OctahedronBox = new SideSet;		OctahedronBox->SetType(kSidesBox);		OctahedronBox->SetCtr(mCtr);		OctahedronBox->SetThreshold(mDiscardThreshold);		Side thisSide;		thisSide.pt1 = zMax;		thisSide.pt2 = xMax;		thisSide.pt3 = yMin;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMax;		thisSide.pt2 = yMin;		thisSide.pt3 = xMin;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMax;		thisSide.pt2 = xMin;		thisSide.pt3 = yMax;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMax;		thisSide.pt2 = yMax;		thisSide.pt3 = xMax;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = xMax;		thisSide.pt3 = yMax;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = yMax;		thisSide.pt3 = xMin;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = xMin;		thisSide.pt3 = yMin;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		thisSide.pt1 = zMin;		thisSide.pt2 = yMin;		thisSide.pt3 = xMax;		OctahedronBox->AlignSide(thisSide);	// shouldn't need this, but...		OctahedronBox->PushSide(thisSide);		OctahedronBox->MakeAllInVects();					// We make the inscribed cube, the cube that just fits inside the box		float nearDist = NearestSideDist(mCtr) / sqrt(3.0);				//	we divide by sqrt(3) because we're setting a perpendicular length, but the				//	nearest side could be as far off of that as the (1 1 1) face.				// If the distance were to the (1 1 1) face, then dividing by sqrt(3) would				//	turn it into the correct orthogonal distance.		SideSet *CubeBox;		CubeBox = new SideSet;		CubeBox->SetCtr(mCtr);		CubeBox->SetType(kCubeBox);		CubeBox->SetThreshold(mDiscardThreshold);		CubeBox->SetSideLen(nearDist);				float tempLen;		// we expand the inscribed cube until one of it's corners is outside the BBox		while (PrimitiveInBox(CubeBox)) {			tempLen = CubeBox->GetSideLen();			CubeBox->SetSideLen(tempLen+increment);		}		// ...and then shrink it by one increment		tempLen = CubeBox->GetSideLen();		CubeBox->SetSideLen(tempLen-increment);				if (mInscribedBox != nil) {			delete mInscribedBox;	// should never need to get here, I think.  Just in case, though...			mInscribedBox = nil;		}			// We test the incsribed cube to see how much volume it has relative to the octahedron.			// If the cube is much smaller (by 50%), then we don't use the cube.			// We give the cube an advantage since it is so much faster to calculate.			float CubeVolume = pow(CubeBox->GetSideLen(), 3);		if (OctahedronBox->Volume() < (CubeVolume * 1.5)) {			delete OctahedronBox;			mInscribedBox = CubeBox;		} else {			delete CubeBox;			mInscribedBox = OctahedronBox;		}			// We make the exscribed cube, the cube that just fits around the whole box		float farXlDist = 0;		Point3DFloat farDistPt;		float thisDist;		Crystal *thisXl;		theXls->Lock();		for (short i = 1; i <= theXls->GetCount(); i++) {			thisXl = (Crystal *) theXls->GetItemPtr(i);			thisDist = thisXl->ctr.Distance(mCtr);			if (thisDist > farXlDist) {				farXlDist = thisDist;			}		}		theXls->Unlock();					// delete the earlier excribed cube, if it exists		if (mExscribedCube) delete mExscribedCube;		mExscribedCube = new SideSet;		mExscribedCube->SetCtr(mCtr);		mExscribedCube->SetThreshold(mDiscardThreshold);		mExscribedCube->SetType(kCubeBox);		mExscribedCube->SetSideLen(farXlDist*2.0);				// This is only the right length if farDistPt is in one of the principal directions				// we shrink the exscribed cube until there's a point outside it...		while (mExscribedCube->AllPointsInBox(theXls)) {			tempLen = mExscribedCube->GetSideLen();			mExscribedCube->SetSideLen(tempLen-increment);		}		// ...and then expand it by one increment		tempLen = mExscribedCube->GetSideLen();		mExscribedCube->SetSideLen(tempLen+increment);	}}// ---------------------------------------------------------------------------//		¥ PrimitiveInBox// ---------------------------------------------------------------------------/*	For the Cube and the Rectangular Prism, we just test each of the vertices to	see if they are inside the box.  For the Cylinder, this won't work, so instead	we test 200 points along the top and bottom circles to see if they are all in the	box.*/BooleanBoundingBox::PrimitiveInBox(SideSet *inPrim){	Point3DFloat thisPt;	Point3DFloat theCtr = inPrim->GetCtr();	float theSide;	switch (inPrim->GetType()) {		case kCubeBox:			theSide = inPrim->GetSideLen();			thisPt.x = theCtr.x - theSide / 2;			thisPt.y = theCtr.y - theSide / 2;			thisPt.z = theCtr.z - theSide / 2;			if (!PointInBox(thisPt))	// try (0,0,0)				return false;			thisPt.y = theCtr.y + theSide / 2;			if (!PointInBox(thisPt))	// try (0,1,0)				return false;			thisPt.x = theCtr.x + theSide / 2;			if (!PointInBox(thisPt))	// try (1,1,0)				return false;			thisPt.y = theCtr.y - theSide / 2;			if (!PointInBox(thisPt))	// try (1,0,0)				return false;			thisPt.z = theCtr.z + theSide / 2;			if (!PointInBox(thisPt))	// try (1,0,1)				return false;			thisPt.x = theCtr.x - theSide / 2;			if (!PointInBox(thisPt))	// try (0,0,1)				return false;			thisPt.y = theCtr.y + theSide / 2;			if (!PointInBox(thisPt))	// try (0,1,1)				return false;			thisPt.x = theCtr.x + theSide / 2;			if (!PointInBox(thisPt))	// try (1,1,1)				return false;		break;		case kRPBox:			thisPt.x = theCtr.x - inPrim->GetXLen() / 2;			thisPt.y = theCtr.y - inPrim->GetYLen() / 2;			thisPt.z = theCtr.z - inPrim->GetZLen() / 2;			if (!PointInBox(thisPt))	// try (0,0,0)				return false;			thisPt.y = theCtr.y + inPrim->GetYLen() / 2;			if (!PointInBox(thisPt))	// try (0,1,0)				return false;			thisPt.x = theCtr.x + inPrim->GetXLen() / 2;			if (!PointInBox(thisPt))	// try (1,1,0)				return false;			thisPt.y = theCtr.y - inPrim->GetYLen() / 2;			if (!PointInBox(thisPt))	// try (1,0,0)				return false;			thisPt.z = theCtr.z + inPrim->GetZLen() / 2;			if (!PointInBox(thisPt))	// try (1,0,1)				return false;			thisPt.x = theCtr.x - inPrim->GetXLen() / 2;			if (!PointInBox(thisPt))	// try (0,0,1)				return false;			thisPt.y = theCtr.y + inPrim->GetYLen() / 2;			if (!PointInBox(thisPt))	// try (0,1,1)				return false;			thisPt.x = theCtr.x + inPrim->GetXLen() / 2;			if (!PointInBox(thisPt))	// try (1,1,1)				return false;		break;		case kCylBox:						// Find points on top and bottom circles of the cylinder.  We'll optimize this by calculating the offset			//	from the circle center to each point in the positive 45 degree octant, and then use symmetry to find the other points			short numOctantPoints = 25;			for (short i = 1; i <= numOctantPoints; i++) {				// theta is the angle in radians that corresponds to the i / numOctantPoints fraction of 45 degrees (pi/4)				float theta = (gPI / 4.0) * (float) i / (float) numOctantPoints;				// xOffset and yOffset are the components of a vector from the center of the circle to the point on the 				//	circle theta radians clockwise from North				float xOffset = inPrim->GetRadius() * sin(theta);				float yOffset = inPrim->GetRadius() * cos(theta);				float zOffset = inPrim->GetHeight() / 2.0;				// For each theta value, find 16 points that use the same X&Y offset values (some switched)								for (short xSign = -1; xSign <= 1; xSign += 2) {					for (short ySign = -1; ySign <= 1; ySign += 2) {						for (short zSign = -1; zSign <= 1; zSign += 2) {							Point3DFloat offsetVector (xOffset * xSign, yOffset * ySign, zOffset * zSign);							thisPt = theCtr + offsetVector;							if (!PointInBox(thisPt)) return false;							Point3DFloat offsetVectorSwitched (yOffset * ySign, xOffset * xSign, zOffset * zSign);							thisPt = theCtr + offsetVectorSwitched;							if (!PointInBox(thisPt)) return false;						}					}				}			}			return true;		break;		case kSidesBox:		default:			Throw_(0);		break;	}	return true;}// ---------------------------------------------------------------------------//		¥ SetOffset// ---------------------------------------------------------------------------voidBoundingBox::SetOffset(Point3DFloat &inPt){	mInscribedBox->SetOffset(inPt);	mExscribedCube->SetOffset(inPt);	SideSet::SetOffset(inPt);}// ---------------------------------------------------------------------------//		¥ AdjustToBounds// ---------------------------------------------------------------------------/*	After adjusting the bounds of the Crystal Array, we come here.  In AdjustToBounds,	we adjust the boundary values of the SideSet (this), and we remove any crystals	that are outside the new bounds */voidBoundingBox::AdjustToBounds(){	if ((mType == kCubeBox) || (mType == kRPBox)) {		Point3DFloat Lower, Upper;		Lower = theXls->LowerBound();		Upper = theXls->UpperBound();		xMax = yMax = zMax = Upper;		xMin = yMin = zMin = Lower;		mCtr = (Lower + Upper) / 2.0;		mType = kRPBox;		mSideLenX = Upper.x - Lower.x;		mSideLenY = Upper.y - Lower.y;		mSideLenZ = Upper.z - Lower.z;	} else {	// then primitive is cylinder		mHeight = theXls->GetHeight();		mRadius = theXls->GetRadius();		mCtr = theXls->GetCtr();		mType = kCylBox;		xMax = yMax = zMax = xMin = yMin = zMin = mCtr;		xMax.x = mCtr.x + mRadius;		xMin.x = mCtr.x - mRadius;		yMax.y = mCtr.y + mRadius;		yMin.y = mCtr.y - mRadius;		zMax.z = mCtr.z + 0.5 * mHeight;		zMin.z = mCtr.z - 0.5 * mHeight;	}	for (short i=1; i <= theXls->GetCount(); i++) {		Crystal *thisXl = (Crystal *) theXls->GetItemPtr(i);		if (!PointInBox(thisXl->ctr)) {			theXls->RemoveItemsAt(1, i);			i--;		}	}}