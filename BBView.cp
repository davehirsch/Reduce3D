//**************************************************************************************// Filename:	BBView.cp// Copyright © 1997 <YourNameHere>. All rights reserved.//// Description:	////**************************************************************************************// Revision History:// Thursday, February 6, 1997 - Original//**************************************************************************************#include "BBView.h"#include "CReduceApp.h"#include "ReduceConstants.h"#include "BoundingBox.h"//**************************************************************************************// Function:	CreateBBViewStream//// Description: Creates a New BBView object from the data in a Stream.//// Inputs:	inStream	the source stream for the data//		// Outputs:	none	////**************************************************************************************BBView*	BBView::CreateBBViewStream( PP::LStream	*inStream){	// extract any data specific to your class		// Then pass the rest of the stream to the base class	return (new BBView(inStream));}//**************************************************************************************// Function:	Default Constructor//// Description: Builds the BBView class.//// Inputs:	none//		// Outputs:	none	////**************************************************************************************BBView::BBView(){}//**************************************************************************************// Function:	Stream Constructor//// Description: Builds the BBView class from a PP Stream//// Inputs:	inStream//		// Outputs:	none	////**************************************************************************************BBView::BBView(PP::LStream *inStream)	: PP::LView(inStream){	::SetRect(&BBRect,0,0, k_InitialGWSize, k_InitialGWSize);	mTheBBImageGW = nil;	mTempPicture = nil;	mThePicParams.hRes = mThePicParams.vRes = k72dpi;	mThePicParams.version = -2;	mThePicParams.reserved1 = mThePicParams.reserved2 = 0;}//**************************************************************************************// Function:	Copy Constructor//// Description: Copies the BBView class.//// Inputs:	inOriginal	- The object to copy//		// Outputs:	none	////**************************************************************************************BBView::BBView(const BBView& inOriginal)	: PP::LView(inOriginal){}//**************************************************************************************// Function:	Destructor//// Description: Destroys the BBView class.//// Inputs:	none//		// Outputs:	none	////**************************************************************************************BBView::~BBView(){	if (mTheBBImageGW != nil) {		delete mTheBBImageGW;		mTheBBImageGW = nil;	}	if (mTempPicture != nil) {		::KillPicture(mTempPicture);		mTempPicture = nil;		Assert_(QDError() == noErr);	}}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidBBView::FinishCreateSelf(){	mImageChanged = true;	// so it will draw the first time	Show();}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------voidBBView::DrawSelf(){	if (mImageChanged)		PlotBBToGW();	CopyGWToMe();}//#include "PixMapWindow.h"// ---------------------------------------------------------------------------//		¥ PlotBBToGW// ---------------------------------------------------------------------------voidBBView::PlotBBToGW(){	mTheApp = (CReduceApp *) PP::LCommander::GetTopCommander();	mBBox = mTheApp->GetBBox();	mMyWindow = mBBox->GetBBWindow();	::SetRect(&BBRect,0,0, k_InitialGWSize, k_InitialGWSize);	mThePicParams.srcRect = BBRect;	Try_ {				//	LEAKY!!! - can be temp after dont need PixMapWindow to debug	//		LGWorld *tempBigGW = new PP::LGWorld(BBRect);			PP::LGWorld tempBigGW(BBRect);				if (mTempPicture != nil) {			::KillPicture(mTempPicture);			mTempPicture = nil;			Assert_(QDError() == noErr);		}		mTempPicture = ::OpenCPicture(&mThePicParams);			ApplyForeAndBackColors();			// all drawing happens here			ActuallyCalcAndDrawBBox(BBRect);		::ClosePicture();		Assert_(QDError() == noErr);		tempBigGW.BeginDrawing();			::EraseRect(&((**mTempPicture).picFrame));			::DrawPicture(mTempPicture, &((**mTempPicture).picFrame));		tempBigGW.EndDrawing();		mTheBBImageGW = new PP::LGWorld(BBRect);		::ForeColor(blackColor);		::BackColor(whiteColor);		::CopyBits(	(BitMap *) **(&(tempBigGW.GetMacGWorld())->portPixMap),						(BitMap *) **(&(mTheBBImageGW->GetMacGWorld())->portPixMap),					&BBRect, &BBRect, srcCopy, nil);				// adjust origin of GWorld, and BBRect to match		::OffsetRect(&BBRect, -BBRect.left, -BBRect.top);		mTheBBImageGW->SetBounds(BBRect);//new PixMapWindow(mTheBBImageGW, false);		mImageChanged = false;			// adjust max window size to be size of BBRect		Rect winMinMaxSize;		winMinMaxSize.top = winMinMaxSize.left = 100;		winMinMaxSize.bottom = BBRect.bottom - BBRect.top + PP::ScrollBar_Size - 2;		winMinMaxSize.right = BBRect.right - BBRect.left + PP::ScrollBar_Size - 2;		mMyWindow->SetMinMaxSize(winMinMaxSize);		PP::SDimension16 StdSize = {winMinMaxSize.right, winMinMaxSize.bottom};		Rect screenRect = (**(::GetMainDevice())).gdRect;			// The standard size should be the maximum size, unless that is larger			// than can be displayed on the screen, in which case it should be the screen size		if (StdSize.width > screenRect.right-screenRect.left)			StdSize.width = screenRect.right-screenRect.left;		if (StdSize.height > screenRect.bottom-screenRect.top)			StdSize.height = screenRect.bottom-screenRect.top;		mMyWindow->SetStandardSize(StdSize);			// BBRect will likely get resized in ActuallyCalcAndDrawBBox;			// we should adjust the image size to match it		ResizeImageTo(BBRect.right - BBRect.left, BBRect.bottom - BBRect.top, false);	} Catch_ (err) {		if (mTheBBImageGW != nil) {			delete mTheBBImageGW;			mTheBBImageGW = nil;		}		delete this;		if (err == iMemFullErr)			throw AllocFailed();		else			Throw_(err);	}}// ---------------------------------------------------------------------------//		¥ CopyGWToMe// ---------------------------------------------------------------------------voidBBView::CopyGWToMe(){	FocusDraw();	::RGBForeColor(&myBlackColor);	::RGBBackColor(&myWhiteColor);		Rect	frame;	CalcLocalFrameRect(frame);		::CopyBits((BitMap *) **(&(mTheBBImageGW->GetMacGWorld())->portPixMap),				&GetMacPort()->portBits,				&frame, &frame, srcCopy, nil);}#include <stdio.h>#include <string.h>// ---------------------------------------------------------------------------//		¥ ActuallyCalcAndDrawBBox// ---------------------------------------------------------------------------voidBBView::ActuallyCalcAndDrawBBox(Rect &inRect){	short	i;	Point3DFloat	vect1, vect2, xP, viewpoint, projAxis, unitAxis,						xFigAxis, xFigUnitAxis, yFigUnitAxis, zUnit, paperAxis,						bVect,	/* vector from viewpoint to point in xyz space */						sVect,	/* vector parallel to bVect that just hits the "paper" */						rVect;	/* vector from figure origin (where center projects) to projected point */	float	dotProduct=0, xScale=kScale, yScale=kScale, dotP=0;	Point	vertex1, vertex2, vertex3;	short		minX=9999, minY=9999;	short		maxX=0, maxY=0;	short		j;	PP::LStr255	theStr;	short width;	short	vOriginOffset = (inRect.right - inRect.left)/2;	short hOriginOffset = (inRect.bottom - inRect.top)/2;		::SetOrigin(-vOriginOffset,-hOriginOffset);	// puts (0,0) in the middle of the drawable area	Rect offsetBoundRect = {inRect.top, inRect.left, inRect.bottom, inRect.right};	::OffsetRect(&offsetBoundRect, -vOriginOffset, -hOriginOffset);	::ClipRect(&offsetBoundRect);	// makes the cipping rect the whole drawable area	viewpoint.x = (30/kPerspective)*mBBox->xMax.x - mBBox->mCtr.x;	viewpoint.y = (20/kPerspective)*mBBox->yMax.y - mBBox->mCtr.y;	viewpoint.z = (10/kPerspective)*mBBox->zMax.z - mBBox->mCtr.z;	projAxis = mBBox->mCtr - viewpoint;	unitAxis = projAxis.Unit();	paperAxis = unitAxis * 1;;	zUnit.z = 1.0;	xFigAxis = zUnit % unitAxis;	xFigUnitAxis = xFigAxis.Unit();	yFigUnitAxis = xFigAxis % unitAxis;		for (j=0; j<=2; j++) {//		::PenMode(patOr);		if (j == 0) {	// first time through, to set x, y scales (doesn't draw anything)			;		} else if (j == 1) {			::ForeColor(yellowColor);			xScale *= (1.0*kPicSize/(1.0*(maxX - minX)));			yScale *= (1.0*kPicSize/(1.0*(maxY - minY)));			minX = minY = 9999;	// reset mins & maxes at beginning of 2nd pass			maxX = maxY = -9999;		} else { 	// (j == 2)			::ForeColor(blackColor);		}		for (i  = 1 ; i  <= mBBox->GetCount() ; i ++) {	// for each side...			vect1 = (*mBBox)[i].pt2 - (*mBBox)[i].pt1;			vect2 = (*mBBox)[i].pt3 - (*mBBox)[i].pt1;			xP = vect1 % vect2;			bVect = (*mBBox)[i].pt1 - viewpoint;			sVect = bVect * 1/(bVect * paperAxis);			rVect = sVect - paperAxis;			vertex1.h = xScale * (rVect * xFigUnitAxis);	// auto rounding			vertex1.v = yScale * (rVect * yFigUnitAxis);	// auto rounding			AdjustLimits(vertex1.h, vertex1.v, &minX, &maxX, &minY, &maxY);			bVect = (*mBBox)[i].pt2 - viewpoint;			sVect = bVect * 1/(bVect * paperAxis);			rVect = sVect - paperAxis;			vertex2.h = xScale * (rVect * xFigUnitAxis);	// auto rounding			vertex2.v = yScale * (rVect * yFigUnitAxis);	// auto rounding			AdjustLimits(vertex2.h, vertex2.v, &minX, &maxX, &minY, &maxY);			bVect = (*mBBox)[i].pt3 - viewpoint;			sVect = bVect * 1/(bVect * paperAxis);			rVect = sVect - paperAxis;			vertex3.h = xScale * (rVect * xFigUnitAxis);	// auto rounding			vertex3.v = yScale * (rVect * yFigUnitAxis);	// auto rounding			AdjustLimits(vertex3.h, vertex3.v, &minX, &maxX, &minY, &maxY);			if (j >= 1) {	// second & third time through						// Dot Product is positive if both vectors point with 90 degrees						// of each other. (i.e., front side)				if ((j==1) && (xP * viewpoint) <= 0)	// back side - 2nd pass					MyFillTriangle(vertex1, vertex2, vertex3);				else if ((j==2) && (xP * viewpoint) > 0)	// front side - 3rd pass					MyDrawTriangle(vertex1, vertex2, vertex3);			}		}	}	::ForeColor(blackColor);	maxX += 1;	maxY += 1;	::MoveTo(maxX, (maxY+minY)/2);	theStr = "\p3D Bounding Box. VE=" + FltStr(yScale/xScale, 2);	width = ::StringWidth(theStr);	maxX += width;	::DrawString(theStr);	::SetOrigin(0,0);		// reset coords to (0,0) at top left		// adjust mins & maxes to new coords;	maxX += hOriginOffset;	minX += hOriginOffset;	maxY += vOriginOffset;	minY += vOriginOffset;	SetRect(&inRect, minX, minY, maxX, maxY);	::InsetRect(&inRect, -4, -4);		// leave a border around image}// ---------------------------------------------------------------------------//		¥ AdjustLimits// ---------------------------------------------------------------------------voidBBView::AdjustLimits(short x, short y, short *minX, short *maxX, short *minY, short *maxY){	if (x < *minX)		*minX = x;	if (x > *maxX)		*maxX = x;	if (y < *minY)		*minY = y;	if (y > *maxY)		*maxY = y;}// ---------------------------------------------------------------------------//		¥ MyDrawTriangle// ---------------------------------------------------------------------------voidBBView::MyDrawTriangle(Point pt1, Point pt2, Point pt3){//	::ForeColor(blackColor);	::MoveTo(pt1.h, pt1.v);	::LineTo(pt2.h, pt2.v);	::LineTo(pt3.h, pt3.v);	::LineTo(pt1.h, pt1.v);}// ---------------------------------------------------------------------------//		¥ MyFillTriangle// ---------------------------------------------------------------------------voidBBView::MyFillTriangle(Point pt1, Point pt2, Point pt3){	PolyHandle triPoly;		triPoly = ::OpenPoly();	::MoveTo(pt1.h, pt1.v);	::LineTo(pt2.h, pt2.v);	::LineTo(pt3.h, pt3.v);	::ClosePoly();//	::ForeColor(yellowColor);//	::PenMode(srcOr);	::FillPoly(triPoly, &qd.ltGray);//	::ForeColor(cyanColor);	::PenPat(&qd.dkGray);	::FramePoly(triPoly);	::PenPat(&qd.black);	if (QDError() != noErr)		;	::KillPoly(triPoly);}