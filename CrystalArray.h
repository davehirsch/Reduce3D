// =================================================================================//	CrystalArray.h 					// =================================================================================#pragma once#include <LArray.h>#include "Crystal.h"#include "myLFileStream.h"#include "LProgressDialog.h"#include "CReducePrefs.h"#include "ReduceConstants.h"typedef struct {	short halfSines;	short	start;	float minProb;} nuclProb1D;typedef struct {	nuclProb1D x;	nuclProb1D y;	nuclProb1D z;} nuclProbType;typedef struct {	short	index;	float	location;} XYZListElement;const short kArrayIncrement = 10;typedef short *	XlList;class CrystalArray: public PP::LArray {	public:	// Exception Classes		class ArrayIOErr {};		class	BadOrderErr {			public:				short expectedNum;				short foundNum; };		class MemErr{};		class PSRProblem {};		public:							CrystalArray(								long		inNumExpected = 0,								PP::LComparator		*inComparator = nil,								Boolean			inKeepSorted = false);							CrystalArray(CrystalArray &inXls);							CrystalArray(CrystalArray *inXls);							~CrystalArray();		Crystal			PopXl();		void				PushXl(Crystal &inXl);		Boolean			RemoveFromList(XYZListElement *inList, float inVal, long inIndex);		void				AddToList(XYZListElement *inList, float inVal, long inIndex, long *ioListSizeAlloc);		void				Clear();		void				Copy(CrystalArray *inXls);		inline void		SetFile(myLFileStream *inFile) {mFile = inFile;};		void				ReadMergeHeader();		void				ReadMergeFile();		void				UpdateXl(short index, Crystal inXl);		inline PP::LStr255	&GetIntComment() {return mIntComment;};		inline float	GetFileVolume() {return mTotalVolume;};		void				GetFileName(Str63 ioStr);		Boolean			CrystalIntersects(Crystal &inXl, Boolean inMatchingCTDataSet, float inVolFraction=0, float betafactorfactor=0);		Boolean			FindCrystalAt(Point3DFloat inPt, Crystal *thisXl);		Point3DFloat	&Average();		double			AverageRad();		inline Boolean	HasBounds() {return mHasBounds;};		inline Point3DFloat &							LowerBound() {return mLower;};		inline Point3DFloat &							UpperBound() {return mUpper;};		inline void		SetHasBounds(Boolean inHasBounds) {mHasBounds = inHasBounds;};		inline void		SetLower (Point3DFloat inLower) {mLower = inLower;};		inline void		SetUpper (Point3DFloat inUpper) {mUpper = inUpper;};		inline short	GetNegRadii() {return mNegRadii;};		inline LProgressDialog *							GetProgress() {return mProgress;};		void				FilterForObservability();		void				InitXlArray(CrystalArray *inXls);		nuclProbType*	GetNuclProb();		float				GetMeanRadius();		void				ChangeRadii(double *outRadiiList, float inDelta);		Boolean			AdjustLocations();		XlList			NearbyXls(Point3DFloat inPt, float inDistance);		void				SortInternalLists();		void				QuickSortXYZList(XYZListElement *inList, short inSize);		XYZListElement *ResizeList(XYZListElement *inList, long ioListSizeAlloc);		short				NearbyCount(XYZListElement *inList, float inVal, float inDistance,											short &outLowerIndex, short &outUpperIndex);		virtual void		RemoveItemWithLists(PP::ArrayIndexT inAtIndex);		void				RebuildLists();		void				CorrectForImpingement();		void				RemoveIllegalOverlaps();		float				CorrectedCrystalVolume(Crystal *inXl);		void				KillLists() {mListSize = 0;};		Boolean			VerifyList();//XYZListElement *inList);//		void				MakeNearbyXlsList(XYZListElement *inList, short *ioNearbyList,//										 short *ioNLUsed, short inLower, short inUpper);//		void				WinnowNearbyList(XYZListElement *inList, float inVal, float inDistance, short *ioNearbyList, short *ioNLUsed);//		void				SortXlList(short *inList, short inSize);//		void				QuickSortXlList(short *inList, short inSize);//		void				ShellSortXlList(short *inList, short inSize);	protected:		myLFileStream		*mFile;		PrefStruct			*mPrefs;		fileTypes			mFileType;		PP::LStr255			mIntComment;		short					mNumCrystals;		float					mTotalVolume;		LProgressDialog 	*mProgress;		Boolean				mHasBounds;		Point3DFloat		mLower, mUpper;		short					mNegRadii;		nuclProbType		*mNuclProb;		XYZListElement		*mXList;//		XYZListElement		*mYList;//		XYZListElement		*mZList;		long					mListSize;	// number of list items with real data		long					mXListSizeAllocated;//, mYListSizeAllocated, mZListSizeAllocated;		// allocated size};