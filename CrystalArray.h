// =================================================================================//	CrystalArray.h 					// =================================================================================#pragma once#include <LArray.h>#include "Crystal.h"#include "myLFileStream.h"#include "LProgressDialog.h"#include "CReducePrefs.h"#include "ReduceConstants.h"typedef struct {	short halfSines;	short	start;	float minProb;} nuclProb1D;typedef struct {	nuclProb1D x;	nuclProb1D y;	nuclProb1D z;} nuclProbType;typedef struct {	short	index;	float	location;} XYZListElement;const short kArrayIncrement = 10;typedef short *	XlList;class CrystalArray: public LArray {	public:	// Exception Classes		class ArrayIOErr {};		class	BadOrderErr {			public:				short expectedNum;				short foundNum; };		class MemErr{};		class PSRProblem {};		public:							CrystalArray(								long		inNumExpected = 0,								LComparator		*inComparator = nil,								Boolean			inKeepSorted = false);							CrystalArray(CrystalArray &inXls);							CrystalArray(CrystalArray *inXls);							~CrystalArray();		Crystal			PopXl();		void				PushXl(Crystal &inXl);		Boolean			RemoveFromList(XYZListElement *inList, float inVal, long inIndex);		void				AddToList(XYZListElement *inList, float inVal, long inIndex, long *ioListSizeAlloc);		void				Clear();		void				Copy(CrystalArray *inXls);		inline void		SetFile(myLFileStream *inFile) {mFile = inFile;};		void				ReadMergeHeader();		void				ReadMergeFile();		void				UpdateXl(short index, Crystal inXl);		inline LStr255	&GetIntComment() {return mIntComment;};		inline float	GetFileVolume() {return mTotalVolume;};		void				GetFileName(Str63 ioStr);		Boolean			CrystalIntersects(Crystal &inXl, Boolean inMatchingCTDataSet, float inVolFraction=0, float betafactorfactor=0);		Boolean			FindCrystalAt(Point3DFloat inPt, Crystal *thisXl);		Point3DFloat	&Average();		double			AverageRad();		inline boundsTypes						GetBounds() {return mBounds;};		inline Point3DFloat &							LowerBound() {return mLower;};		inline Point3DFloat &							UpperBound() {return mUpper;};		inline void		SetBounds(boundsTypes inBounds) {mBounds = inBounds;};		inline void		SetLower (Point3DFloat inLower) {mLower = inLower;};		inline void		SetUpper (Point3DFloat inUpper) {mUpper = inUpper;};		inline Point3DFloat	&	GetCtr () {return mCtr;};		inline float		GetRadius () {return mRadius;};		inline float		GetHeight () {return mHeight;};		inline void		SetCtr (Point3DFloat inCtr) {mCtr = inCtr;};		inline void		SetRadius (float inRadius) {mRadius = inRadius;};		inline void		SetHeight (float inHeight) {mHeight = inHeight;};		inline short	GetNegRadii() {return mNegRadii;};		inline LProgressDialog *							GetProgress() {return mProgress;};		void				FilterForObservability();		void				InitXlArray(CrystalArray *inXls);		nuclProbType*	GetNuclProb();		float				GetMeanRadius();		void				ChangeRadii(double *outRadiiList, float inDelta);		Boolean			AdjustLocations();		XlList			NearbyXls(Point3DFloat inPt, float inDistance);		void				SortInternalLists();		void				QuickSortXYZList(XYZListElement *inList, short inSize);		XYZListElement *ResizeList(XYZListElement *inList, long ioListSizeAlloc);		short				NearbyCount(XYZListElement *inList, float inVal, float inDistance,											short &outLowerIndex, short &outUpperIndex);		virtual void		RemoveItemWithLists(ArrayIndexT inAtIndex);		void				RebuildLists();		void				CorrectForImpingement();		void				RemoveIllegalOverlaps();		float				CorrectedCrystalVolume(Crystal *inXl);		void				KillLists() {mListSize = 0;};		Boolean			VerifyList();//XYZListElement *inList);	protected:		myLFileStream		*mFile;		PrefStruct			*mPrefs;		fileTypes			mFileType;		LStr255			mIntComment;		short					mNumCrystals;		float					mTotalVolume;		LProgressDialog 	*mProgress;		boundsTypes			mBounds;		Point3DFloat		mLower, mUpper;		Point3DFloat		mCtr;		float				mRadius, mHeight;		short					mNegRadii;		nuclProbType		*mNuclProb;		XYZListElement		*mXList;		long					mListSize;	// number of list items with real data		long					mXListSizeAllocated;//, mYListSizeAllocated, mZListSizeAllocated;		// allocated size};