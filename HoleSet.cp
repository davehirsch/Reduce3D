// ===========================================================================//	HoleSet.cp// ===========================================================================//	#include "HoleSet.h"#include "MathStuff.h"// ---------------------------------------------------------------------------//		¥ HoleSet// ---------------------------------------------------------------------------//	Default ConstructorHoleSet::HoleSet(myLFileStream *inFile)	:CrystalArray(){	SetFile(inFile);	ReadMergeFile();}// ---------------------------------------------------------------------------//		¥ HoleSet// ---------------------------------------------------------------------------//	Default DestructorHoleSet::~HoleSet(){}// ---------------------------------------------------------------------------//		¥ PointInHole// ---------------------------------------------------------------------------BooleanHoleSet::PointInHole(Point3DFloat &inPoint){	Crystal *curXl;	Lock();	for (short i = 1; i <= GetCount(); i++) {		curXl = (Crystal *) GetItemPtr(i);		if ((curXl->ctr.Distance(inPoint) < curXl->r))			return true;	}	Unlock();	return false;}// ---------------------------------------------------------------------------//		¥ NearestHoleDist// ---------------------------------------------------------------------------// returns distance from inPoint to surface of nearest hole (not center)doubleHoleSet::NearestHoleDist(Point3DFloat &inPoint){	double minDist = HUGE_VAL;	double testDist;	short numHoles = GetCount();	Crystal *curXl;	Lock();	for (short i = 1; i <= numHoles; i++) {		curXl = (Crystal *) GetItemPtr(i);		testDist = curXl->ctr.Distance(inPoint) - curXl->r;		if (minDist > testDist)			minDist = testDist;	}	return minDist;}// ---------------------------------------------------------------------------//		¥ TidyCrystalsUp// ---------------------------------------------------------------------------// removes any crystals whose centers are inside a holevoidHoleSet::TidyCrystalsUp(CrystalArray *inXls){	mProgress->SetActionDescriptor("\pRemoving crystals inside holes");	mProgress->SetValues(0, GetCount(), 0);	mProgress->Show();	Crystal *thisHole, *otherXl;	Lock();	inXls->KillLists();	for (short i = 1; i <= GetCount(); i++) {		thisHole = (Crystal *) GetItemPtr(i);		mProgress->Progress(i);		for (short j=1; j <= inXls->GetCount(); j++) {			otherXl = (Crystal *) inXls->GetItemPtr(j);			float separation = thisHole->ctr.Distance(otherXl->ctr);			if (separation < thisHole->r)	{	// if the crystal center is inside the hole				inXls->RemoveItemWithLists(j);			}		}	}	Unlock();	mProgress->Hide();	RebuildLists();}